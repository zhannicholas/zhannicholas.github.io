[{"content":" Stay hungry, Stay foolish\u0026hellip;\u0026hellip;\n ","href":"/","title":"Home"},{"content":"","href":"/blogs/","title":"Blogs"},{"content":"学习笔记\n踩坑日记\n生活杂记\n\u0026hellip;\n","href":"/about/","title":"About"},{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/tags/redis/","title":"Redis"},{"content":"","href":"/tags/","title":"Tags"},{"content":"","href":"/authors/zhannicholas/","title":"zhannicholas"},{"content":"  Redis是一个位于内存中的数据结构存储系统，可用作数据库、缓存和消息中间件。它支持的数据结构有：string、hash、list、set、sorted set with range quries、bitmap、hyperloglogs、geospatial indexes with radius queries以及stream。Redis支持复制、Lua脚本、基于LRU的键驱逐、事务和不同级别的磁盘持久化，并通过哨兵和Redis集群的自动分区机制来保证高可用。\nRedis的存储是基于key-value的，但这里的key-value不是简单的key-value，因为value的类型可以有很多种。在我们传统的key-value存储中，key和value都是字符串，而在Redis中，value不仅可以是字符串，还有可能是像列表、集合这样的复杂的数据结构。\n 本文主要内容包括：Redis的安装、键和几种常见的数据类型的使用，以及和数据生存期相关的一些操作。\n安装Redis 参见Redis Quick Start。\nRedis键 Redis的键是一个字符串。在Redis中，字符串二进制安全的，也就是说：Redis中的字符串可以包含任何类型的数据(比如：一张图片、一个序列化后的Java对象……)，这些也可以成为Redis中的键。\n注意：空字符串(\u0026quot;\u0026quot;)也是一个有效的键。\n数据类型 Strings 字符串(string)是Redis最基本的数据类型，最大不能超过512MB。\nRedis提供了20多个操作string类型的命令。下面是一些例子：\n\u0026gt;\u0026gt; set s1 \u0026quot;Hello, Redis\u0026quot; // 设置s1的值为\u0026quot;Hello, Redis\u0026quot; OK // 成功返回OK \u0026gt;\u0026gt; get s1 // 获取值 \u0026quot;Hello, Redis\u0026quot; \u0026gt;\u0026gt; setnx s1 \u0026quot;Redis\u0026quot; // 尝试为s1设置新值 0 // s1已有值，不进行操作，返回0 \u0026gt;\u0026gt; get s1 \u0026quot;Hello, Redis\u0026quot; \u0026gt;\u0026gt; set s1 2 // 设置值 OK \u0026gt;\u0026gt; get s1 \u0026quot;2\u0026quot; \u0026gt;\u0026gt; incr s1 // 加1 3 \u0026gt;\u0026gt; incrby s1 10 // 加10 13 \u0026gt;\u0026gt; decr s1 // 减1 12 \u0026gt;\u0026gt; decrby s1 5 // 减5 7 \u0026gt;\u0026gt; incrbyfloat s1 1.1 // 加1.1 8.1 \u0026gt;\u0026gt; incrbyfloat s1 -3.1 // 减3.1 5  SET 和 GET 分别用来设置和检索key对应的值(这个值是一个字符串)。需要注意的是，如果某个key已经有对应的值，SET 命令会覆盖掉已有的值(不管之前的值是何种类型都会被覆盖)，和这个key关联的TTL也会被丢弃。如果不希望已有key的值被覆盖，可以使用 SETNX 命令，当key存在时，SETNX 不会进行任何操作。\n虽然值是string，但如果这个值是一个数字的字符串形式的话，可以对其进行加减操作。上面的例子中，s1的值被重新修改为了\u0026quot;2\u0026quot;，随后执行了 INCR 和 INCRBY 两个加法命令，值变成了13，之后的减法命令 DECR 和 DECRBY 将值减到了7。更加有趣的是，Redis还提供了 INCRBYFLOAT 以支持浮点加减运算。\n\u0026gt;\u0026gt; mset s1 1 s2 2 s3 a OK \u0026gt;\u0026gt; mget s1 s2 s3 [ \u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;a\u0026quot; ]  有时候，一次性设置或获取多个值是很有意义的，这可以通过 MSET 和 MGET 命令实现。类似的还有 MSETNX 命令。\nLists 在Redis中，列表(list)表示由一些元素组成的有序序列。通常情况下，List的实现有数组和链表两种方式，两者各有优劣。数组实现的List可以通过索引快速访问元素，但在插入或删除元素的时候较慢；链表实现的List在插入或删除元素时非常迅速，但访问元素时较慢。Redis中的list使用链表实现，因为对于一个数据库系统来说，快速向一个非常长的列表中添加元素至关重要。基于链表的实现还带来了一个重大优势，那就是可以快速的选取列表中的某一部分。\nRedis提供了10多个操作list的命令，下面时一些例子：\n\u0026gt;\u0026gt; lpush list1 a 1 b // 向列表list1的头部依次插入a、1、b这三个元素 3 // 成功插入，当前列表list1含有3个元素 \u0026gt;\u0026gt; lrange list1 0 -1 // 查看list1 1) \u0026quot;b\u0026quot; 2) \u0026quot;1\u0026quot; 3) \u0026quot;a\u0026quot; \u0026gt;\u0026gt; rpush list1 c d // 向列表list1尾部依次插入c、d这两个元素 5 // 插入成功，当前列表list1含有5个元素 \u0026gt;\u0026gt; lrange list1 0 -1 1) \u0026quot;b\u0026quot; 2) \u0026quot;1\u0026quot; 3) \u0026quot;a\u0026quot; 4) \u0026quot;c\u0026quot; 5) \u0026quot;d\u0026quot; \u0026gt;\u0026gt; lpop list1 // 移除并返回列表list1中的第一个元素 b \u0026gt;\u0026gt; rpop list1 // 移除并返回列表list2中的最后一个元素 d \u0026gt;\u0026gt; lrange list2 0 -1 // 列表list2是空的 \u0026gt;\u0026gt; lpop list2 // 从一个空的列表里面移除元素会返回NULL (nil) \u0026gt;\u0026gt; rpop list2 (nil) \u0026gt;\u0026gt; lrange list1 0 -1 1) \u0026quot;1\u0026quot; 2) \u0026quot;a\u0026quot; 3) \u0026quot;c\u0026quot; \u0026gt;\u0026gt; lindex list1 0 // 查看列表list1中处于位置0处的元素 1 \u0026gt;\u0026gt; lindex list1 -1 // 查看列表list1中最后一个元素 c  命令 LPUSH 和 RPUSH 分别用来向列表头部(左侧)和尾部(右侧)添加元素，LPOP 和 RPOP 分别用来从列表头部(左侧)和尾部(右侧)移除元素。在一个空的列表上执行 LPOP 或 RPOP 将返回 NULL 。有时候，我们希望只有当列表中有元素时，才执行POP操作，这时候可以使用 BLPOP 和 BRPOP 。两个命令的都是从列表中移除元素，只是方向不一样。以 BLPOP 为例，BLPOP 的完整命令如下：\nBLPOP key [key ...] timeout  BLPOP 接收一个或多个key以及一个超时时间timeout(可阻塞时间，单位为秒，0代表一直阻塞)。在这些key中，如果有key对应的列表不为空，将会返回第一个非空列表的key及POP出的值。举个例子：\n\u0026gt;\u0026gt; lrange list1 0 -1 // 列表list1包含两个元素 1) \u0026quot;a\u0026quot; 2) \u0026quot;c\u0026quot; \u0026gt;\u0026gt; lrange list2 0 -1 // 列表list2为空 \u0026gt;\u0026gt; blpop list2 list1 0 // list1中的第一个元素被移除 1) \u0026quot;list1\u0026quot; 2) \u0026quot;a\u0026quot;  BLPOP 依次检查list2和list1，然后移除并返回list1的头部元素(list2是一个空列表)。\n如果 BLPOP 命令后面给出的的key对应的都是空列表，BLPOP 就会阻塞当前连接。一旦另外一个客户端向某一个key对应的列表插入元素，BLPOP 就会解除阻塞并返回。若阻塞的时间超过了timeout，将返回NULL。\n若要查看列表中的元素，可以使用 LRANGE 命令，LRANGE 命令需要两个索引作为参数。这两个索引形成一个区间，分别指向待返回的第一个和最后一个元素在列表中的位置。索引可以是负数，0、-1、-2分别代表链表中的第一个、最后一个和倒数第二个元素。除了区间查看外，还可以使用 LINDEX 命令查看指定位置的元素。\n\u0026gt;\u0026gt; llen list1 // 查看列表list1的长度 3 \u0026gt;\u0026gt; ltrim list1 1 2 // 修剪列表list1，只保留位于区间[1,2]中的元素 OK \u0026gt;\u0026gt; lrange list1 0 -1 // 查看list1中所有元素 1) \u0026quot;a\u0026quot; 2) \u0026quot;c\u0026quot;  LLEN 用于查看list的长度。很多时候，我们只需要保留列表中的某一部分，这个时候 LTRIM 就可以排上用场了，它和 LRANGE 类似，也接收两个索引作为参数，但它将列表的内容设置为区间内的元素并去除区间外的所有元素。上面的例子中，LTRIM 告诉Redis只保留列表list1处于区间[1,2]中的元素，然后丢弃其它的元素。\nHashes Redis中的哈希表(hash)是一个字符串类型的field-value映射表，非常适合用来表示对象。\n下面是一些例子：\n\u0026gt;\u0026gt; hset user:1 name Tome // 将哈希表user:1的name字段的值设置为Tome 1 \u0026gt;\u0026gt; hget user:1 name // 获取哈希表user:1中name字段对应的值 Tome \u0026gt;\u0026gt; hmset user:2 name Bob age 20 education barchelor // 一次向哈希表user:2中插入多个filed-value OK \u0026gt;\u0026gt; hmget user:2 name age // 获取哈希表user:2中name和age字段对应的值 [ \u0026quot;Bob\u0026quot;, \u0026quot;20\u0026quot; ] \u0026gt;\u0026gt; hgetall user:2 // 获取哈希表user:2中所有字段和值 { \u0026quot;name\u0026quot;: \u0026quot;Bob\u0026quot;, \u0026quot;age\u0026quot;: \u0026quot;20\u0026quot;, \u0026quot;education\u0026quot;: \u0026quot;barchelor\u0026quot; } \u0026gt;\u0026gt; hget user:1 age // 企图获取一个不存在的字段对应的值，会返回NULL (nil) \u0026gt;\u0026gt; hexists user:1 age // 检查哈希表user:1中是否存在字段age 0 \u0026gt;\u0026gt; hvals user:2 // 返回哈希表user:2中所有的值 [ \u0026quot;Bob\u0026quot;, \u0026quot;20\u0026quot;, \u0026quot;barchelor\u0026quot; ] \u0026gt;\u0026gt; hincrby user:2 age 2 // 将哈希表user:2的age字段对应的值加2 22 \u0026gt;\u0026gt; hget user:2 age 22  Sets Redis中的集合(set)是一个由字符串构成的无序集合。除了基本的插入、删除、存在性检测等操作，Redis还支持集合的交、并、差计算。\n下面是基本操作的一些例子：\n\u0026gt;\u0026gt; sadd set1 red blue white black // 向集合set1中插入4个元素 4 \u0026gt;\u0026gt; smembers set1 // 查看集合set1内容 [ \u0026quot;black\u0026quot;, \u0026quot;white\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;red\u0026quot; ] \u0026gt;\u0026gt; sismember set1 yellow // 检查yellow是否在set1中 0 // 集合set1不包含yellow \u0026gt;\u0026gt; scard set1 // 查看集合set1的基数(元素个数) 4 \u0026gt;\u0026gt; spop set1 // 随机从集合set1中移除一个元素 white \u0026gt;\u0026gt; srem set1 white // 从集合set1中删除一个不存在的元素 0 \u0026gt;\u0026gt; srem set1 black // 从集合set1中删除一个存在的元素 1 \u0026gt;\u0026gt; smembers set1 [ \u0026quot;blue\u0026quot;, \u0026quot;red\u0026quot; ]  下面是集合运算：\n\u0026gt;\u0026gt; sadd set2 a b c red blue gold 6 \u0026gt;\u0026gt; smembers set2 [ \u0026quot;red\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;gold\u0026quot; ] \u0026gt;\u0026gt; sunion set1 set2 // set1 + set2 [ \u0026quot;a\u0026quot;, \u0026quot;blue\u0026quot;, \u0026quot;gold\u0026quot;, \u0026quot;red\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;b\u0026quot; ] \u0026gt;\u0026gt; sinter set1 set2 // set1 x set2 [ \u0026quot;blue\u0026quot;, \u0026quot;red\u0026quot; ] \u0026gt;\u0026gt; sdiff set2 set1 // set2 - set1 [ \u0026quot;a\u0026quot;, \u0026quot;gold\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;b\u0026quot; ] \u0026gt;\u0026gt; sadd set3 f 1 \u0026gt;\u0026gt; sdiff set2 set1 set3 // set2 - set1 - set3 [ \u0026quot;a\u0026quot;, \u0026quot;gold\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;b\u0026quot; ]  Sorted sets Redis中的有序集合(sorted set)和集合(set)类似，存放不重复的字符串。不过，有序集合中的每个元素都有一个对应的浮点分数(score)，这个分数用来维持集合的有序性。由于是有序的，有序集合又具有哈希表的快速访问的优势。\n考虑有序集合中的两个元素A和B，有序集合的有序性基于以下两点：\n 如果A.score \u0026gt; B.score，那么：A \u0026gt; B。 如果A.socre = B.score，A \u0026gt; B的前提是A的字典序大于B。因为集合的元素都是唯一的，A和B的内容不能相同。  下面是一些例子：\n\u0026gt;\u0026gt; zadd z1 2 a -1 b // 向有序集合z1中添加a(score=2)和b(score=-1)， ZADD还可以用来更新元素对应的分数 2 \u0026gt;\u0026gt; zrange z1 0 -1 // 查看z1内容(正序)，因为b.score \u0026lt; a.score，所有b在前面 [ \u0026quot;b\u0026quot;, \u0026quot;a\u0026quot; ] \u0026gt;\u0026gt; zrange z1 0 -1 withscores // 查看z1内容及对应分数 [ \u0026quot;b\u0026quot;, \u0026quot;-1\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;2\u0026quot; ] \u0026gt;\u0026gt; zrevrange z1 0 -1 // 查看z1内容(逆序) [ \u0026quot;a\u0026quot;, \u0026quot;b\u0026quot; ] \u0026gt;\u0026gt; zrangebyscore z1 0 inf // 查看z1中分数在[0, inf)内的内容 [ \u0026quot;a\u0026quot; ] \u0026gt;\u0026gt; zrank z1 b // 查看z1中内容b的排名 0 \u0026gt;\u0026gt; zremrangebyscore z1 -inf -1 // 移除z1中分数位于(-inf,1]的所有元素 1 \u0026gt;\u0026gt; zrange z1 0 -1 [ \u0026quot;a\u0026quot; ]  有序集合还支持很多的命令，比如：ZPOPMAX、ZRANGEBYLEX、ZUNIONSTORE等等。\nBitmaps 严格地说，Bitmap并不是一种新的数据类型，而是基于string的一种数据类型，它提供了一些基于比特位的操作。\n相关的命令分为两种：操作单个比特位的和操作一组比特位的。\n比特位的设置和检索使用的是 BITSET 和 BITGET 命令:\n\u0026gt;\u0026gt; setbit bits 2 1 0 \u0026gt;\u0026gt; getbit bits 2 1 \u0026gt;\u0026gt; getbit bits 1 0  BITSET给指定比特位设置值，然后返回该位置上原来的值，企图使用 BITSET 设置0和1以外的值会导致错误。 BITGET 获取指定位置的值， 如果给定的位置超出了存储用的字符串的长度，将会返回0。\n操作一组比特位的命令分为三种：\n BITOP 进行字符串之间的按位与、按位或、按位异或以及按位取反操作。 BITCOUNT 进行计数操作，返回设置为1的比特位的个数。 BITPOS 寻找给定的0或1出现的第一个位置。  HyperLogLogs Redis使用HyperLogLog进行计数，这个算法是基于统计的。Redis的实现中，标准误差只有1%，并且在最坏的情况下只需要消耗 12KB 的内存。HyperLogLog在技术上是一种不同的数据结构，但也是基于string实现的。\n我们使用 SADD 向集合中添加元素，类似的，我们也可以使用 PFADD 向HyperLogLog中添加元素。实际上，HyperLogLog并不存储我们添加的元素，只是更新内部状态。\n\u0026gt;\u0026gt; pfadd hll a b c d // 向hll中加入四个元素 1 \u0026gt;\u0026gt; type hll // 查看hll类型 string // HyperLogLog实际为string \u0026gt;\u0026gt; pfcount hll // 对hll进行计数 4 \u0026gt;\u0026gt; pfadd hll1 a b c d 1 \u0026gt;\u0026gt; pfadd hll2 c d e f 1 \u0026gt;\u0026gt; pfmerge hll3 hll1 hll2 // 合并hll1和hll2到hll3 OK \u0026gt;\u0026gt; pfcount hll3 6  Geospatial indexes Redis在3.2.0版本中加入了地理空间(geospatial)这一数据类型，并支持索引半径查询功能。一个具体的位置信息由三元组(longtitude, latitude, name)确定，当向某一个key添加数据时，数据会被存储为有序集合，这么做为半径查询 GEORADIU 提供了支持。\n下面是一些例子：\n\u0026gt;\u0026gt; geoadd municipalities 116.4551113869 39.6733986505 beijing 121.6406041505 30.8267595167 shanghai 106.6992091675 29.3055601981 chongqing // 添加3个地理空间数据 3 \u0026gt;\u0026gt; geodist municipalities beijing chongqing // 查看beijing和chongqing直接的距离(单位为米) 1457336.8906 \u0026gt;\u0026gt; georadius municipalities 116 40 1000 km // 查看以经度116、纬度40为中心，1000km为半径内的所有位置 [ \u0026quot;beijing\u0026quot; ] \u0026gt;\u0026gt; geohash municipalities beijing shanghai // 查看beijing和chongqing的Geohash表示 [ \u0026quot;wx4cdn242c0\u0026quot;, \u0026quot;wtqrrgzfzs0\u0026quot; ] \u0026gt;\u0026gt; geopos municipalities chongqing // 查看chongqing的地理空间数据 [ [ \u0026quot;106.69921070337295532\u0026quot;, \u0026quot;29.30556015923176716\u0026quot; ] ] \u0026gt;\u0026gt; georadiusbymember municipalities chongqing 1500 km // 查看以chongqing为中心、1500km为半径内的所有位置 [ \u0026quot;chongqing\u0026quot;, \u0026quot;shanghai\u0026quot;, \u0026quot;beijing\u0026quot; ]  Streams Stream是Redis 5.0中新增加的数据类型，它以更加抽象的方式模拟了日志结构，通常实现为一个仅以追加模式打开的文件。stream涉及到的内容比较多，后面会详细了解。这里先跳过。\n数据过期 我们可以为某个key设置过期时间(expires)。当expires达到时，对应的key就会被自动删除，就像我们显式的执行 DEL 命令一样。过期时间的单位可以是秒，也可以是毫秒。关于expires的信息都存放在磁盘上，且有备份。这意味着，即使Redis服务器停止运行，过期时间仍然会有效。实际上，Redis保存的是key过期的确切时间，而不是剩余生存时间，虽然参数是秒或毫秒。\n下面是一些例子：\n\u0026gt;\u0026gt; set s1 v1 OK \u0026gt;\u0026gt; expire s1 10 // 设置s1于10秒后过期 1 \u0026gt;\u0026gt; ttl s1 // 查看s1的剩余生存时间(单位为秒) 7 \u0026gt;\u0026gt; pttl s1 // 查看s1的剩余生存时间(单位为毫秒) 3042 \u0026gt;\u0026gt; get s1 // 查看s1的值，未经过10秒 \u0026quot;v1\u0026quot; \u0026gt;\u0026gt; get s1 // 查看s1的值，超过10秒，s1已被删除 (nil) \u0026gt;\u0026gt; set s2 v2 ex 10 // 在设置值的同时指定过期时间为10秒 OK \u0026gt;\u0026gt; set s3 v3 px 10000 // 在设置值的同时指定过期时间为10000毫秒 OK  ","href":"/blogs/%E5%88%9D%E8%A7%81redis/","title":"初见Redis"},{"content":"","href":"/tags/linux/","title":"Linux"},{"content":" 快速方法 使用root操作\nStep 1: 添加一个用户 adduser username Step 2: 授予root权限 usermod -aG sudo username 但是\u0026hellip;\u0026hellip; 有些时候，这并不管用\n在vultr新租的Debian VPS上，我想添加sarkar这个用户，并授予它root权限。依然执行了上面的命令，但可怜的sarkar还是一个普通用户。解决方案如下：\nStep1: 安装sudo # apt-get install sudo Step2: 修改/etc/sudoers # cd /etc # chmod +w sudoers # vim sudoers 找到下面内容：\n# User privilege specification root\tALL=(ALL:ALL) ALL 在后面添加一行，声明sarkar的权限：\n# User privilege specification root\tALL=(ALL:ALL) ALL sarkar ALL=(ALL:ALL) ALL 保存并退出。然后：\n# chmod -w sudoers 使/etc/sudoers再次成为不可写的状态。\n现在，sarkar就具有root权限了。\n","href":"/blogs/linux%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8E%88%E4%BA%88root%E6%9D%83%E9%99%90%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/","title":"Linux添加用户并授予root权限的简单方法"},{"content":"","href":"/categories/","title":"Categories"},{"content":"  代理模式（Proxy Pattern）:给某一个对象提供一个代理，并由代理对象控制对原对象的引用。\n 代理模式中引入了一个新的代理对象，代理对象可以在客户端和目标对象之间起到中介作用，去掉客户端不应该看到的内容或服务或者给客户端提供额外的服务。\n结构图 代理模式的结构图如下：\n从结构图可以看出，代理模式主要包含3个角色：\n Suject(抽象主题类)：它声明了真实主题和代理主题共有的接口，似的在任何使用真是主题的地方都可以使用代理主题。 RealSubject(真实主题类)：它定义了代理角色所代表的真是对象，包含真实的业务操作，客户端可以通过代理对象间接的调用真实主题角色中定义的操作。 Proxy(代理类)：代理类包含一个对真实主题类的引用，从而可以在任何时候操纵真实主题对象。通常在代理类中，客户端在调用真实主题的方法的前后还会进行一些其它的操作，这可以由代理类提供。  模式实现 根据代理模式的结构图，可以写出如下的示例代码：\n// 抽象主题接口 public interface Subject { void request(); }// 真实主题类 public class RealSubject implements Subject{ @Override public void request() { System.out.println(\u0026#34;Request of RealSubject instance.\u0026#34;); } }// 代理主题类 public class Proxy implements Subject { // 维持一个对真实主题类的引用  private RealSubject realSubject = new RealSubject(); public void preRequest(){ System.out.println(\u0026#34;PreRequest.\u0026#34;); } public void postRequest(){ System.out.println(\u0026#34;PostRequest.\u0026#34;); } @Override public void request() { preRequest(); System.out.println(\u0026#34;request of Proxy.\u0026#34;); realSubject.request(); postRequest(); } } 测试用的客户端类：\n// 客户端类 public class Client { public static void main(String[] args){ Proxy proxy = new Proxy(); proxy.request(); } } 运行结果：\nPreRequest. request of Proxy. Request of RealSubject instance. PostRequest. 可以发现，客户端通过代理类调用了真实主题类的方法，同时还调用了一些其它的方法。\n几种常用的代理  远程代理（Remote Proxy）: 又称Ambassador，它为一个位于不同地址空间的对象提供一个本地的代理对象。 虚拟代理（Virtual Proxy）： 如果要创建一个资源消耗较大的对象，可以先创建一个资源消耗较小的对象来代替，真实的对象只有在被需要的时候才创建。 保护代理（Protect Proxy）： 控制对一个对象的访问，可以给不同的用户提供不同的反问权限。 缓冲代理（Cache Procy）： 为某一个目标操作的结果提供存储空间，供多个客户端共享。 智能引用代理（Smart Rererence Proxy）： 当一个对象被引用的时候，提供一些额外的操作。  总结 可以根据不同的应用场合选择不同的代理类型。代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合读，符合迪米特法则。客户端可以针对抽象接口编程，增加和更换代理类无须修改原有代码，符合开闭原则，利于系统的扩展。不同类型的代理为不同的应用场景提供合适的解决方案。\n由于代理对象出现在客户端和真实对象之间，这加大了客户端和真实对象之间的距离，可能会降低请求的处理速度。同时，代理模式的实现也需要额外工作，这可能加大系统的复杂性。\n","href":"/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%89%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","title":"《设计模式的艺术》学习笔记之十三：代理模式"},{"content":"","href":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%86%85%E5%8A%9F%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"《设计模式的艺术：软件开发人员内功修炼之道》读书笔记"},{"content":"","href":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"设计模式"},{"content":"  享元模式（Flyweight Pattern）：运行共享技术有效的支持大量 细粒度 对象的复用，又称轻量级模式。\n 享元模式以共享的方式高效的支持大量细粒度对象的重用。实现共享的关键是区分了 内部状态（Intrinsic State） 和 外部状态（Extrinsic State） 。\n 内部状态：内部状态是享元内部不会随着外部条件改变而改变的状态，是可以共享的。 外部状态：外部状态会随着外部条件的改变而改变的状态，是不可共享的。  一旦区分了内部状态和外部状态，就可以将具有相同内部状态的对象存储到享元池中。当需要新的对象的时候，就可以先查看享元池，如果享元池有符合要求的对象，就可以将其取出，再注入不同的外部状态，就可以得到一系列相似的对象，而这些对象在内存中只有一份。\n结构图 享元模式的结构图如下所示：\n从图中可以看出，享元模式主要包含4个角色：\n Flyweight(抽象享元类)：它声明了具体享元类共有的方法，这些方法可以向外部提供对象的内部状态，也可以用来设置对象的外部状态。 ConcreteFlyweight(具体享元类)：它实现了Flyweight类声明的方法，并为具体的享元类提供了存储内部状态需要的空间。 UnsharedConcreteFlyweight(非共享具体享元类)：并不是所有的抽象享元类的子类都要被共享，不能被共享的子类就是非共享具体享元类。当需要一个相关对象的时候，就直接实例化创建了。 FlyweightFactory(享元工厂类)：它被用来创建和管理享元对象，针对Flyweight抽象享元类进行编程。  实际上，由于具体享元类是需要被共享的，所以可以结合单例模式来设计享元类，为每一个享元类都提供一个唯一的享元对象。享元工厂一般也是结合工厂模式来进行设计的。\n模式实现 来看一下中国围棋，围棋的棋盘上只有黑子和白子，不同的是不同棋子的位置不同，所以可以将黑子和白子作为享元对象，对应的坐标作为外部状态，使用享元模式来设计棋盘。结构图如下：\n实现的代码如下：\n// 坐标类 public class Coordinate { private int x; private int y; public int getX() { return x; } public int getY() { return y; } public Coordinate(){} public Coordinate(int x, int y) { this.x = x; this.y = y; } }// 抽象棋子类 public abstract class GoChessman { public abstract String getColor(); public void display(Coordinate coordinate){ System.out.println(this.getColor() + \u0026#34;: (\u0026#34; + coordinate.getX() + \u0026#34;, \u0026#34; + coordinate.getY() + \u0026#34;).\u0026#34;); } }// 白子 public class WhiteGoChessman extends GoChessman { @Override public String getColor() { return \u0026#34;white\u0026#34;; } }// 黑子 public class BlackGoChessman extends GoChessman { @Override public String getColor() { return \u0026#34;black\u0026#34;; } }// 棋子工厂 public class GoChessmanFactory { private static GoChessmanFactory instance = new GoChessmanFactory(); private static HashMap\u0026lt;String, GoChessman\u0026gt; chessmanMap; private GoChessmanFactory(){ chessmanMap = new HashMap\u0026lt;\u0026gt;(); GoChessman blackGoChessman, whiteGoChessman; blackGoChessman = new BlackGoChessman(); whiteGoChessman = new WhiteGoChessman(); chessmanMap.put(\u0026#34;black\u0026#34;, blackGoChessman); chessmanMap.put(\u0026#34;white\u0026#34;, whiteGoChessman); } public static GoChessmanFactory getInstance() { return instance; } public GoChessman getGoChessman(String color){ return chessmanMap.get(color); } } 测试用的客户端代码：\n// 客户端 public class Client { public static void main(String[] args){ // 获取享元工厂对象  GoChessmanFactory goChessmanFactory = GoChessmanFactory.getInstance(); // 产生棋子  GoChessman black1 = goChessmanFactory.getGoChessman(\u0026#34;black\u0026#34;); GoChessman black2 = goChessmanFactory.getGoChessman(\u0026#34;black\u0026#34;); // 判断两颗黑子是否相同  System.out.println(\u0026#34;black1 == black2: \u0026#34; + (black1 == black2)); // 获取两颗白子  GoChessman white1 = goChessmanFactory.getGoChessman(\u0026#34;white\u0026#34;); GoChessman white2 = goChessmanFactory.getGoChessman(\u0026#34;white\u0026#34;); // 判断两颗黑子是否相同  System.out.println(\u0026#34;white1 == white2: \u0026#34; + (white1 == white2)); // 设置坐标并展示  black1.display(new Coordinate(1, 1)); black2.display(new Coordinate(2, 2)); white1.display(new Coordinate(3, 3)); white2.display(new Coordinate(4, 4)); } } 运行结果：\nblack1 == black2: true white1 == white2: true black: (1, 1). black: (2, 2). white: (3, 3). white: (4, 4). 可以发现：使用同一个关键字从享元池取出来的对象是都是同一个，后期可以设置不同对象的外部状态，使得所有的对象具有差异。\n总结 当系统中存在大量相同或者相似的对象的时候，这会浪费大量的内存，可以使用享元模式处理这个问题。通过享元池，可以实现相同或者相似的细粒度对象的复用，这能节省内存空间，提高系统性能。相同的对象因为内部状态的相同而相同，相似的对象因为外部状态的不同而不同，并且它们都是独立的。但是，使用享元模式会使系统变得复杂，将对象的部分状态外部化可能使得系统的运行时间变长。\n","href":"/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%BA%8C%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","title":"《设计模式的艺术》读书笔记之十二：享元模式"},{"content":"  外观模式（Facade Pattern）：外部与一个子系统的通信通过一个统一的外观角色进行，为子系统中的一组接口提供一个统一的入口。外观模式又称门面模式，它定义了一个高层接口，这个接口使得子系统的使用更加容易。\n 外观模式隐藏了系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。\n结构图 为了更好的理解外观模式，先来看一下示意图：\n从上图可以看出：如果没有外观角色，每个客户端都可能需要和多个子系统之间进行复杂的交互，系统的耦合度非常大。引入外观角色facade之后，客户端就只需要和外观角色交互了，外观角色代替客户端和多个子系统进行交互，这降低了系统的耦合度。\n外观模式结构图：\n从上图可以看出，外观模式主要包含两个角色：\n Facade(外观角色)：它知道相关的子系统的功能和职责。客户端调用它的方法的时候，它通常会把客户端发来的请求委派到相应的子系统中去，由子系统的对象进行处理。 System(子系统角色)：它们被外观角色或者客户端调用。实际上，子系统并不知道外观角色的存在，外观角色对她们来说就是一个客户端而已。  模式实现 根据结构图可以写出下面的示例代码：\n// 子系统接口 public interface Subsystem { void method(); }// 子系统A public class SystemA implements Subsystem { @Override public void method() { System.out.println(\u0026#34;调用systemA的方法\u0026#34;); } }// 子系统B public class SystemB implements Subsystem { @Override public void method() { System.out.println(\u0026#34;调用systemB的方法\u0026#34;); } }// 子系统C public class SystemC implements Subsystem { @Override public void method() { System.out.println(\u0026#34;调用systemC的方法\u0026#34;); } }// 外观类 public class Facade { private Subsystem systemA; private Subsystem systemB; private Subsystem systemC; public Facade(){ System.out.println(\u0026#34;调用外观类的方法\u0026#34;); systemA = new SystemA(); systemB = new SystemB(); systemC = new SystemC(); } public void method(){ systemA.method(); systemB.method(); systemC.method(); } } 测试用的客户端类：\n// 客户端类 public class Client { public static void main(String[] args){ Facade facade = new Facade(); facade.method(); } } 运行结果：\n调用外观类的方法 调用systemA的方法 调用systemB的方法 调用systemC的方法 可以发现，客户端通过外观角色调用了子系统的功能。\n总结 外观模式的主要目的在于降低系统的复杂度。通过引入外观角色，简化了客户端与子系统之间的交互，为复杂子系统的调用提供了一个统一的接口，使得子系统和客户端之间的耦合度降低了，但这并不影响子客户端直接使用子系统的目的。一个子系统的修改不会影响到其它的子系统，子系统的内部变化也不会影响到外观对象。\n不过，外观模式不能很好的限制客户端直接使用子系统类。如果设计不当，增加新的子系统可能会导致外观类源代码的修改，这将违反开闭原则。\n","href":"/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","title":"《设计模式的艺术》读书笔记之十一：外观模式"},{"content":"  装饰模式（Decotator Pattern）：动态的给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更加灵活。\n 装饰模式允许向一个现有的对象添加新的功能而又不改变其结构。\n结构图 装饰模式的结构图如下：\n从图中可以看出，装饰模式主要包含4个角色：\n Component(抽象构件类)：它是一个接口，声明了在具体构件类中的业务方法。具体构件类和抽象装饰类都实现了这个接口，这样一来，客户端就可以一致对待装饰前的对象和装饰后的对象。抽象构件类也可以是抽象类。 ConcreteComponent(具体构件类)：它实现了Component接口，定义类具体的构件。装饰器类可以给它增加额外的职能。 Decotator(抽象装饰类)：它也实现了Component接口，是整个模式的核心。它用来给具体构件类增加职责，但是具体的职责将在子类中实现。同时，他维护了一个对Component的引用，通过这个引用可以调用装饰前的对象的方法，通过子类扩展这个方法就可以达到装饰的目的。 ConcreteDecorator(具体装饰类)：它继承了抽象装饰类，负责给构件添加新的职责。每一个具体装饰类都定义了新的职责，可以给对象扩充职责。  模式实现 // 抽象构件接口 public interface Component { void operation(); }// 具体构件类 public class ConcreteComponent implements Component { @Override public void operation() { System.out.println(\u0026#34;调用原有的功能\u0026#34;); } }// 抽象装饰类 public abstract class Decorator implements Component{ protected Component component; // 维持一个对Component对象的引用  public Decorator(Component component){ this.component = component; } public void operation(){ component.operation(); // 调用原有业务方法  } }// 具体装饰类 public class ConcreteDecorator extends Decorator { public ConcreteDecorator(Component component) { super(component); } public void operation(){ super.operation(); // 调用原有业务方法  addBehavior(); // 调用新增方法  } // 新增方法  private void addBehavior(){ System.out.println(\u0026#34;增加新功能\u0026#34;); } } 测试的客户端代码：\n// 客户端类 public class Client { public static void main(String[] args){ Component component1 = new ConcreteComponent(); Component component2 = new ConcreteDecorator(component1); // 用component2装饰component1  component2.operation(); } } 运行结果：\n调用原有的功能 增加新功能 可以发现：由于具体构件类和装饰类都实现了相同的抽象构件接口，装饰模式能够以对客户端透明的方式 动态 的给对象添加职责。也就是说，客户端不会察觉到对象在装饰前后的不同。\n总结 装饰模式降低了系统的耦合度，可以动态的给对象增加或删除职责，使得需要装饰的具体构件类和具体装饰类可以独立的变化，非常有利于系统的扩展。\n在扩展对象功能的时候，使用组合方式的装饰模式比继承更加灵活，不会导致系统中类的迅速增加，而且可以对一个类进行多次装饰，这能得到功能更加强大的对象。\n但是，使用装饰模式的时候，系统中会产生很多小对象，大量的小对象会占用更多的系统资源。而且，装饰模式比继承更为复杂。\n","href":"/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/","title":"《设计模式的艺术》学习笔记之十：装饰模式"},{"content":"  组合模式（Composite Pattern）：组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构。组合模式对单个对象（叶子对象）和组合对象（容器对象）的使用具有一致性。组合模式又称“整体-部分”（Part-Whole）模式。\n 使用组合模式，客户端可以像处理简单元素一样处理复杂元素，能够降低客户端和复杂元素内部的耦合度。\n结构图 组合模式的结构图如下：\n从图中可以看出，组合模式主要包含3个角色：\n Component(抽象构件类)：它为叶子构件和容器构件声明了用来访问及管理子构件的接口，它也可以包含所有子类公共接口的声明和实现。她也可以是接口和具体的类。 Leaf(叶子构件类)：它是容器树中的叶子节点，没有子节点。因此，它实现了抽象构件类中定义的接口。可以通过特殊方式处理那些调用访问及管理子构件的行为。 Composite(容器构件类)：它是容器树中的非叶子节点，它可以包含叶子节点和容器节点。因此，它提供了一个集合用来管理子构件。它也实现了抽象构件类中定义的接口，在其业务方法中可以递归的调用子节点的业务方法。  模式实现 根据结构图，可以写出下面的简单实现代码：\n// 抽象构件类 public abstract class Component { public abstract void add(Component c); // 添加元素  public abstract void remove(Component c); // 移除元素  public abstract Component getChild(int i); // 获取子节点  public abstract void operation(); // 业务方法 }/ 叶子构件类 public class Leaf extends Component { @Override public void add(Component c) { } @Override public void remove(Component c) { } @Override public Component getChild(int i) { return null; } @Override public void operation() { System.out.println(\u0026#34;调用叶子构件的业务方法\u0026#34;); } }// 容器构件类 public class Composite extends Component { private ArrayList\u0026lt;Component\u0026gt; children = new ArrayList\u0026lt;\u0026gt;(); @Override public void add(Component c) { children.add(c); } @Override public void remove(Component c) { children.remove(c); } @Override public Component getChild(int i) { return children.get(i); } @Override public void operation() { System.out.println(\u0026#34;调用容器构件的业务方法 -\u0026gt; 递归调用子构件的业务方法\u0026#34;); for(Component child: children){ child.operation(); } } } 测试用的客户端类：\n// 客户端类 public class Client { public static void main(String[] args){ Component leaf1, leaf2, composite1, composite2; leaf1 = new Leaf(); leaf2 = new Leaf(); composite1 = new Composite(); composite2 = new Composite(); composite1.add(leaf1); composite1.add(composite2); composite2.add(leaf2); composite1.operation(); } } 运行结果：\n调用容器构件的业务方法 -\u0026gt; 递归调用子构件的业务方法 调用叶子构件的业务方法 调用容器构件的业务方法 -\u0026gt; 递归调用子构件的业务方法 调用叶子构件的业务方法 可以看出: composite1 是一个容器构件，它具有两个子节点——一个叶子节点 leaf1 和一个容器节点 composite2 。 composite2 又具有一个叶子节点。调用 composite1 的业务方法会依次递归调用其子构件的业务方法。\n透明组合模式和安全组合模式 按照抽象构件类的定义形式，可以将组合模式分为透明组合模式和安全组合模式。\n透明组合模式 透明组合模式的结构图如下：\n可以看出：透明组合模式中，抽象构件类声明了所有用于管理成员对象的方法，这样一来，所有的构件类都具有相同的接口，客户端可以针对接口编程。从客户端的角度看，叶子构件和容器构件是相同的，可以同样对待。透明组合模式的缺点就是 不够安全 ，因为叶子构件和容器构件本质上是有区别的。叶子构件不可能具有子构件，也就是说：调用叶子构件中关于子构件的方法可能导致问题。\n安全组合模式 安全组合模式的结构图如下：\n可以看出：安全组合模式中，抽象构件类没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法。对于叶子构件的实例来说，就无法调用到这些方法，这是安全的。但是，安全组合是不够透明的，因为叶子构件和容器构件具有不同的方法，因此客户端不能面向抽象构件类编程。\n总结 组合模式主要用在具有 整体-部分 结构的层次结构中，可以一致性对待整体和部分，这一般是一个树形结构。使用组合模式，可以清楚的定义分层次的复杂对象，使得客户端可以忽略层次之间的差异，方便对整个结构进行控制，简化操作。在组合模式中增加新的叶子构件和容器构件非常方便，不用修改已有代码，符合开闭原则。但是，组合模式很难在增加新构件的时候对构件的类型进行限制。\n","href":"/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B9%9D%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","title":"《设计模式的艺术》读书笔记之九：组合模式"},{"content":"  桥接模式（Bridge Pattern）：将类的功能层次结构（抽象部分）和实现层次结构（实现部分）分离，使二者能够 独立 的变化，并在二者之间搭建桥梁，实现桥接。\n 如果系统中存在两个独立变化的维度，通过桥接模式就可以将这两个维度分离出来，使二者可以独立的扩展。\n结构图 桥接模式的结构图如下：\n从图中可以看出，桥接模式主要包含4个角色：\n Abstraction(抽象类)：抽象类用来定义接口，其中维护了一个Implementor类型的对象； RefinedAbstraction(扩充抽象类)：它扩充了由Abstraction定义的接口，实现了Abstraction中声明的方法，并可以调用Implementor的方法； Implementor(实现类接口)：它声明了基本操作的接口； ConcreteImplementor(具体实现类)：它实现了Implementor中声明的接口，在程序运行时，它将替代Implementor提供给Abstraction具体的业务操作方法；  模式实现 假设我们要开发一个绘图系统，它能够使用红、绿、蓝三种不同的颜色绘制圆形、正方形和三角形。很容易发现这里面有两个独立变化的维度，可以使用桥接模式来进行设计。可以得到下面的结构图：\n于是可以写出下面的示例代码：\n抽象颜色接口：\n// 颜色接口 public interface Color { void paint(); } 具体颜色类：\n// 红色 public class Red implements Color{ @Override public void paint() { System.out.println(\u0026#34;使用红色绘图\u0026#34;); } }// 绿色 public class Green implements Color { @Override public void paint() { System.out.println(\u0026#34;使用绿色绘图\u0026#34;); } }// 蓝色 public class Blue implements Color { @Override public void paint() { System.out.println(\u0026#34;使用蓝色绘图\u0026#34;); } } 抽象形状类：\n// 形状接口 public abstract class Shape { protected Color color; protected Shape(Color color){ this.color = color; } public abstract void draw(); } 具体形状类：\n// 圆形 public class Circle extends Shape { public Circle(Color color) { super(color); } @Override public void draw() { color.paint(); System.out.println(\u0026#34;绘制圆形\u0026#34;); } }// 正方形 public class Square extends Shape { public Square(Color color) { super(color); } @Override public void draw() { color.paint(); System.out.println(\u0026#34;绘制正方形\u0026#34;); } }// 三角形 public class Triangle extends Shape { public Triangle(Color color) { super(color); } @Override public void draw() { color.paint(); System.out.println(\u0026#34;绘制三角形\u0026#34;); } } 测试用的客户端类：\n// 客户端 public class Client { public static void main(String[] args){ Color color = new Red(); Shape shape = new Circle(color); shape.draw(); color = new Green(); shape = new Triangle(color); shape.draw(); color = new Blue(); shape = new Square(color); shape.draw(); } } 运行结果：\n使用红色绘图 绘制圆形 使用绿色绘图 绘制三角形 使用蓝色绘图 绘制正方形 总结 在进行软件设计的时候，如果系统中有两个或者多个变化的维度的时候，都可以尝试使用桥接模式来进行设计。通过在抽象层之间建立关系，可以避免层间静态继承结构（多层继承常常违反单一指职责原则）的出现，还能够松耦合抽象和实现之间的关系。分离出来的各个维度可以独立的变化，有利于单独进行扩展。不过，使用桥接模式会增加系统的理解与设计难度，需要识别出独立变化的维度，使用范围也有一定的局限性。\n","href":"/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AB%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","title":"《设计模式的艺术》读书笔记之八：桥接模式"},{"content":"  适配器模式（Adapter Pattern）：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，又称包装器（Wrapper）。\n 适配器模式的目标就是在不修改原有适配者接口和抽象目标类接口的前提下，将一个类的接口和另一个类的接口匹配起来。根据适配器有适配者的关系的不同，适配器模式又分为 对象适配器模式 和类适配器模式 。\n对象适配器模式  在对象适配器模式中，适配器与适配者之间是 关联 关系。\n 结构图 对象适配器模式的结构图如下： 从图中可以看出，对象适配器模式主要包含3个角色：\n Target(目标抽象接口)：它定义了客户端所需要的接口。它也可以是一个抽象类或者具体类； Adaptee(适配者类)：它是被适配的角色，包含了客户端希望使用的业务方法，但是客户端又不能调用，需要进行适配。 Adapter(适配器类)：它是适配器模式的核心，通过它来对Target和Adaptee进行适配。这里Adapter通过实现Target中的接口并关联一个Adaptee对象使二者产生关联。  模式实现 // 目标接口 public interface Target { // Adaptee 没有这个方法  void request(); }// 适配者类 public class Adaptee { public void specificRequest(){ System.out.println(\u0026#34;我是适配者的方法\u0026#34;); } }// 适配器类 public class Adapter implements Target { private Adaptee adaptee; // 关联一个Adaptee  public void setAdaptee(Adaptee adaptee) { this.adaptee = adaptee; } @Override public void request() { System.out.println(\u0026#34;进行适配\u0026#34;); // 转发调用  adaptee.specificRequest(); } } 测试用的客户端代码：\n// 客户端类 public class Client { public static void main(String[] args){ Target target = new Adapter(); Adaptee adaptee = new Adaptee(); ((Adapter) target).setAdaptee(adaptee); target.request(); } } 运行结果：\n进行适配 我是适配者的方法 适配器类通过关联一个适配者实例，将客户端和适配者衔接起来，然后在request() 方法中调用适配者的 specificRequest() 方法完成适配功能。\n类适配器模式  在类适配器模式中，适配器与适配者是 继承 或者 ** 实现** 关系。\n 结构图 模式实现 代码绝大部分和对象适配器的代码相同，不再重复，不同在于Adapter类。\n// 适配器类 public class Adapter extends Adaptee implements Target { @Override public void request() { specificRequest(); } } 由于这里使用的是继承机制，在只支持单继承结构的编程语言里会受到一定的限制。\n双向适配器模式  在双向适配器模式中，适配器类同时包含适配者和目标类的引用，适配者可以通过适配器调用目标类的方法，目标类也可以通过适配器调用适配者的方法。\n 结构图 双向适配器模式的结构图如下：\n模式实现 双向适配器的代码较为复杂，主要在于适配器同时维持了对目标类和适配者的引用：\n// 适配器类 public class Adapter implements Target, Adaptee{ // 同时维持对目标类和适配者类的引用  private Target target; private Adaptee adaptee; public void setTarget(Target target) { this.target = target; } public void setAdaptee(Adaptee adaptee) { this.adaptee = adaptee; } @Override public void specificRequest() { target.request(); } @Override public void request() { adaptee.specificRequest(); } } 总结 适配器模式将现有的接口转化为客户类所期望的接口，实现了对现有类的复用。如果没有一些现有的类，那么适配器模式是派不上用场的。\n适配器模式解除了现有类和目标类的耦合，也不用修改现有的结构。同时，适配器模式非常利于扩展，完全符合开闭原则。但是，适配器模式也有一定的局限：比如单继承结构语言的限制，适配者类不能是最终类等。\n","href":"/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%83%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","title":"《设计模式的艺术》读书笔记之七：适配器模式"},{"content":"  建造者模式（Builder Pattern）：将一个复杂的对象的构建与它的表示分离，使得同样的创建过程可以创建不同的表示。建造者模式又称为生成器模式。\n 基本实现方案 建造者模式常用来逐步创建复杂对象，它允许客户端通过指定复杂对象的内容和类型就可以构建它们，用户并不需要知道内部的实现细节。\n建造者模式的结构图如下：\n从图中可以看出，建造者模式主要包含4个角色：\n Builder(抽象建造者类)：它声明了创建一个产品对象所需要的接口。抽象建造者类也可以是具体类或者抽象类。它主要含有两类方法：  buildPartX(): 用来创建产品的各个组成部件； getResult(): 返回创建好的产品；  ConcreteBuilder(具体建造者类)：它实现了Builder接口，将被用来创建一个具体的产品； Product(产品类)：它是被Concrete创建的对象，和特定的ConcreteBuilder相关联； Director(指挥者类)：它隔离了客户端和产品的创建过程，负责安排产品的创建过程。它是和客户端交互的接口，将根据客户端的要求创建并返回具体的产品；  根据结构图可以写出下面的示例代码：\n// 产品类 public class Product { private String partA; private String partB; private String partC; //省略getter和setter  @Override public String toString() { return \u0026#34;Product{\u0026#34; + \u0026#34;partA=\u0026#39;\u0026#34; + partA + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, partB=\u0026#39;\u0026#34; + partB + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, partC=\u0026#39;\u0026#34; + partC + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }// 抽象建造者 public interface Builder { void buildPartA(); void buildPartB(); void buildPartC(); Product getResult(); }// 具体建造者类 public class ConcreteBuilder implements Builder { Product product = new Product(); @Override public void buildPartA() { System.out.println(\u0026#34;Build partA\u0026#34;); product.setPartA(\u0026#34;partA\u0026#34;); } @Override public void buildPartB() { System.out.println(\u0026#34;Build partB\u0026#34;); product.setPartB(\u0026#34;partB\u0026#34;); } @Override public void buildPartC() { System.out.println(\u0026#34;Build partC\u0026#34;); product.setPartC(\u0026#34;partC\u0026#34;); } @Override public Product getResult() { System.out.println(\u0026#34;Building finished!\u0026#34;); return product; } }// 指挥者类 public class Director { private Builder builder; public void setBuilder(Builder builder){ this.builder = builder; } public Product construct(){ builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); return builder.getResult(); } } 测试用的客户端代码：\n// 客户端类 public class Client { public static void main(String[] args){ Director director = new Director(); Builder builder = new ConcreteBuilder(); // 注入Builder  director.setBuilder(builder); Product product = director.construct(); System.out.println(product); } } 运行结果：\nBuild partA Build partB Build partC Building finished! Product{partA=\u0026#39;partA\u0026#39;, partB=\u0026#39;partB\u0026#39;, partC=\u0026#39;partC\u0026#39;} 总结 建造者模式的核心在于：如何使用相同的构建过程一步步完成产品组件的创建，最终构建出不同的产品。\n建造者模式适用于创建复杂的产品。它也能选择性的创建产品的部件以及指定产品部件的创建次序，这能够实现对产品创建过程的精确控制。每一类的建造者都相互独立，可以很方便地替换具体的建造者和增加新的建造者，这符合开闭原则。但是，建造者模式要求产品一般具有较多的共同点，如果产品之间差异很大，就不适合使用建造者模式了。\n","href":"/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","title":"《设计模式的艺术》读书笔记之六：建造者模式"},{"content":"  原型模式（Prototype Pattern）：使用原型实例指定创建对象，并通过克隆这些原型得到新的对象。\n 原型模式的工作原理就是：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象克隆自己来实现创建过程。\n需要注意的是：通过克隆方法所创建的对象应当都是 全新 的对象，他们在内存中拥有新的地址。通常，对克隆后的对象进行修改不会影响原型对象，每一个克隆对象都是相互独立的。通过修改克隆后的对象，可以得到一组相似的对象。\n基本实现方案 原型模式的结构图如下：\n从结构图中可以看出，原型模式主要包含3个角色：\n Prototype(抽象原型类)：它声明了克隆方法的接口，供具体原型类实现，它也可以是抽象类或这具体类； ConcretePrototype(具体原型类)：它实现了抽象原型类中声明的克隆方法，调用此方法会返回一个自己的克隆对象； Client(客户端类)：针对抽象原型类编程，让一个原型对象克隆自己从而创建一个新的原型对象。  原型模式的一个简单实现：\n原型类：\nimport java.io.*; // 实现序列化接口，便于进行深克隆 public class Book implements Serializable { private String name; private String isbn; private String publishingCompany; public Book(String name, String isbn, String publishingCompany) { this.name = name; this.isbn = isbn; this.publishingCompany = publishingCompany; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getIsbn() { return isbn; } public void setIsbn(String isbn) { this.isbn = isbn; } @Override public String toString() { return \u0026#34;Book{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, isbn=\u0026#39;\u0026#34; + isbn + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, publishingCompany=\u0026#39;\u0026#34; + publishingCompany + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } // 使用序列化技术进行深克隆  public Book deeppClone() throws IOException, ClassNotFoundException{ // 将对象写入流中  ByteArrayOutputStream bao = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bao); oos.writeObject(this); // 将对象从流中取出  ByteArrayInputStream bio = new ByteArrayInputStream(bao.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bio); return (Book) ois.readObject(); } } 测试用的客户端代码：\nimport java.io.IOException; public class Client { public static void main(String[] args) throws IOException, ClassNotFoundException { Book bookPrototype = new Book(\u0026#34;设计模式\u0026#34;, \u0026#34;978-7-303-23647-8\u0026#34;, \u0026#34;机械工业出版社\u0026#34;); Book bookCopy = bookPrototype.deeppClone(); System.out.println(\u0026#34;bookPrototype == bookCopy: \u0026#34; + (bookPrototype == bookCopy)); System.out.println(\u0026#34;bookPrototype.getClass() == bookCopy.getClass(): \u0026#34; + (bookPrototype.getClass() == bookCopy.getClass())); bookCopy.setIsbn(\u0026#34;978-6-111-22222-1\u0026#34;); System.out.println(\u0026#34;------------ bookPrototype -------------\u0026#34;); System.out.println(bookPrototype); System.out.println(\u0026#34;------------ bookCopy -------------\u0026#34;); System.out.println(bookCopy); } } 运行结果：\nbookPrototype == bookCopy: false bookPrototype.getClass() == bookCopy.getClass(): true ------------ bookPrototype ------------- Book{name=\u0026#39;设计模式\u0026#39;, isbn=\u0026#39;978-7-303-23647-8\u0026#39;, publishingCompany=\u0026#39;机械工业出版社\u0026#39;} ------------ bookCopy ------------- Book{name=\u0026#39;设计模式\u0026#39;, isbn=\u0026#39;978-6-111-22222-1\u0026#39;, publishingCompany=\u0026#39;机械工业出版社\u0026#39;} 可以发现：克隆的对象和原来的对象已经不是同一个对象了，但是它们仍然属于同一个类，仍然具有一致的行为和相似的属性。\n浅克隆VS深克隆 浅克隆和深克隆的主要区别在于是否支持 引用类型 的成员变量的复制。\n值类型VS引用类型 在Java中，数据类型分为 值类型 和 引用类型 。\n值类型也就是基本的数据类型，包括：boolean, char, byte, short, int, long, float, double；\n引用类型包括类、数组、接口等复杂类型。\n浅克隆（Shallow Clone) 在浅克隆中，如果原型对象成员变量是值类型，则复制一份给克隆对象；如果是引用类型，则将引用对象的 地址 复制一份给克隆对象。也就是说，原型对象和克隆对象的引用类型成员指向的是 同一个 内存地址， 也就是同一个引用。\n可以通过覆盖object类的 clone() 方法实现浅克隆。\n深克隆 和浅克隆不同的是：深克隆在复制成员变量的时候，不管成员变量是基本类型还是引用类型，都会复制一份给克隆对象。此外，深克隆还会将原型对象的所有引用也复制一份给克隆对象。\n可以通过序列化（Serialization）技术快速实现深克隆。\n总结 原型模式是一种用来快速创建大量相同或者相似对象的方式。特别是当创建新的对象较为复杂的时候，使用原型模式可以简化创建过程。使用了抽象层的原型模式还能很好的支持扩展。当我们需要保存对象在某一时刻的状态的时候，能够很轻松的通过深克隆机制来实现。不过，原型模式需要为每一个类都配备一个克隆方法，由于克隆方法在类的内部，所以当需要对类进行改造的时候，需要修改原有的代码，这违反了开闭原则。\n","href":"/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"《设计模式的艺术》读书笔记之五：原型模式"},{"content":"  抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列相关或者相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称Kit模式。\n 产品等级结构和产品族 先回忆一下工厂方法模式：在工厂方法模式里面，每一种具体的产品都有它对应的工厂，工厂方法具有专一性，也就是说一个工厂仅提供一种产品。有时候，我们希望一个工厂可以创建多种产品。如果仍然采取一个工厂对应一种产品的方法，那么系统中类的个数就会快速增加。\n在提出抽象工厂模式之前，先引入产品等级结构和产品族的概念：\n 产品等级结构。产品等级结构也就是产品的继承结构。比如：我们现在有手机这个抽象类，它的子类有华为手机、苹果手机、小米手机……。华为手机下面又有P系列手机、Mate系列手机、畅享系列手机等等。抽象的手机和不同品牌的具体的手机就构成了一个产品等级结构。 产品族。在抽象工厂模式中，产品族指的是由同一个工厂生产的，位于不同产品等级结构的一组产品。就像上面的华为手机系列的具体机型。  产品等级结构和产品族就像是一个平面的X和Y坐标轴，通过一个产品产品等级结构和产品族就能唯一确定这个产品。\n基本实现方案 抽象工厂模式的结构图如下：\n从图中可以看出，抽象工厂模式主要包含4个角色：\n AbstractFactory(抽象工厂类)：它声明了一组用来创建一族产品的方法，每一个方法对应一种产品； ConcreteFactory(具体工厂类)：它实现了抽象工厂类中声明的方法。一个具体工厂中的不同方法负责创建位于同一产品族的不同产品等级结构的产品，所有的这些产品构成了同一个产品族。 AbstracProduct(抽象产品类)：它声明了产品所具有的业务方法； ConcreteProduct(具体产品类)：它实现了抽象产品类中声明的方法  根据结构图可以写出如下示例代码：\n抽象产品：\n// 产品族A public interface AbstractProductA { public void productAMethod(); }// 产品族B public interface AbstractProductB { public void productBMethod(); } 具体产品：\n// 具体产品A1 public class ConcreteProductA1 implements AbstractProductA { @Override public void productAMethod() { System.out.println(\u0026#34;这是产品A1, 属于产品族1\u0026#34;); } }// 具体产品A2 public class ConcreteProductA2 implements AbstractProductA { @Override public void productAMethod() { System.out.println(\u0026#34;这是产品A2, 属于产品族2\u0026#34;); } }// 具体产品B1 public class ConcreteProductB1 implements AbstractProductB { @Override public void productBMethod() { System.out.println(\u0026#34;这是产品B1, 属于产品族1\u0026#34;); } }// 具体产品B2 public class ConcreteProductB2 implements AbstractProductB { @Override public void productBMethod() { System.out.println(\u0026#34;这是产品B2, 属于产品族2\u0026#34;); } } 抽象工厂：\n// 抽象工厂 public interface AbstractFactory { // 创建产品族A  public AbstractProductA createProductA(); // 创建产品族B  public AbstractProductB createProductB(); } 具体工厂：\n// 具体工厂1 public class ConcreteFactory1 implements AbstractFactory { @Override public AbstractProductA createProductA() { System.out.println(\u0026#34;创建产品A1, 产品等级A\u0026#34;); return new ConcreteProductA1(); } @Override public AbstractProductB createProductB() { System.out.println(\u0026#34;创建产品B1, 产品等级B\u0026#34;); return new ConcreteProductB1(); } }// 具体工厂2 public class ConcreteFactory2 implements AbstractFactory { @Override public AbstractProductA createProductA() { System.out.println(\u0026#34;创建产品A2, 产品等级A\u0026#34;); return new ConcreteProductA2(); } @Override public AbstractProductB createProductB() { System.out.println(\u0026#34;创建产品B2, 产品等级B\u0026#34;); return new ConcreteProductB2(); } } 测试用的客户端代码：\n// 客户端 public class Client { public static void main(String[] args){ AbstractFactory factory; AbstractProductA productA; AbstractProductB productB; factory = new ConcreteFactory1(); productA = factory.createProductA(); productA.productAMethod(); productB = factory.createProductB(); productB.productBMethod(); factory = new ConcreteFactory2(); productA = factory.createProductA(); productA.productAMethod(); productB = factory.createProductB(); productB.productBMethod(); } } 运行结果：\n创建产品A1, 产品等级A 这是产品A1, 属于产品族1 创建产品B1, 产品等级B 这是产品B1, 属于产品族1 创建产品A2, 产品等级A 这是产品A2, 属于产品族2 创建产品B2, 产品等级B 这是产品B2, 属于产品族2 总结 和工厂方法模式相比，抽象工厂模式最大的不同在于：工厂方法模式针对的是一个产品等级结构，而抽象工厂模式针对的是多个产品等级结构（一个产品族）。在这里，属于同一个产品族的多个对象被设计成一起工作。当向系统中增加产品族的时候，不用修改已有代码，这符合开闭原则。但是当向系统中增加新的产品等级结构的时候会很麻烦，需要对原来的代码进行修改，这个修改往往是很大的，这又违反了开闭原则。\n","href":"/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%9B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","title":"《设计模式的艺术》读书笔记之四：抽象工厂模式"},{"content":"  工厂方法模式（Factory Method Pattern）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化，这让一个类的实例化延迟到了其子类。工厂方法模式简称工厂模式（Factory Method），也称虚拟构造器模式（Virtual Constructor Pattern），又被称为多态工厂模式（Polymorphic Factory Method）。\n 基本实现方案  将需要创建的各种不同对象的相关代码封装到不同的具体产品类中； 将具体产品类的公共代码进行抽象和提取后封装到一个抽象产品类(也可以是接口或者具体的类)中，它是所有具体产品类的父类； 创建一个抽象工厂类并提供一个创建产品的工厂方法，用于返回一个具体的产品； 创建和具体产品类对应的具体工厂类，使之成为抽象工厂类的子类，并实现抽象工厂类中定义的方法。  工厂方法模式的结构图如下：\n可以看出，工厂方法模式主要包含四个角色：\n Product(抽象产品类)：它定义了产品的接口，供所有具体的产品类实现。 ConcreteProduct(具体产品类)：它实现了产品的接口，是具体工厂类创建的对象，和具体工厂一一对应； Fatory(抽象工厂类)：它是整个模式的核心，声明了工厂方法factoryMethod()。所有的具体工厂类都必须实现它声明的方法； ConcreteFactory(具体工厂类)：它实现了抽象工厂类的接口，与特定的产品相关联，并可返回具体产品的实例；  根据结构图可以写出如下的示例代码：\n产品类：\n// 抽象产品接口 public interface Product { public void productMethod(); }// 具体产品A public class ConcreteProductA implements Product{ public ConcreteProductA(){ System.out.println(\u0026#34;创建产品A\u0026#34;); } @Override public void productMethod() { System.out.println(\u0026#34;这是产品A\u0026#34;); } }// 具体产品B public class ConcreteProductB implements Product { public ConcreteProductB(){ System.out.println(\u0026#34;创建产品B\u0026#34;); } @Override public void productMethod() { System.out.println(\u0026#34;这是产品B\u0026#34;); } } 工厂类：\n// 抽象工厂接口 public interface Factory { public Product factoryMethod(); }// 具体产品A对应的具体工厂 public class ConcreteProductAFactory implements Factory { @Override public Product factoryMethod() { return new ConcreteProductA(); } }// 具体产品B对应的具体工厂 public class ConcreteProductBFactory implements Factory { @Override public Product factoryMethod() { return new ConcreteProductB(); } } 客户端测试代码：\n// 客户端 public class Client { public static void main(String[] args){ Factory factory = null; Product product = null; // 创建产品A  factory = new ConcreteProductAFactory(); product = factory.factoryMethod(); product.productMethod(); // 创建产品B  factory = new ConcreteProductBFactory(); product = factory.factoryMethod(); product.productMethod(); } } 运行结果：\n创建产品A 这是产品A 创建产品B 这是产品B 与简单工厂模式相比，工厂方法模式最大的区别就是引入了抽象工厂这个角色。它只是简单的声明了工厂方法，具体的产品对象由其子类——具体工厂类创建，这使得客户端可以针对抽象工厂编程，具体工厂类可以延迟到运行时刻再确定。\n总结 工厂方法模式是对简单工厂模式的改进，克服了简单工厂模式的不足，关键在于基于工厂角色和产品角色的 多态 设计。抽象工厂通过指定其子类来确定具体使用工厂方法创建哪个对象，这就向客户端隐藏了具体产品的实现细节，客户端不必知道具体产品类的类名，只需知道相应的工厂即可。如果采用配置文件的方式指定具体的产品类，在更换产品的时候只需要修改配置文件，不必修改已有代码。当向系统中加入新的产品时，也无须修改已有代码，只需添加具体产品类和对应的工厂类并修改配置文件，这非常有利于系统的扩展。然而，但加入新的产品的时候，系统中的类的个数也将成对增加，在一定程度上加大了系统的复杂度。\n","href":"/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","title":"《设计模式的艺术》读书笔记三：工厂方法模式"},{"content":"  简单工厂模式（Simple Factory Pattern）：定义一个工厂类，工厂类根据参数返回不同的实例，被创建的实例通常具有共同的父类。由于创建实例的方法是静态方法，因此简单工厂模式又被称为静态工厂方法模式。\n 简单工厂的核心在于：根据传入的参数获取相应的对象，而无须知道创建的细节。\n基本实现方案  将需要创建的各种不同对象的相关代码封装到不同的具体产品类中； 将具体产品类的公共代码进行抽象和提取后封装到一个抽象产品类(也可以是接口或者具体的类)中，它是所有具体产品类的父类； 创建一个工厂类并提供一个创建产品的工厂方法，它能根据传入参数的不同创建不同的具体产品对象；  简单工厂模式的结构图如下：\n可以看出，简单工厂模式的结构图中包含3个角色：\n Factory(工厂类)：它是整个模式的核心，负责创建所有的产品。外界可以直接调用静态工厂方法factoryMethod()创建所需要的具体产品对象； Product(抽象产品类)：它是所有具体产品类的父类，封装了所有具体产品类的公有方法。 ConcreteProduct(具体产品类)：它是简单工厂模式创建的目标，所有被创建的对象都是某个具体产品类的一个实例。  根据结构图写出的代码如下：\n// 抽象产品 public interface Product { // 公有方法  public void sameMethod(); }// 具体产品A public class ConcreteProductA implements Product { public ConcreteProductA(){ System.out.println(\u0026#34;创建产品A\u0026#34;); } @Override public void sameMethod() { System.out.println(\u0026#34;这是产品A\u0026#34;); } }// 具体产品B public class ConcreteProductB implements Product{ public ConcreteProductB(){ System.out.println(\u0026#34;创建产品B\u0026#34;); } @Override public void sameMethod() { System.out.println(\u0026#34;这是产品B\u0026#34;); } } 工厂类根据传入参数创建对应的具体产品：\n// 工厂类 public class Factory { public static Product getProduct(String args){ Product product = null; if(args.equalsIgnoreCase(\u0026#34;A\u0026#34;)){ product = new ConcreteProductA(); // 其他操作...  } else if(args.equalsIgnoreCase(\u0026#34;B\u0026#34;)){ product = new ConcreteProductB(); // 其他操作...  } return product; } } 下面是客户端代码：\n// 客户端 public class Client { public static void main(String[] args){ Product product; product = Factory.getProduct(\u0026#34;A\u0026#34;); product.sameMethod(); product = Factory.getProduct(\u0026#34;B\u0026#34;); product.sameMethod(); } } 最终运行的结果如下：\n创建产品A 这是产品A 创建产品B 这是产品B 方案的改进 观察客户端的代码可以发现，每更换一个产品都必须更改客户端的代码，这违反了开闭原则。有没有一种方式可以实现在不修改客户端代码的情况下更换产品呢？当前有。在Java中，可以采取配置文件的方式，将factoryMethod()的参数存储在XML或者properties格式的配置文件中。通过读取配置文件获取参数，然后客户端根据从配置文件得到的参数去调用工厂类的静态方法，这就达到了目的。\n总结 使用简单工厂模式，客户端只知道传入工厂类的参数，不必关心对象是如何创建的，它也不知道所创建的产品是哪一个类。工厂类知道每一个具体产品的创建细节，它根据传入参数决定创建哪一个对象供客户端使用，实现了对象的创建和使用的分离。但是，工厂类集中了所有产品的创建逻辑，职责过重。当增加新的产品的时候，不得不修改工厂类的代码，这违反了开闭原则，同时也不利于系统的扩展和维护。\n","href":"/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","title":"《设计模式的艺术》读书笔记二：简单工厂模式"},{"content":"  单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类就是单例类。\n 从单例模式的定义来看，它有3个要点：\n 它只有唯一一个实例； 它必须自行创建这个实例； 它必须向整个系统提供这个实例；  基本实现方案  将构造函数设为私有，确保外界无法通过 new 创建该对象； 提供公有的静态方法，返回单例类的唯一实例，供外界访问； 创建唯一的实例，并通过公有的静态方法返回；  单例模式的结构图如下：\n根据这个图，可以很容易写出对应的代码：\n// 单例类 public class Singleton { // 私有静态成员变量  private static Singleton instance = null; // 私有构造函数  private Singleton(){} // 公有静态成员方法，返回单例  public static Singleton getInstance(){ if(instance == null) instance = new Singleton(); return instance; } } 饿汉式单例类(Eager Singleton) 饿汉式单例类的结构图如下：\n从图中可以看出，当类 加载 的时候，静态变量instance就会被初始化，此时会调用私有的构造函数创建类的唯一实例。代码如下：\n// 饿汉式单例类 public class EagerSingleton { private static final EagerSingleton instance = new EagerSingleton(); private EagerSingleton(){} public static EagerSingleton getInstance(){ return instance; } } 懒汉式单例类(Lazy Singleton) 懒汉式单例类的结构图如下：\n从图中可以看出，和饿汉式单例不同的是：懒汉式单例在类加载的时候不实例化，而是第一次调用getInstance()的时候才被实例化。这就是 延迟加载（Lazy Load）技术 ，也就是在需要的时候才加载实例。在Java中，为了避免多个县城同时调用getInstance()方法，可以使用关键字 synchronized 进行线程锁定 。代码如下（这个方法有缺陷）：\n// 有缺陷的懒汉类 public class LazySingleton1 { private static LazySingleton1 instance = null; private LazySingleton1(){} synchronized public static LazySingleton1 getInstance(){ if(instance == null) instance = new LazySingleton1(); return instance; } } 上面的代码中， synchronized 锁定了整个getInstance()方法，会影响系统的性能，一个改进的方法是：只锁定创建实例的那一行代码。修改后的getInstance()方法如下：\npublic static LazySingleton1 getInstance(){ if(instance == null){ synchronized (LazySingleton1.class){ instance = new LazySingleton1(); } } return instance; } 上面的代码看似解决了问题，然而并没有。考虑某一瞬间，如果多个线程同时调用getInstance()方法，如果此时instance == null,这些线程就都能通过if语句的判断。由于使用了synchronized，后面的线程会处于排队等待的状态。当前面的线程执行完由synchronized锁定的代码之后，实例已经被创建，而后面的线程此时并不知道实例已经被创建的事实，天真的创建了新的实例。如此一来，系统中就会出现多个单例对象，这就违背了单例模式的设计思想。一个可行的解决方案是：采用 双重检查锁定（Double-Check Locking） 。也就是在synchronized锁定的代码中再进行一次instance == null 的判断，这样后面的线程就不会通过新的判断条件，也就不会新建线程了。使用双重锁定需要使用Java中的volatile关键字，被它修饰的成员变量可以确保多个线程都能正确处理。修改后的代码如下：\n// 采用双重检查锁定的懒汉类 public class LazySingleton2 { private volatile static LazySingleton2 instance = null; private LazySingleton2(){} public static LazySingleton2 getInstance(){ if(instance == null){ // 第一重判断  synchronized (LazySingleton2.class){ if(instance == null){ // 第二重判断  instance = new LazySingleton2(); } } } return instance; } } 由于使用volatile关键字会屏蔽JVM所做的一些代码优化，因此使用DCL来实现单例模式也不够完美。一种更好的实现方法是：采用 IoDH技术 。\n采用IoDH技术实现单例模式 Initialization on Demand Holder(IoDH)技术 克服饿汉类单例和懒汉类单例的缺点，既能实现延迟加载，又能保证线程安全。在实现的时候，需要在单例类添加一个 静态内部类 ，然后在这个静态内部类中创建单例对象，再将该单例对象返回给外界使用。代码如下：\n// 使用IoDH技术实现 public class BetterSingleton { private BetterSingleton(){} private static class HolderClass{ private final static BetterSingleton instance = new BetterSingleton(); } public static BetterSingleton getInstance(){ return HolderClass.instance; } } 总结 一篇读书笔记下来，对单例模式的理解更是加深了不少，尤其是双重检查锁定机制。总的来说：单例模式适用于系统只需要一个实例对象或者只能通过一个公共访问点访问单个实例的情况。采用单例模式，能够实现对唯一实例的访问，由于只有一个实例，减少了对系统资源的占用，不失为一种节约系统资源的好方式。但是，单例模式缺乏抽象层，不利于扩展和代码的复用。还有就是，单例类通常具有很多职责，这违背了SRP。\n","href":"/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","title":"《设计模式的艺术》读书笔记一：单例模式"},{"content":" 面向对象设计的7个原则  面向对象设计存在7个原则。在设计中使用这些原则，有助于提高设计模型的灵活性和可维护性，提高类的內聚度，降低类之间的耦合度。\n 单一职责原则(Single Responsibility Principle, SRP) 职责 可以理解为 引起类变化的原因 。 就一个类而言，应该只有一个引起它变化的原因 。如果一个类具有多个职责，那么就有多个引起它变化的原因。过多的职责耦合在一起，当其中一个职责变化时，可能影响到其它职责的正常运作。因此，在设计类的时候，要将这些职责分离，将不同的职责封装在不同的类中。确保引起该类变化的原因只有一个，从而提高类的內聚度。\n开闭原则(Open-Closed Principle, OCP) 一个软件实体应当对扩展开放，对修改关闭 。也就是说： 软件实体应该尽可能在不修改原有代码的情况下进行扩展 。为了满足开闭原则，需要对系统进行 抽象化 设计，抽象化是开闭原则的关键。可以先定义出 抽象层 ，然后通过 具体类 来进行扩展。当需要修改系统的行为时，不需要改动抽象层，只需要添加新的具体类就能实现新的业务功能，这就在不修改原有代码的基础上完成了目标。\n里氏替换原则(Liskov Substitution Principle, LSP) 子类应当可以替换父类并出现在父类能够出现的任何地方 。也就是说：在软件中将一个父类对象替换成它的子类对象，程序不会出现任何的问题，反过来则不然。里氏替换原则是实现开闭原则的重要方式之一。由于使用父类的地方都可以使用子类，因此在程序中应该尽量使用父类来对对象进行定义，而在运行的时候再确定子类类型，用子类替换父类对象。因此，可以将父类声明设计为抽象类或者接口，让子类继承父类或者实现父类接口并实现父类声明的方法。在运行的时候，子类实例替换父类实例，可以很方便的扩展系统的功能，增加新的功能可以通过增加新的子类来实现。\n依赖倒置原则(Dependence Inversion Principle, DIP) 抽象不应该依赖于细节，细节应当依赖于抽象 。高层模块不应该依赖于低层模块，两者都应当依赖于 抽象 。也就是说：要针对接口编程，而不是针对实现编程。在程序设计中，尽量使用高层的抽象类来完成功能，而不要使用具体的类来做这些。为此，一个具体类应当只实现接口或者抽象类中声明过的方法，而不要有多余的方法，否则高层的抽象类无法调用到在子类新增加的方法。\n引入抽象层之后，系统的灵活性变高。在程序中尽量使用抽象类进行编程，而将具体类写在配置文件中。如此一来，当系统需要扩展时，只需要对抽象层进行扩展并修改配置文件，无需改动原来的代码。\n依赖注入的三种方式： 构造注入 、 设值注入 、 接口注入 。\n接口隔离原则(Interface Segregation Principle, ISP) 使用多个专门的接口，而不使用一个总的接口 。也就是说：客户端不应该依赖它不需要的接口。当一个接口太大的时候，需要将其划分为一些更小的接口。如果把接口比喻成角色，那么一个接口应当只扮演一个或者一类角色。\n组合/聚合复用原则(Composite Reuse Principle, CRP) 应当尽量使用对象组合，而不是继承来达到复用的目的 。继承复用会破坏封装性，因为继承会将父类的实现细节暴露给子类。当父类改变的时候，子类也必须跟着改变。组合/聚合关系可以将已有的对象纳入新的对象中，新对象可以调用已有对象的功能，而已有对象的内部对新对象是不可见的。相对于继承来说，这种方式的耦合度较低，已有对象的改变不会给新对象带来太大的影响。一般来说，如果两个类之间是 Is-A 关系，应当使用继承；如果两个类之间是 Has-A 关系，应当使用组合或者聚合。\n迪米特法则(Law of Demeter, LoD) 一个软件实体应当尽可能少的与其它实体发生作用 。如果一个系统符合迪米特法则，那么当其中的某一个模块发生改变时，就会尽量少的影响其它模块。在设计系统的时候，尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象之间就不应当发生任何直接的作用。如果一个对象需要调用另一个对象的方法，可以通过一个第三者来完成这个调用。这就降低了对象之间的耦合度。\n","href":"/blogs/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%847%E4%B8%AA%E5%8E%9F%E5%88%99/","title":"面向对象设计的7个原则"},{"content":"","href":"/tags/java/","title":"Java"},{"content":"","href":"/categories/java-web/","title":"Java Web"},{"content":" Java WEB复习笔记  这是为了准备秋招面试而对Java Web开发进行的复习。\n 首先，对于一个Java Web应用，它由一组Servlet、HTML页、实用类、以及其它可以被绑定的资源构成。它运行于实现了Servlet规范的Servlet容器中。\nServlet Java Servlet和平台无关，它运行于Servlet容器中。Servlet容器负责Servlet和客户端的通信以及调用Servlet的方法，Servlet和客户端的通信采用的是 请求/响应 模式。\nServlet的功能  创建并返回基于客户端请求的动态HTML页面。 创建可嵌入到现有HTML页面中的HTML片段。 与其它服务器资源进行通信。  Sevlet容器 Servlet容器可以创建Servlet，并调用Servlet相关生命周期方法。还是运行JSP等的软件环境。\nServlet生命周期方法  构造器：只调用一次。只有第一次请求Servlet的时候，才调用构造器，创建Servlet实例。即Servlet使 单实例 的。 init()方法：只调用一次。在Servlet实例创建完毕后立即被调用，用于初始化当前Servlet。 service()方法：每次请求都会调用，用于相应请求。 destroy()方法：只调用一次。在当前Servlet所在的Web应用被卸载前调用，用于释放当前Servlet所占有的资源。  ServletConfig接口 这个接口封装了 当前 Servlet的配置信息，并可以获取ServletContext对象。\n String getServletName();: 获取Servlet的配置名。 ServletContext getServletContext();: 获取对应的ServletConfig对象。 String getInitParameter(String var1);: 获取指定参数名的初始化参数。 Enumeration\u0026lt;String\u0026gt; getInitParameterNames();: 获取参数名组成的Enumerarion。  ServletContext接口 Servlet引擎为每一个Web应用都创建一个对应的ServletContext对象。这个对象由Web应用中 所有 的Servlet所共享。它实际代表了当前的Web应用。\nServletContext有很多的功能，比如：\n 获取当前Web应用的初始化参数\n String getInitParameter(String var1);: 获取指定参数名的初始化参数。 Enumeration\u0026lt;String\u0026gt; getInitParameterNames();: 获取参数名组成的Enumerarion。  获取虚拟路径所映射的本地路径 -String getRealPath(String var1);\n 访问资源文件\n 记录日志\n 设置和获取应用属性\n  ServletRequest接口 ServletRequest接口封装了请求信息，可以从中获取任何请求信息。\nGET\u0026amp;POST请求  GET方式  将请求信息附加在请求地址后面 传送的数据量有限 传输信息在浏览器地址栏 可见 常见于输入URL或点击网页上的超链接  POST方式  将数据作为HTTP消息的实体内容传送 传送的数据量比GET方式大得多。 传输信息在浏览器地址栏 不可见 主要用于提交表单数据   获取请求参数  String getParameter(String var1);: 根据请求参数的名字返回参数值。 Enumeration\u0026lt;String\u0026gt; getParameterNames();：返回参数名对应的Enumaration对象。 String[] getParameterValues(String var1);：根据请求参数的名字返回请求参数对应的数组，如获取多选框信息。 Map\u0026lt;String, String[]\u0026gt; getParameterMap();：返回请求参数的键值对。  ServletResponse接口 ServletResponse接口封装了响应信息，给客户端的响应取决于本接口实现的方法。常用的方法有：\n PrintWriter getWriter() throws IOException;: 返回一个PrintWriter对象。然后我们可以调用该对象的print(\u0026quot;something\u0026quot;)方法打印信息到浏览器上。 void setContentType(String var1);: 设置响应的内容类型。  GenericServlet GenericServlet同时实现了Servlet接口、ServletConfig接口和 Serializable接口，和各种协议无关。HttpServlet就继承于它。\nHttpServlet HttpServlet继承自GeniricServlet实现类，用于 HTTP协议。它在service()方法中将使用HttpServletRequest.getMothod()方法来获取请求方式，然后根据不同的请求方式创建不同的具体的处理方式。\nJSP  JSP页面由HTML语句和嵌套在其中的Java代码组成。本质还是Servet。JSP页面中的java代码需要嵌套在\u0026lt;%和%\u0026gt;中。\n JSP运行原理 当Web容器接收到以.jsp为扩展名的URL请求时，将该请求转交给JSP引擎处理。每个JSP页面在第一次被访问的时候，JSP引擎都会把它翻译为一个Servlet源程序并编译。然后Web容器就可以像调用普通Servlet程序一样来处理这个由JSP页面翻译而来的Servlet程序。\nJSP页面的隐含对象 这些隐含对象不用声明，可以直接使用。一共有9个。\npublic void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response) throws java.io.IOException, javax.servlet.ServletException { final javax.servlet.jsp.PageContext pageContext; javax.servlet.http.HttpSession session = null; final javax.servlet.ServletContext application; final javax.servlet.ServletConfig config; javax.servlet.jsp.JspWriter out = null; final java.lang.Object page = this; javax.servlet.jsp.JspWriter _jspx_out = null; javax.servlet.jsp.PageContext _jspx_page_context = null; // 内嵌Java代码翻译后的位置，这里有第9个隐含对象: exception  } 9个隐含对象分别是：\n request: HttpServletRequest的一个对象。 response: HttpSevletResponse的一个对象。 pageContext: PageContext的一个对象，可以从中获取到其它8个隐含对象以及页面的其它信息。 session: HttpSession的一个对象，代表浏览器和服务器的一次会话。 application: ServletContext的一个对象，代表当前的Web应用。 config: ServletConfig的一个对象。 out: JspWriter的一个对象。调用out.println()可直接把字符串打印到浏览器。 page： 指向当前JSP对应的Servlet对象的引用，使Object类型，只能使用Object类的方法。 exception：异常对象。在JSP页面中声明了isErrorPage=true后才会启用。  JSP基本语法 JSP模板元素 JSP中的HTML代码就是JSP模板元素。这是整个网页的骨架。\nJSP表达式 可以使用JSP表达式直接将一个Java变量或者表达式的计算结果输出到浏览器。待输出的变量或者表达式要在\u0026lt;%=和%\u0026gt;之间。\n 计算结果是一个字符串。 变量或表达式后面不能有分号，因为每个表达式都被翻译为一条out.print()语句。  JSP脚本片段 脚本片段就是嵌套在\u0026lt;%和%\u0026gt;之间的Java代码。这些脚本片段将被原封不动的被搬进JSP页面翻译成Servlet的_JspService()方法中。\n 多个脚本片段中的代码是可以相互访问的。 单个脚本片段中的Java语句可以不少完整的，但多个脚本片段组合后的结果必须是完整的。  JSP声明 JSP声明将Java代码封装在\u0026lt;%!和%\u0026gt;之间。这里面的代码会被插入到Servlet的_jspService()方法外面。 常用来定义相关的静态代码块、成员变量和方法。\nJSP中对域对象的属性操作 这里的域对象指的是request, session, application, pageContext这四个对象。它们都拥有下面的几个和属性相关的方法：\n Object getAttribute(String var1);: 获取指定属性值。 Enumeration\u0026lt;String\u0026gt; getAttributeNames();: 获取所有属性名组成的Enumeration对象。 void setAttribute(String var1, Object var2);: 设置属性。 void removeAttribute(String var1): 移除指定属性。  它们的作用范围各不相同，下面从小到大排列：\n pageContext: 仅限于当前页面，范围最小。 request: 仅限于同一个请求。 session: 仅限于一次会话（默认从浏览器打开到关闭）。 application: 仅限于当前Web应用，范围最大。  JSP指令 JSP指令用来告诉JSP引擎如何处理页面中的其余部分。基本的语法格式为：\u0026lt;%@ 指令 属性名=\u0026quot;属性值\u0026quot; %\u0026gt;。主要有一下三种指令：\n page指令：用来定义页面的各种属性。 include指令：用来通知JSP引擎在翻译JSP页面的时候将其他文件中的内容包含进当前JSP页面翻译成的Servlet中。使用的是 相对路径 。 taglib指令：用来引入所使用的标签库  JSP标签  \u0026lt;jsp:include\u0026gt;标签：用来把应一个资源的输出内容插入到当前JSP页面的输出内容中。使用 相对路径。 \u0026lt;jsp:forward\u0026gt;标签：用于把请求转发个另一个资源。使用 相对路径。 \u0026lt;jsp:param\u0026gt;标签：用来向程序传递参数信息。使用 相对路径。  请求的转发与重定向 请求转发 可以使用RequestDispatcher接口中的forward()方法进行请求转发。这个接口中定义了两个方法：\n include(ServletRequest request, ServletResponse response)方法：转发到请求到当前Web应用中的其他资源。 forward(ServletRequest request, ServletResponse response)方法：在响应中包含资源。  可以使用RequestDispatcher getRequestDispatcher(String forwardPath);来获取RequestDispatcer。\n请求的重定向 可以使用sendRedirect()方法来进行请求的重定向。不仅可以重定向到当前应用程序中的其它资源，还可以到同一站点上的其它应用程序中的资源，甚至 可以使用绝对路径到其它站点的资源。\n请求转发和重定向的比较 本质区别：请求转发只向服务器发出 一次 请求，而重定向发出了 两次 请求。\n   方法 请求转发 请求重定向     地址栏变化 首次发出的请求地址 重定向后最后响应的那个地址   最终Servlet中的request对象 和中转的那个request是同一个对象 和中转的那个request不是同一个对象   作用范围 限于当前Web应用 服务器上任何资源   \u0026ldquo;\\\u0026ldquo; 代表当前Web应用的根目录 代表整个Web站点的根目录    Cookie与Session HTTP是一种无状态的协议。Cookie和Session是Servlet中的两种会话跟踪机制。\nCookie Cookie采用的是在 客户端 保持HTTP状态信息的方案。它是在当浏览器访问WEB服务器上的某个资源的时候，有WEB服务器在HTTP响应消息头中附带传送的一个小的文本文件。一旦浏览器保存了这个Cookie，以后每次访问服务器的时候都会在HTTP消息头中将这个Cookie回传给服务器。\n 可以通过response对象的addCookie(Cookie cookie)方法向浏览器写入Cookie。 可以通过request对象的getCookie()方法从客户端获取Cookie。  默认情况下的Cookie当关闭浏览器的时候会消失。可以通过setMaxAge()方法设置Cookie的存活时间。\nSession Session采用的是在 服务端 保持HTTP状态信息的方案，以Cookie（默认实现方式，系统会创造一个名为JSESSIONID的输出cookie，称为session cookie）或者URL重写（禁用Cookie后的解决方案）为基础，使用SessionId唯一标识一个Session。\n Session的创建  当服务端的某个程序调用类似于HttpServletRequest.getSession()的方法的时候，Session对象 才会被创建 。  Session的删除  程序调用HttpSession.invalidate()方法 超过有效期 服务端进程终止  URL重写  使用HttpServletResponse接口定义的的encodeURL()或encodeRedirectURL()方法。   JDBC JDBC为Java程序员提供了一个独立于特定数据库管理系统、通用SQL数据库存取和操作的公共接口，可以使用它来连接提供了JDBC驱动的数据库。\nDriver接口 Java.sql.Driver接口是所有JDBC驱动程序都需要实现的接口，由不同的厂商提供不同的实现。\n加载与注册JDBC驱动  可以通过调用Class类的静态方法forName()来加载JDBC驱动。 DriverManager类负责管理驱动程序，它会调用Driver接口的实现。  建立数据库连接 数据库连接用来向数据库服务器发送命令。\n 可以调用DriverManager类的getConnection()方法建立到数据库的连接。还可以使用Driver接口的connect()方法建立到数据库的连接。其中DriverManager使用起来更加方便，还可以管理多个不同的驱动程序。 JDBC URL用来标识一个被注册的驱动程序。驱动程序管理器会通过这个URL选择正确的驱动程序，从而建立到数据库的连接。JDBC URL的标准由三部分组成，各个部分之间用冒号:分隔。\n 协议：JDBC中总是jdbc 子协议：用来标识一个数据库驱动程序 子名称：为定位数据库提供足够的信息   比如：使用mysql数据库的url连接可以是这样的：jdbc:mysql：//localhost:3306/database。 java.sql中有三个接口分别定义了对数据库的不同访问方式：\n Statement接口  Statement接口用来执行静态SQL语句。 可以通过调用Connection对象的createStatement()方法创建Statement对象。剩下的两个接口都是这个接口的子类型。  PreparedStatement  PreparedStatement接口用来执行预编译的SQL语句。 可以通过调用Connection对象的prepareStatement()方法来获取PreparedStatement对象。 PreparedStatement对象多代表的SQL语句中的参数用问号?来表示，并通过对应的setXXX(index, value)来设置这些参数。其中index从1开始。 使用本接口可以防止SQL注入。  CallableStatement  CallableStatement接口用来执行SQL存储程序。   数据库的查询和更新  数据库更新  常用int executeUpdate​(String sql)方法可以进行数据库的插入、修改和删除操作。  数据库查询  常用ResultSet executeQuery​(String sql)方法来进行数据库的查询操作。   ResultSet ResultSet接口以逻辑表格的形式封装了执行数据库操作得到的结果集。ResultSet对象维护了一个指向当前数据行的 游标 。初始的时候，游标在表格的第一行 之前 。可以通过next()方法移动到下一行，然后调用getXXX(index)或getXXX(columnName)来获取对应列的值。\n常用数据类型转换表    Java类型 SQL类型     int INTEGER   long BIGINT   short SMALLINT   String CHAR, VARCHAR, LONGVARCHAR   boolean BIT   byte TINYINT   byte array BINARY, VARBINART   java.sql.Date DATE   java.sql.Time TIME   java.sql.Timestamp TIMESTAMP    使用JDBC驱动程序处理元数据 元数据是关于数据的数据。\nDatabaseMetaData类 DatabaseMetaData类提供了获取和数据库系统有关的各种信息的方法，也就是 元数据 。而又可以从Connection对象获得DatabaseMetaData的对象。\nResultSetMetaData类 ResultSetMetaData类提供了获取ResultSet对象中列的类型和属性信息的方法。\n 可以通过调用ResultSet对象的getMetaData()方法来获取它的对象。 可以使用getColumnCount()方法来获取SQL语句中查询了多少列。 可以使用getColumnLabel(int colunm)方法来获取指定列的别名。其中索引从1开始。  数据库连接池 数据库连接池的基本思想是为数据库建立一个缓冲池，并预先往缓冲池里放入一定数量的连接。当需要和数据库建立连接时，直接从连接池里取出连接，用完之后再归还给连接池。\n数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。\nMVC设计模式 MVC把应用分为模型、视图和控制器三个模块，它们各自处理不同而任务。\n模型 模型应用程序的主体部分，表示业务数据和业务逻辑。一个模型可以为多个视图提供数据。\n视图 视图接收用户输入、向用户展示相关数据。但不进行任何实际的业务处理。\n控制器 控制器接收用户请求并决定调用哪个模型去处理请求，然后决定调用哪个视图显示模型处理返回的数据。\nFilter(过滤器)  Filter是Java Web的一个重要组件，它的基本功能是对Servlet容器调用Servlet的进程进行拦截（拦截请求和响应），从而在Servlet进行响应处理的 前后 实现一些特殊的功能。\n Servlet的API中定义了三个供开发人员编写Filter程序的接口：Filter, FilterChain, FilterConfig。Filter程序是一个实现了Filter接口的Java类，它和Servlet非常类似，并且由Servlet容器进行调用和执行。没有相应的Filter实现类可供继承，要开发Filter，需要自己实现接口。\n和使用Servlet类似，Filter程序需要在web.xml文件中注册和设置它所能拦截的资源（Jsp, Servlet, image, html），这也可以通过 注解 来完成。\n对于多个Filter拦截同一个url的情况：\n 使用注解：多个Filter的执行顺序的由Filter实现类名的字符顺序来决定，这会给维护增加难度。比如：现在有Test1Filter和Test2Filter,它们都对test.jsp进行拦截。初始化的顺序是：Test1Filter先初始化，而后是Test2Filter。拦截执行的顺序是：Test2Filter在前，而Test1Filter在后。\n 使用web.xml：执行按照filer-mapping声明顺序执行，这就更加清晰可见。最好使用后一种方法。\n  Filter接口  default void init(FilterConfig filterConfig) throws ServletException  Filer对象的初始化方法，在Filter对象被创建时（Filter对象在Servlet容器加载当前Web应用时被创建）执行，只执行 一次 FilterConfig类似于ServletConfig  void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3)  逻辑代码，每次拦截都会被调用 FilterChain: 多个Filter构成的一个链。在特定的操作完成后，可以在当前Filter对象的doFilter()方法内部需要调用FilterChain 对象的chain.doFilter(request,response)方法才能把请求交付给Filter链中的下一个Filter或者目标Servlet程序去处理，也可以直接向客户端返回响应信息，或者利用RequestDispatcher的forward()和include()方法，以及HttpServletResponse的sendRedirect()方法将请求转向到其他资源。  default void destroy()  用来释放当前Filter所占用的资源，在Filter被销毁之前调用，只调用一次。   Filter的配置 Filter的注册 在web.xml中注册Filter，使用\u0026lt;filter\u0026gt;元素，也可以用注解注册。使用web.xml时：\n \u0026lt;filter-name\u0026gt;为Filter指定一个名字，不能为空。 \u0026lt;filter-class\u0026gt;为Filter的完整限定类名。 \u0026lt;init-param\u0026gt;用来设置初始化参数（使用\u0026lt;param-name\u0026gt;指定参数名，\u0026lt;param-value\u0026gt;指定参数值）。  这一步骤使用注解会方便得多。\nFilter的映射 使用\u0026lt;filter-mapping\u0026gt;元素，可以为一个Filter设置所负责拦截的资源，其中有两种方式可以指定：Servlet名称和资源访问的请求路径(url)。\n \u0026lt;filter-name\u0026gt;子元素用于设置filter的注册名，该名必须是已经注册了的名字。 \u0026lt;url-pattern\u0026gt;用来设置拦截的请求路径 \u0026lt;servlet-name\u0026gt;用来指定拦截的Servlet名称 \u0026lt;dispatcher\u0026gt;指定所拦截的资源被Servlet容器调用的方式。可以是：REQUEST, INCLUDE, FORWARD和ERROR。默认是REQUEST。  REQUEST: 当用户 直接 访问页面的时候，这个Filter会被调用。如果目标资源是通过RequestDispatcher的include()或forward()方法访问的话，就不会被调用。 INCLUDE: 只有当目标资源时通过RequestDispatcher的include()方法访问时，Filter才会被调用。 FORWARD: 只有当目标资源时通过RequestDispatcher的forward()方法访问时，Filter才会被调用。 ERROR: 只有当目标资源时通过声明式异常处理机制调用的时候，Filter才会被调用。   Listener(监听器)  Listener是专门用来对其它对象身上发生的事件或者状态改变进行监听和采取相应处理的对象。\n Servlet监听器是Servlet规范中定义的一种特殊的类，用于监听Web应用程序中的ServletContext, HttpSession和ServletRequest等域对象的创建、销毁以及属性发生改变的事件。\nListener的分类 监听域对象自身的创建和销毁的Listener  ServletContextListener接口  这个接口用于监听ServletContext对象的创建和销毁事件。当ServletContext对象被创建的时候，触发contextInitialized()方法；当ServletContext对象被销毁的时候，触发contextDestroyed()方法。常用来对当前Web应用进行初始化操作。  HttpSessionListener接口  这个接口用于监听HttpSession对象的创建和销毁事件。当Session对象被创建的时候，触发sessionCreated()方法；当Session对象被销毁的时候，触发sessionDestroyed()方法。  ServletRequestListener接口  这个接口用于监听ServletRequest对象的创建和销毁事件。当ServletRequest对象被创建的时候，触发requestInitialized()方法；当ServletRequest对象被销毁的时候，触发requestDestroyed()方法。   监听域对象中属性的增加、删除或修改的Listener 有三个Listener接口，分别是ServletContextAttributeListener, HttpSessionAttributeListener和ServletRequestAttributeLitener。它们中分别定义了监听对应域对象的属性的增加、修改和删除的方法。方法名完全相同，只是接受的参数不同。分别是：attributeAdded(), attributeReplaced()和attributeRemoved()。\n监听绑定到HttpSession域中某个对象状态的Listener 有两个特殊的Listener接口用来帮助JavaBean对象了解自己在Session域中的状态。分别是：\n HttpSessionBindingListener接口  感知自己被绑定到Session中。Web服务器此时会调用valueBound()方法。 感知自己被从Session中解除绑定。Web服务器此时会调用valueUnbound()方法。  HttpSessionActivationListener接口  绑定到HttpSession对象的对象将要随HttpSession对象被钝化之前，Web浏览器此时会调用sessionWillPassivate()方法。 绑定到HttpSession对象的对象将要随HttpSession对象被活化之后，Web浏览器此时会调用sessionDidActive()方法。   `可以完成基于表单的文件上传操作，需要指定表单的`enctype`属性值为`multipart/form-data`，表示表单以二进制传输数据。默认为`application/x-www-form-urlencoded`，这种编码方案使用有限的字符集，不适合大容量的二进制数据或者包含了非ASCII字符的文本。 -- ","href":"/blogs/java-web%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Java Web复习笔记"},{"content":"","href":"/tags/leetcode/","title":"Leetcode"},{"content":"","href":"/categories/leetcode/","title":"Leetcode"},{"content":" 这是Leetcoce上的第279个问题，解题的方法很有启发意义，以此备忘。\n题目描述 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, \u0026hellip;）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n示例 1:\n输入: n = 12 输出: 3 解释: 12 = 4 + 4 + 4. 示例 2:\n输入: n = 13 输出: 2 解释: 13 = 4 + 9. 解决方案 一个错误的方法 最开始的想法是依次对每个数进行开方操作，这样能够找到比它小的最接近它的完全平方数。代码如下：\nprivate int numSquares1(int n){ int step = 0; while(n \u0026gt; 0){ n -= Math.pow((int)(Math.sqrt(n)), 2); step ++; } return step; } 这段代码使用的是贪心算法的思想，每次找比 n 小的最大的完全平方数。错误的原因是：这个贪心策略在这里 并不适用 。题目中就有一个反例：\n12 = 4 + 4 + 4 一个正确的方式 贪心策略不适用，又不想使用暴力解法。那么有没有好一点的解题方法呢？答案是有的：可以把原问题转化为一个 图论 中的问题。转化方法如下：\n 对于从 n 到 0 的每一个数字，让其成为图中的一个顶点； 如果图中的两个数字之间相差一个完全平方数，则连接它们；  这样一来，原来的问题就转化为求：n 到 0 之间的 最短路径 的问题。使用广度优先遍历的策略就可以找出答案。\njava代码如下：\n/** * 最开始是想用贪心算法来求解，但是后来发现贪心算法在这里并不适用。比如:12 = 4 + 4 + 4; * 这里可以将问题转化为一个求图中的最短路径的问题： * 从n到0,每个数字表示一个节点。如果两个数字之间相差一个完全平方数，则连接它们。 * 最终会得到一个无权图，此时原问题就转化为求这个无权图中n到0的最短路径。 * 使用BFS的思想对图进行层序遍历，从n所在层到0所在层 * @param n 给定的正整数n * @return 和为n需要的最少的完全平方数 */ private int numSquares(int n){ if(n \u0026lt;= 0){ return 0; } int step = 0; // 存放最终结果  Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(n); // 初始节点n入队  int size = queue.size(); // 保存当前层的节点数  while(!queue.isEmpty()){ if(size == 0){ size = queue.size(); step ++; } int number = queue.poll(); // 队首元素出队  size --; if(number == 0){ return step; // 到达终点0，结束程序  } for(int i = 1;number \u0026gt;= i * i;i ++){ // number内还存在完全平方数  queue.offer(number - i * i); } } } 不幸的是：这段代码在Leetcode上 超时 了。\n于是我改用了 Pair\u0026lt;\u0026gt; 对的形式，减少了对上面代码中size取值的判断次数，期望程序能快一点。代码如下：\nprivate int numSquares2(int n){ if(n \u0026lt;= 0){ return 0; } int step = 0; // 存放最终结果  Queue\u0026lt;Pair\u0026lt;Integer, Integer\u0026gt;\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(new Pair\u0026lt;\u0026gt;(n, 0)); // 初始节点n入队  while(!queue.isEmpty()){ Pair\u0026lt;Integer, Integer\u0026gt; pair = queue.poll(); // 队首元素出队  int number = pair.getKey(); step = pair.getValue(); if(number == 0){ return step; // 到达终点0，结束程序  } for(int i = 1;number - i * i \u0026gt;= 0;i ++){ // number内还存在完全平方数  queue.offer(new Pair\u0026lt;\u0026gt;(number - i * i, step + 1)); } } return step; } 然而：还是 超时 了。\n于是我开始仔细看这一段代码，发现了引起性能问题的最大原因：对于较大的数字，每次执行for循环的时候，都会往队列中推入很多重复的路径。比如要到达数字1所在的节点，可能从2、5、10、17、26\u0026hellip;出发 。只要减少了重复的路径，程序的性能应该就会有不少的提升。为了解决重复复访问的问题，我新开了一个数组，用来判断某个节点是否已被访问，现在只将没有被访问过的节点推入队列。\njava代码如下：\nprivate int numSquares3(int n){ if(n \u0026lt;= 0){ return 0; } int step = 0; // 存放最终结果  Queue\u0026lt;Pair\u0026lt;Integer, Integer\u0026gt;\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(new Pair\u0026lt;\u0026gt;(n, 0)); // 初始节点n入队  boolean[] visited = new boolean[n + 1]; // 用来保存已经访问过的节点  visited[n] = true; while(!queue.isEmpty()){ Pair\u0026lt;Integer, Integer\u0026gt; pair = queue.poll(); // 队首元素出队  int number = pair.getKey(); step = pair.getValue(); if(number == 0){ return step; // 到达终点0，结束程序  } for(int i = 1;number - i * i \u0026gt;= 0;i ++){ // number内还存在完全平方数  if(!visited[number - i * i]) { queue.offer(new Pair\u0026lt;\u0026gt;(number - i * i, step + 1)); visited[number - i * i] = true; // 更新visited[]  } } } return step; } Accepted!耶~\n终于能够看到用时极短的答案是怎么做的了。原来它们使用了 数论 的知识。我赶紧去补了一下 四平方定理 。\n四平方和定理 ：任何一个正整数都可以表示成不超过四个整数的平方之和。\n推论 ： 当n是形如:\\(4^a(8b + 7)(a \u0026gt;= 0;b \u0026gt;= 0)\\)n不能表示成3个整数的平方和\n借助这两条定理，我自己实现了一下。 java代码如下：\n// 使用四平方和定理及其推论  private int numSquares4(int n){ while(n % 4 == 0){ n /= 4; } if(n % 8 == 7){ return 4; } // 判断一个数是由一个还是两个平方数组成  int r = (int)Math.sqrt(n); if(r * r == n){ return 1; } for(int t = 1;t * t \u0026lt;= n;t ++){ int k = (int)Math.sqrt(n - t * t); if(k * k + t * t == n){ return 2; } } return 3; }","href":"/blogs/perfect-squares/","title":"完全平方数"},{"content":" 这是Leetcode上的第344题，虽然很简单，但是涉及到一些技巧，于是我决定把我试过的方法记录下来。\n题目描述 请编写一个函数，其功能是将输入的字符串反转过来。\n示例：\n输入：s = \u0026#34;hello\u0026#34; 返回：\u0026#34;olleh\u0026#34; 解决方案 反转字符串的方法由很多种，但是各自的效率会有些差别。\n方法一 重新开辟一个字符串，然后将原来的字符串从后向前一个一个复制到新的字符串中。这可能是最容易想到也最经常使用的一个方法。\nprivate String reverse(String s){ String r = \u0026#34;\u0026#34;; int n = s.length(); for(int i = n - 1;i \u0026gt;= 0;i--){ r += s.charAt(i); } return r; } 不幸的是，这个方法未能通过所有的测试用例，最终超时了。。。\n方法二 前一个方法失败了，于是决定采用对撞指针的方法来碰碰运气。初始化两个指针，一个指向字符串的开头，一个指向字符串的结尾，同时向中间移动直至两指针相遇，在移动的过程中交换各自指向的那个字符即可。但是问题来了，Java中没有直接提供在字符串上修改指定位置字符的方法。不过，Java提供了将字符串转为字符数组的方法，这也能达到我的目的。\nprivate String reverse2(String s){ char[] a = s.toCharArray(); int l = 0, r = a.length - 1; while(l \u0026lt; r){ char c = a[l]; a[l] = a[r]; a[r] = c; r --; l ++; } String s1 = \u0026#34;\u0026#34;; for(int i = 0;i \u0026lt; a.length;i ++){ s1 += a[i]; } return s1; } 本来以为这个方法能够通过测试，然而还是失败了。呜呜呜……，问题就在于最后5行。方法四就是对这几行的改进。\n方法三 查阅API发现，Java中StringBuilder提供了反转字符串的方法，于是我决定试一试：\nprivate String reverse3(String s){ return new StringBuffer(s).reverse().toString(); } 短小精悍，这个方法通过了测试，并且只花了4ms。但还是不够好。\n方法四 这是方法二的改进，能把测试时间缩短至2ms，是我目前知道的最快的方法了：\nprivate String reverse2(String s){ char[] a = s.toCharArray(); int l = 0, r = a.length - 1; while(l \u0026lt; r){ char c = a[l]; a[l] = a[r]; a[r] = c; r --; l ++; } return new String(a); }","href":"/blogs/java%E4%B8%AD%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","title":"Java中反转字符串的几种方法"},{"content":" 这是Leetcode上的第215题：数组中的第k个最大元素。\n问题描述 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n示例 1:\n输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 示例 2:\n输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 解决方案 提供两种解法，一种是使用快速排序的解法，一种是使用划分思想但不排序的解法。\n使用排序 要找出数组中第K个最大的元素，最直观的方法就是先将原数组按照非递增顺序排序，然后返回第K个元素。我这里使用的是快速排序。\n快速排序需要先对数组进行划分，划分的代码如下：\n/** * 总是使用最右端的元素A[r]将数组A[p..r]划分为A[p..q - 1]、A[q]、A[q + 1..r] * A[p..q - 1] \u0026gt;= A[q] * A[q + 1..r] \u0026lt; A[q] * @param A 待划分数组 * @param p 下界 * @param r 上界 * @return q */ private int partition(int[] A, int p, int r){ int x = A[r]; // 保存最右端元素  int i = p - 1; // i最终指向A[p..q - 1]中的最后一个元素  for(int j = p;j \u0026lt;= r - 1;j++){ if(A[j] \u0026gt;= x){ i ++; exchange(A, i, j); // 将不小于A[q]的元素A[j]放到A[p..q - 1]中，同时一个小于A[q]的元素被放到A[q + 1..r]中  } } exchange(A, i + 1, r); // 将最右端的元素放到正确位置  return i + 1; } 接下来是寻找第K个最大的元素了：\nprivate void quickSort(int[] nums, int p, int r){ if(p \u0026lt; r){ int q = partition(nums, p, r); quickSort(nums, p, q - 1); quickSort(nums, q + 1, r); } } public int findKthLargest(int[] nums, int k){ int p = 0, r = nums.length - 1; quickSort(nums, p, r); return nums[k - 1]; } 使用划分 利用快速排序中划分的思想，假定始终选取数组A[0..n-1]中的最后一个元素（划分后它在数组中的位置为q）作为参照点，划分后的结果为：A[1..n-1]在划分后由三部分组成，从左到右依次为：\n A[0..q-1]: 均不小于A[q]; A[q] A[q+1..n-1]:均小于A[q];  由此可确定第K大的元素的位置：\n k = q + 1: 返回A[q]; k \u0026lt; q + 1: 在A[0..q-1]中继续寻找第K大的元素 k \u0026gt; q + 1： 在A[q+1..n-1]中继续寻找第(k - q + 1)大的元素  递归版本的代码如下：\nprivate int findKthLargestHelper(int[] nums, int k, int p, int r){ int q = partition(nums, p, r); if(k == q + 1){ return nums[q]; } else if(k \u0026lt; q + 1){ return findKthLargestHelper(nums, k, p, q - 1); } else{ return findKthLargestHelper(nums, k - q + 1, q + 1, r); } } 迭代版本做了一点改动，代码如下：\nprivate int findKthLargestHelperIteratively(int[] nums, int k, int p, int r){ int q = partition(nums, p, r); while(k != q + 1){ if(k \u0026lt; q + 1){ q = partition(nums, p, q - 1); } else{ q = partition(nums, q + 1, r); } } return nums[q]; }","href":"/blogs/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/","title":"寻找数组中的第K个最大的元素"},{"content":" 问题描述 荷兰国旗问题(Dutch national flag problem)是Dijkstra提出的一个经典的编程练习。原问题大概是这样说的：\n Dijkstra used the Dutch National Flag Problem* as a structured programming exercise in program derivation and program proof. Given `N\u0026rsquo; objects coloured red, white or blue, sort them so that objects of the same colour are adjacent, with the colours in the order red, white and blue.\n Leetcode上的第75题——分类颜色考查的也正是这个问题。\n解决方案 使用任意一种排序算法 这其实是一个对数组元素进行排序的问题，因此使用任意一种排序算法均可以达到目的。\n使用计数排序 一个较为方便的排序算法是使用计数排序，统计每种颜色出现的次数，然后按照红、白、蓝(使用0,1,2代表红、白、蓝)的出现的次数排序，重写当前数组，这正是计数排序的思想。这个方法要扫描两遍数组：第一遍统计各元素出现的次数；第二遍重写当前数组。还需要开辟额外的空间来支持计数这个操作。\n 时间复杂度为：O(n); 空间复杂度为：O(k), k为元素的取值范围;  Java实现 private void countingSort(int[] nums){ int[] c = new int[3]; int n = nums.length; for(int i = 0;i \u0026lt; n;i++){ c[nums[i]] ++; } int k = 0; for(int i = 0;i \u0026lt; 3;i++){ for(int j = 0;j \u0026lt; c[i];j++){ nums[k ++] = i; } } } 使用划分 另一种解法就是利用快速排序中三路划分的思想。这样做的好处是只需要扫描一趟数组。划分过程中原来的数组由四部分组成，从左到右依次为：全0，全1，未处理，全2。初始示意图如下： 运行过程中示意图如下： 这样无需开辟新的数组。\n 时间复杂度：O(n); 空间复杂度：O(1);  Java实现 public void tripartition(int[] nums){ int n = nums.length; int zero = -1; // 从左到右指向最右的那个0  int two = n; // 从右到左指向最左的那个2  int i = 0; // 用来遍历数组  while(i \u0026lt; two){ switch (nums[i]){ case 0: exchange(nums, ++zero, i ++);break; // nums[i] = 0,将它与最右侧的那个1交换  case 1: i ++;break; // nums[i] = 1,指针前进一步  case 2: exchange(nums, -- two, i);break; // nums[i] = 2,将它与最左侧的那个2的前一个元素交换  default: break; } } }","href":"/blogs/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/","title":"荷兰国旗问题"},{"content":"","href":"/categories/life/","title":"LIFE"},{"content":"  在北邮一年的交换学习已经结束。仔细想想我这一年，好像并没有什么值得一提的。在我的印象里，第一学期的大多数时间都花在了学校开设的课程上，总是在完成课程作业或者相关的东西，取得一个看起来还不错的成绩真心不容易。出于对新地方的好奇感，在周末，我总是喜欢出去转转，一个学期下来，我对北京的了解程度居然超过了已经在北京上了两年大学的室友。\n到了第二学期，课程数量只有第一学期的一半，这就有了大量可支配的自由时间。我变得空闲下来，这个时候开始思考自己接下来到底该做什么。刚开学的3月份，北邮就有不少人开始准备考研了。对于考研，我也陷入了犹豫当中，过了一个月，我意识到再这么犹豫下去是不行的。于是我决定买一本《李永乐数学复习全书》，先做做试试看。两个月过去了，《全书》也看完了。然后我发现，我的内心是抗拒考研的，我更加倾向于毕业后直接工作。于是我丢弃了那本充满笔墨的《全书》，开始思考就业的事情。也开始复习自己的专业技能。\n真正让我获益很大的是第二个学期的那些空闲时间，这让我有了很多的时间来思考自己到底想要什么。特别是听过北京GDG在3月底举办的灯塔IO和微软在6月举办的Insider Dev Tour之后，我对自己应该提升的能力有了更加明确的认识。他们也正是我想告诉学弟学妹们的一些建议。\n 在北京的一些经历，让我看到了很可怕的一点: 比你优秀的人比你还努力！\n我绝不是一个优秀的计算机专业的学生，但我正朝成为优秀的计算机人才努力。如何让自己变得更加的优秀呢?我觉得要诀有下:\n 夯实专业基础，提升专业能力水平； 树立终身学习的目标，学习是没有止境的； 培养一种不轻易放弃的态度；  PS：下面只是一些我个人的看法，要学会用批判的态度看待各种东西。\n专业相关 专业课程 我是大二才转来计算机学院的。在大二，我们最重要的专业课有《离散数学》、《数据结构》。我敢肯定的说:除了我之外，还有很多人在那个时候不知道《离散数学》和《数据结构》这两门课对我们计算机专业的学生来说是多么的重要。当然还有同一学期的《计算机组成原理》，这是一门偏理论和硬件的课程。我们很多人都觉得我一个计算机专业的学生多学点编程，整天学这一堆数学和与硬件相关的东西有什么用？！\n我觉得让我们产生这些想法的原因有两个：\n 老师没有在课程开始之前给我们讲清楚这门课程对我们到底有什么用 我们自己没有主动去搞清楚这些课程到底有什么用  总而言之，我们不知道这些课程到底有什么用。后来，我终于明白了学校给我们开设的课程到底有什么用了：\n 在说数学的重要性之前，我觉得应该祭出《数据结构》和《算法设计与分析》这两门课。它们是我们用编程解决复杂问题必须要考虑的东西。当我们遇到问题，在开始编写代码之前，我们需要先设计好程序的总体框架，划分程序的功能模块。然后决定不同功能模块应该采用怎样的算法以及数据结构。这时我就想起来了那个著名的公式：$$ 程序 = 算法 + 数据结构 $$而写算法不仅仅是用一些数学模型，还有逻辑推理的过程。很多时候你想到的东西到最后实现的时候都要用到数学。 再说说数学，数学是各种算法的基础。我们学校计科专业在大学主要就学《高等数学》、《离散数学》、《线性代数》和《概率论与数理统计》这四门课程。《高等数学》放哪个理工科的专业你都得学，它还是《概率论与数理统计》基础，学过《概率论与数理统计》的都知道，这里面会遇到一大堆微积分相关的知识。我认为《离散数学》是我们计算机专业学生最应该好好学习的一门数学课，它是算法的基础，是加密理论的基础。当你学习《算法设计与分析》这么课程的时候，你就会再次见到很多《离散数学》里面的知识了，只不过这次你是用它们而不是学它们。最后剩下《线性代数》和《概率论与数理统计》，关于它们的用处，你随便翻一下一本有关机器学习、数据挖掘、自然语言处理导论等这些当前比较火的人工智能技术就知道了。关于数学在计算机领域的应用，有一本书可以直观的解决你们的疑惑——吴军的《数学之美》。 还有一堆理论和硬件相关的课程。它们告诉了我们计算机是如何工作和构成的。它们或许不能直接给我们带来收益，但你绝对会在以后的工作生涯里收益于它们。它们可能是你多于同龄人的一个技能。  编程能力 编程能力是我们计算机专业学生最基本的能力。我们通过编程来解决问题，实现自己的想法。你的编程能力和你编写的代码量有着直接的关系。我以前都是懒得写程序，总觉得有些太简单，用不着直接把程序写出来。后来一遇到需要编程解决的问题的时候，往往会遇到“难产”的问题，半天写不出几行代码，不知道从哪开始。意识到这个问题之后，我就开始了积累代码量的过程。\n编程语言 编程语言层出不穷，各有各自的优势。与此对应的还有不断涌现的各种新技术。我觉得编程语言不应该是我们重点学习的对象，编程语言只是解决问题的一个工具。我们需要重点学习的是编程思想，然后精通一门面向过程的语言和一门面向对象的语言。在我们需要使用新的编程语言来解决问题的时候，找一份Tutorial,是能够很快速的入门的，然后借助于编程语言的文档和搜索引擎就可以开始工作了。\n所以我认为需要重点学习的是解决问题的思想，编程的思想，抽象思维，原理和方法。\n积累经验 趁着还在大学，有着充足的学习时间，做一些小的项目，积累一些项目经验吧，它将是我们最宝贵的财富之一。写点东西来记录是一个不错的方式。\n关于学习 除了需要学习编程以外，我觉得写作和英语也是我们应当重点培养的能力。\n学习写作 为什么要学习写作呢？我说的写作可不是让你写什么文学作品啊。我的意思是，写一些和自己专业相关的东西，记录一些自己在学习过程中遇到的问题以及是如何解决这些问题的，写一些学习笔记。好记性还是敌不过键盘侠啊。一个非常好的方式就是写博客。\n其实我大二的时候就想建一个自己的博客网站了，但当时总觉得自己太菜，写的东西太low，也不知道写什么，然后就放弃了。我真正开始写博客的时间是大三的下学期，那时候我的空闲时间很多，我又是一个喜欢折腾的人，然后就会遇到各种奇奇怪怪的问题。遇到了问题怎么办呢？当然是Google了，一般情况下，通过Google总能找到问题的解决方案，但有时候也会花掉你大量的时间。如果每次出现的问题都是不同的问题，那么这是没有什么影响的，还是得花时间去查。因为每次都是照着别人讲的方法一步步做解决问题的，基本上解决完问题过不了多久就会忘记。等到同样的问题再次出现的时候，又要重复之前的工作，去尝试那些可能的解决方案，这就很浪费时间了。那么有没有什么可以减少这种重复性劳动的方法呢，方法就是自己写博客记录下这次的解决方案，以备下次使用。\n其实我的博客是写给我自己看的，我觉得可以了就可以了，不用担心别人怎么说。\n建立自己的博客网站 我用Hugo(一个用Go语言编写静态网站生成框架)和Github Pages建立了自己的博客网站，其实就是记录一些自己学习的东西以及踩坑日记，方便自己以后回忆或者查阅。比起在电脑本地笔记来说，一个能够随时通过手机或者电脑访问的博客网站的优势不知道好到了哪里去。如果你能够让别人通过搜索引擎找到你写的东西并从其中受益，那么我觉得你应该会很高兴。\n当前搭建博客网站的框架很多，使用起来也很方便。主流的有Hexo、Hugo、Jekyll等等。关于它们，网上都有很多的教程。Hugo的编译速度是最快的，同时支持Markdown语法，但网上的中文参考资料不如其它的多，绝大多数多是英文资料。中文文档至今还没翻译完成，使用Hugo需要一定的英语能力。下面就是使用Hugo生成的这篇文章的一部分： 选择一个漂亮的皮肤，你的博客网站就会显得很漂亮。\n有人可能会问，写博客不会花很多时间吗？写博客当然会花时间，但它能够帮你节省更多的时间，还能够帮助形成你自己的知识体系。那做笔记来说，如果你有做笔记的习惯，笔记都是要做的，那么为什么不把笔记写在一个你更加容易查阅的地方呢。\n写下你的想法并分享给别人 近年来，知识付费的潮流开始兴起。如果你拥有一个粉丝圈，或者是你能够提供别人需要的知识，你就能从中获得回报。在这之前，别人得知道你并认可你。或许写博客能够成为你自我营销的一种方式呢。\n学习英语 可以毫不夸张的说，英语是程序员除母语外的第二语言。不单单是计算机专业，各行各业都被英语影响着。Wikipedia上英语词条的数目远超中文词条，而且英文词条的质量也更高。下面是当前Wikipedia的词条数量： 拿我们计算机专业来说，我们遇到的绝大多数问题都能在StackOverFlow上找到答案，然而这个网站是英文的。如果你的英语很差，只能靠着百度搜索一些国内的资料也是能正常工作的，汉语是我们的母语，没有交流障碍，也更加容易理解。但一到专业方面，尤其是我们计算机行业的东西，光靠中文可能就不够用了。\n计算机的相关理论几乎都是从国外发展起来的，很多专业文档都是用英语写的。如果你对比阅读过一本国外的原版英文教材和它在国内的翻译版本，你最终应该会认为：还是原版的好理解，中文翻译得太别扭了。国外的教材都很厚，不像国内的教材那么薄，那是因为国外上课讲的少，作者为了方便学生自学才写了那么多的内容，国内主要的知识还是靠老师来讲，很多课程拿着老师上课的PPT不用教材也能轻松通过，可最后学到的东西有那么多那么扎实吗？看翻译版的书的时候，你可能就不能那么准确的领会原作者的意图了，翻译是不可能做到百分之百准确的。\n当我们写程序的时候，很多时候都需要去查阅相关的技术文档。这个时候你可以使用网页翻译插件来帮助你你看懂文档，但插件翻译出来的准确度也是有限制的。最好的方法还是自己看，那样不会有太多的信息的损失，也没有那么容易产生歧义。\n如何学 如果只是为了能够看懂英文文档，那就容易多了。你只需要不断地积累自己的词汇量就可以了，不断地去眼熟新的单词，看多了自然就记住了。我学习英语词汇用的就是：Vocabulary.com + 欧路词典。它们在英语学习方面给了我巨大的帮助。如果你想系统的搞清楚某一个单词是什么意思，我推荐给你一个网站：Vocabulary.com，它用英语解释英语，能够让你直观的感受到单词的意思以及相近单词之间的区别。我一直觉得一种语言是不能完整准备的表达出另一种语言所要表达的信息的。上面那个网站是全英文版的，你可能会看不懂。所以，我再推荐给你一部词典：欧路词典，它支持扩充词库，你可以自由加载各种词库，包括各种原生英文例句。结合英文词库和中文词库，你能够更好的理解一个词的意思。当然，这只是词汇，理解一个单词最好的方法还是要看它所处的语境。就像中国汉字博大精深一样，英文单词也是博大精深。如果你想更好的学习英语，那就要自己想办法了，我已经把我用到的最好的两个软件推荐给你了。我当前的目标是，做到不借助翻译软件阅读英语，口语始终是硬伤。\n专注力 通过北邮学习的经历，我发现很多北邮人程序写得好的原因不单单是因为他们写得多，还有一个重要的原因是他们做事情的时候很专注。我觉得专注力应该也是我们必备的素质之一。当遇到难以解决的问题，不同人处理的态度是不一样的，我之前在网上看到一个缎子描述的很形象。 大概是说：985的正面硬刚，不干出来不罢休；211的先尝试，尝遍各种方法依然无果，于是放弃；民办的见状说，太难了，我选择放弃。 这或许就是不同学校之间的一个重要差距吧。不要轻易的放弃。\n提高工作效率的一个重要方法就是提高自己的专注程度，也就是减少外界干扰自己的程度或者增加自己抵抗外界干扰的程度。\n几个小建议  推荐一本书《软技能：代码之外生存指南》； 趁你还在大学，少呆寝室，多出去走走，外面的世界很精彩； 锻炼身体，少熬夜；  ","href":"/blogs/%E5%8C%97%E9%82%AE%E5%9B%9E%E5%BF%86/","title":"北邮回忆"},{"content":"","href":"/categories/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E4%B9%8B%E6%97%85/","title":"《算法导论》之旅"},{"content":"  许多随机算法通过排列给定的输入数组来使输入随机化。这里的目标是构造数组 A 的一个随机排列。\n 方法一：排序 为数组的每一个元素 A[i] 分配一个随机的优先级 P[i] ，然后根据优先级来对数组 A 中的元素进行排序。比如：\nA = {43, -1, 82, 61, -87, -86, -55, 28, 47, -97}\nP = {70, 433, 302, 154, 805, 810, 740, 287, 213, 41}\n排序后的 A 就是：\nA = {-97, 43, 61, 47, 28, 82, -1, -55, -87, -86}\n方法二：原地排列 假设数组 A 的长度为 n , 进行 n 次迭代，在第 i 次迭代的时候， 从 A[i..n] 中随机选取一个元素来作为 A[i] 。第 i 迭代之后， A[i] 就不再改变。\n实现 主要java代码如下：\nimport ch02.GenerateTestData; import java.util.Random; class PermutingArraysRandomly{ public void printArray(int[] A){ int n = A.length; for(int i = 0;i \u0026lt; n;i++){ System.out.printf(\u0026#34;%-6d\u0026#34;, A[i]); if((i + 1) % 10 == 0) System.out.println(); } } /** * @param a 下界 * @param b 上界 * @return [a, b]之间的一个随机整数 */ public int rand(int a, int b){ Random random = new Random(); int c = b - a; return random.nextInt(c + 1) + a; } /** * 交换A[i]和A[j]的值 * @param A * @param i * @param j */ public void exchange(int[] A, int i, int j){ int t = A[i]; A[i] = A[j]; A[j] = t; } /** * 根据优先级对数组A进行选择排序 * @param A 待排序数组 * @param P 优先级数组 * @return 根据优先级排序后的数组 */ public int[] selectSort(int[] A, int[] P){ int n = A.length; for(int i = 0;i \u0026lt; n;i++){ int minp = i; for(int j = i + 1;j \u0026lt; n;j++){ // 值小的优先级高  if(P[j] \u0026lt; P[minp]){ minp = j; } } exchange(A, i, minp); exchange(P, i, minp); } return A; } /** * 为数组的每个元素A[i]分配一个随机的优先级P[i]，然后根据优先级对数组A中的元素进行排序。 * @param A * @return 按优先级排序后的数组，即随机排列后的数组 */ public int[] permuteBySorting(int[] A){ int n = A.length; int[] P = new int[n]; // 优先级数组  for(int i = 0;i \u0026lt; n;i++){ P[i] = rand(0, n * n * n + 1); // 使P[i]尽可能唯一  } System.out.println(\u0026#34;\\nP:\u0026#34;); printArray(P); selectSort(A, P); // 根据优先级排序A  System.out.println(\u0026#34;\\nsorted:\u0026#34;); printArray(A); return A; } /** * 原地排列给定数列 * @param A * @return */ public int[] randomizeInPlace(int[] A){ int n = A.length; for(int i = 0;i \u0026lt; n;i++){ exchange(A, i, rand(i, n - 1)); } return A; } }","href":"/blogs/two-ways-to-produce-a-uniform-random-permutation/","title":"产生均匀随机排列的两种方法"},{"content":"","href":"/tags/%E7%AE%97%E6%B3%95/","title":"算法"},{"content":" 问题描述 这是《算法导论》的习题5.1-3： \u0026gt; 假设你希望以各1/2的概率输出0和1。你可以自由使用一个输出0或1的过程BIASED-RANDOM。它以概率 p 输出1，以概率 1-p 输出0，其中 0 \u0026lt; p \u0026lt; 1，但是你并不知道 p 的值。给出一个利用BIASED-RANDOM作为子程序的算法，返回一个无偏向的结果。\n解决方案 分析 我们并不知道 p 的取值，但我们可以通过BIASED-RANDOM来重新构造一个过程，使之等概率的输出0和1。考虑连续两次调用BIASED-RANDOM得到的结果 P(ij)，将会得到如下结果： $$ P(00) = p^2 $$ $$ P(01) = (1 - p)p $$ $$ P(10) = p(1 - p) $$ $$ P(11) = (1 - p)^2 $$ 可以发现：P(01) = P(10)。利用产生 01 和 10 的概率相等这个性质就可以解决题目中的问题了。\njava代码 private int biasedRandom(){ Random random = new Random(); return random.nextInt(2); // 随机产生[0,1]内的整数  } public int rand(){ while(true){ int i = biasedRandom(), j = biasedRandom(); if(i == 1 \u0026amp;\u0026amp; j == 0){ return 1; } else if(i == 0 \u0026amp;\u0026amp; j == 1){ return 0; } else continue; } }","href":"/blogs/%E9%80%9A%E8%BF%8701%E6%9C%89%E5%81%8F%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%97%A0%E5%81%8F%E6%A6%82%E7%8E%87/","title":"通过偏概率0/1生成器，得到无偏概率0/1生成器"},{"content":"","href":"/tags/python/","title":"Python"},{"content":"","href":"/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"环境配置"},{"content":"  Anaconda 是一个 python 的发行版，可以用来管理 python 的包和环境，同时它包含1000+的开源package。正如那句话一样：\nThe Most Trusted Distribution for Data Science\n还有一个没有包含那么多包的 python 发行版，叫做Miniconda。\n 是用Anaconda Navigator还是conda Navigator 和 conda 都是可以用来管理包和环境。在安装完 Anaconda 之后，它们就都已经存在于系统之中了。区别是：\n Navigator 是图形界面 conda 是命令行界面  可以同时使用它们来进行管理。\n还是习惯使用conda 这里有一份conda cheat sheet。花点时间看看，就能开始使用 conda 了。\n.condarc 是 conda 的配置文件，它是可选的。当我们第一次运行 conda config 命令的时候, 这个文件就会被创建，通常位于：C:\\user\\username\\.condarc。可以通过直接修改它来配置 conda ，因为 conda config 命令的结果最终会写到 .condarc 中。\n配置源(channels) Anaconda 默认的源位于国外，在国内访问的速度不够快。可以采用国内的镜像来加快访问速度。我一般使用的是清华的源，运行以下命令：\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes 通过命令：\nconda info 可以查看当前的配置信息。如果添加成功，你会看到刚才所添加的链接。不过也可以直接查看 .condarc 这个文件，文件的内容目前大致是这个样子：\nchannels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ - defaults ssl_verify: true show_channel_urls: true 其中有一个字段是 defaults, 这使得所有默认的源都包含在当前的源里面，当然也可以删除它。\n我们也可以改变默认的源，修改defalut_channels 即可。\n让conda自动更新(auto_update_conda) conda 默认是自动更新的，每当用户在root环境更新或安装包的时候，就会触发。可以采用命令：\nconda config --set auto_update_conda false 来关闭自动更新。这时候 conda 就只会在用户运行手动更新的命令 conda update 的时候及进行更新了。\nAlway yes(always_yes) 每当我们执行安装包的命令的时候， conda 都会问我们Proceed ([y]/n)?。如果不想每次都回答这个问题，可以这么设置 always_yes :\nconda config --set always_yes true 目前我用到的配置部分大致就是这些。这里有一份关于使用 .condarc 的完整说明。\n","href":"/blogs/anaconda-source-configuration/","title":"配置Anaconda源"},{"content":" 矩阵乘法 矩阵相乘只有在第一个矩阵的列数（column）和第二个矩阵的行数（row）相同时才有定义。若 A 为 m x n 矩阵，B为 n x p 矩阵，则他们的乘积 C = AB 会是一个 m x p 矩阵。其乘积矩阵的元素如下面式子得出： $$C_{ij} = \\sum_{k = 1}^n A_{ik} B_{kj}$$\n解决方案 常规方法求解 根据矩阵相乘的定义，可以直接求解两个矩阵的乘积。但这种方法的时间复杂度为：$ O(n^3) $。java代码如下：\npublic int[][] matrixMultiply(int[][] A, int[][] B) { int rowc = A.length, colc = B[0].length, colab = A[0].length; int[][] C = new int[rowc][colc]; for (int i = 0; i \u0026lt; rowc; i++) { for (int j = 0; j \u0026lt; colc; j++) { for (int k = 0; k \u0026lt; colab; k++) { C[i][j] += A[i][k] * B[k][j]; } } } return C; } 分治法求解 使用分治法求解矩阵乘法实际上是利用了分块矩阵的性质。为了方便使用分治法，假定相乘的矩阵都是 n x n 的，其中 n 是2的幂。分治法将 n x n 的矩阵划分为4个 n/2 x n/2 的子矩阵，然后进行运算。假设矩阵 A 、 B 、 C 均满足上面的要求，那么它们可以进行如下表示： $$ A = \\begin{bmatrix}A_{11} \u0026amp; A_{12} \\\\ A_{21} \u0026amp; A_{22} \\\\ \\end{bmatrix}, B = \\begin{bmatrix}B_{11} \u0026amp; B_{12} \\\\ B_{21} \u0026amp; B_{22} \\\\ \\end{bmatrix}, C = \\begin{bmatrix}C_{11} \u0026amp; C_{12} \\\\ C_{21} \u0026amp; C_{22} \\\\ \\end{bmatrix} $$ 于是有： $$ A = \\begin{bmatrix}C_{11} \u0026amp; C_{12} \\\\ C_{21} \u0026amp; C_{22} \\\\ \\end{bmatrix} = \\begin{bmatrix}A_{11} \u0026amp; A_{12} \\\\ A_{21} \u0026amp; A_{22} \\\\ \\end{bmatrix} \\begin{bmatrix}B_{11} \u0026amp; B_{12} \\\\ B_{21} \u0026amp; B_{22} \\\\ \\end{bmatrix} $$ 也就是说： $$ C_{11} = A_{11}B_{11} + A_{12}B_{21} $$ $$ C_{12} = A_{11}B_{12} + A_{12}B_{22} $$ $$ C_{21} = A_{21}B_{11} + A_{22}B_{21} $$ $$ C_{22} = A_{21}B_{12} + A_{22}B_{22} $$ 《算法导论》上的伪代码如下： 书上的伪代码掩盖了一个非常重要的细节，那就是如何分解矩阵。如果真的创建出12个子矩阵，那将会花费O($ n^2 $)的时间来复制矩阵的元素。不过书上给出了一个十分关键的提示——用下标来指明一个子矩阵。如此一来，就可以避免对矩阵的复制操作，只需花费O(1)的时间。既然矩阵符合上面的要求，只需要改变矩阵的表示方式即可。添加子矩阵在原矩阵中的开始位置及子矩阵的大小就好了。\njava实现的代码如下：\n/** * @param ra A中行开始下标 * @param ca A中列开始下标 * @param n 子方阵宽度 */ private int[][] squareMatrixMultiply(int[][] A, int[][] B, int[][] C, int ra, int ca, int rb, int cb, int rc, int cc, int n) { if (n == 1) { C[rc][cc] = A[ra][ca] * B[rb][cb]; // 只有一个元素  } else if (n == 2) { // 都只有四个元素  C[rc][cc] += A[ra][ca] * B[rb][cb] + A[ra][ca + 1] * B[rb + 1][cb]; // C11 = A11 * B11 + A12 * B21  C[rc][cc + 1] += A[ra][ca] * B[rb][cb + 1] + A[ra][ca + 1] * B[rb + 1][cb + 1]; // C12 = A11 * B12 + A12 * B22  C[rc + 1][cc] += A[ra + 1][ca] * B[rb][cb] + A[ra + 1][ca + 1] * B[rb + 1][cb]; // C21 = A21 * B11 + A22 * B21  C[rc + 1][cc + 1] += A[ra + 1][ca] * B[rb][cb + 1] + A[ra + 1][ca + 1] * B[rb + 1][cb + 1]; // C22 = A21 * B12 + A22 * B22  } else { n /= 2; // 分解矩阵  squareMatrixMultiply(A, B, C, ra, ca, rb, cb, rc, cc, n); // A11 * B11  squareMatrixMultiply(A, B, C, ra, ca + n, rb + n, cb, rc, cc, n); // A12 * B21  squareMatrixMultiply(A, B, C, ra, ca, rb, cb + n, rc, cc + n, n); // A11 * B12  squareMatrixMultiply(A, B, C, ra, ca + n, rb + n, cb + n, rc, cc + n, n); // A12 * B22  squareMatrixMultiply(A, B, C, ra + n, ca, rb, cb, rc + n, cc, n); // A21 * B11  squareMatrixMultiply(A, B, C, ra + n, ca + n, rb + n, cb, rc + n, cc, n); // A22 * B21  squareMatrixMultiply(A, B, C, ra + n, ca, rb, cb + n, rc + n, cc + n, n); // A21 * B12  squareMatrixMultiply(A, B, C, ra + n, ca + n, rb + n, cb + n, rc + n, cc + n, n); // A22 * B22  } return C; } Strassen方法 Strassen方法不是很直观，它的核心思想是减少乘法的次数。分治法用了8次乘法，而Strassen方法只用了7次乘法，时间复杂度为$ O(n^{lg_7}) $。它的步骤如下：\n 先将矩阵A、B、C分解为 n/2 x n/2 的子矩阵，可以采用上面的下标计算方式，但我重新创建了子矩阵。 创建10个 n/2 x n/2 的矩阵$ S_1, S_2, \u0026hellip;, S_{10} $:  $$ S_1 = B_{12} - B_{22} $$ $$ S_2 = A_{11} + A_{12} $$ $$ S_3 = A_{21} + A_{22} $$ $$ S_4 = B_{21} - B_{11} $$ $$ S_5 = A_{11} + A_{22} $$ $$ S_6 = B_{11} + B_{22} $$ $$ S_7 = A_{12} - A_{22} $$ $$ S_8 = B_{21} + B_{22} $$ $$ S_9 = A_{11} - A_{21} $$ $$ S_{10} = B_{11} + B_{12} $$ 3. 递归的计算7次 n/2 x n/2 的矩阵乘法： $$ P_1 = A_{11}S_1 = A_{11}B_{12} - A_{11}B_{22} $$ $$ P_2 = B_{22}S_2 = A_{11}B_{22} + A_{12}B_{22} $$ $$ P_3 = B_{11}S_3 = A_{21}B_{11} + A_{22}B_{11} $$ $$ P_4 = A_{22}S_4 = A_{22}B_{21} - A_{22}B_{11} $$ $$ P_5 = S_5S_6 = A_{11}B_{11} + A_{11}B_{22} + A_{22}B_{11} + A_{22}B_{22} $$ $$ P_5 = S_5S_6 = A_{11}B_{11} + A_{11}B_{22} + A_{22}B_{11} + A_{22}B_{22} $$ $$ P_6 = S_7S_8 = A_{12}B_{21} + A_{12}B_{22} - A_{22}B_{21} - A_{22}B_{22} $$ $$ P_7 = S_9S_{10} = A_{11}B_{11} + A_{11}B_{12} - A_{21}B_{11} + A_{21}B_{12} $$ 4. 对$ P_i $ 执行加减法运算得到 C 的四个子矩阵： $$ C_{11} = P_5 + P_4 - P_2 + P_6 $$ $$ C_{12} = P_1 + P_2 $$ $$ C_{21} = P_3 + P_4 $$ $$ C_{22} = P_5 + P_1 - P_3 - P_7 $$ 由于我直接拆分了矩阵，因此这一步还需要合并四个子矩阵到 C 。\njava 代码如下：\nprivate int[][] squareMatrixMultiplyStrassen(int[][] A, int[][] B, int ra, int ca, int rb, int cb, int n) { int[][] C = new int[n][n]; if (n == 1) { C[0][0] = A[ra][ca] * B[rb][cb]; return C; } else { // step 1: 分解矩阵  n /= 2; // step 2: 创建10个矩阵  int[][] S1 = squareMatrixAddorSub(B, B, rb, cb + n, rb + n, cb + n, n, false); // S1 = B12 - B22  int[][] S2 = squareMatrixAddorSub(A, A, ra, ca, ra, ca + n, n, true); // S2 = A11 + A12  int[][] S3 = squareMatrixAddorSub(A, A, ra + n, ca, ra + n, ca + n, n, true); // S3 = A21 + A22  int[][] S4 = squareMatrixAddorSub(B, B, rb + n, cb, rb, cb, n, false); // S4 = B21 - B11  int[][] S5 = squareMatrixAddorSub(A, A, ra, ca, ra + n, ca + n, n, true); // S5 = A11 + A22  int[][] S6 = squareMatrixAddorSub(B, B, rb, cb, rb + n, cb + n, n, true); // S6 = B11 + B22  int[][] S7 = squareMatrixAddorSub(A, A, ra, ca + n, ra + n, ca + n, n, false); // S7 = A12 - A22  int[][] S8 = squareMatrixAddorSub(B, B, rb + n, cb, rb + n, cb + n, n, true); // S8 = B21 + B22  int[][] S9 = squareMatrixAddorSub(A, A, ra, ca, ra + n, ca, n, false); // S9 = A11 - A21  int[][] S10 = squareMatrixAddorSub(B, B, rb, cb, rb, cb + n, n, true); // S10 = B11 + B12  // Step 3: 计算7次乘法  int[][] P1 = squareMatrixMultiplyStrassen(A, S1, ra, ca, 0, 0, n); // P1 = A11 * S1  int[][] P2 = squareMatrixMultiplyStrassen(S2, B, 0, 0, rb + n, cb + n, n); // P2 = S2 * B22  int[][] P3 = squareMatrixMultiplyStrassen(S3, B, 0, 0, rb, cb, n); // P3 = S3 * B11  int[][] P4 = squareMatrixMultiplyStrassen(A, S4, ra + n, ca + n, 0, 0, n); // P4 = A22 * S4  int[][] P5 = squareMatrixMultiplyStrassen(S5, S6, 0, 0, 0, 0, n); // P5 = S5 * S6  int[][] P6 = squareMatrixMultiplyStrassen(S7, S8, 0, 0, 0, 0, n); // P6 = S7 * S8  int[][] P7 = squareMatrixMultiplyStrassen(S9, S10, 0, 0, 0, 0, n); // P7 = S9 * S10  // Step4: 根据P1-P7计算出C  int[][] T1 = squareMatrixAddorSub(P5, P4, 0, 0, 0, 0, n, true); // P5 + P4  int[][] T2 = squareMatrixAddorSub(P2, P6, 0, 0, 0, 0, n, false); // P2 - P6  int[][] C11 = squareMatrixAddorSub(T1, T2, 0, 0, 0, 0, n, false); // C11 = P5 + P4 - P2 + P6  int[][] C12 = squareMatrixAddorSub(P1, P2, 0, 0, 0, 0, n, true); // C12 = P1 + P2  int[][] C21 = squareMatrixAddorSub(P3, P4, 0, 0, 0, 0, n, true); // C21 = P3 + P4  int[][] T3 = squareMatrixAddorSub(P5, P1, 0, 0, 0, 0, n, true); // P5 + P1  int[][] T4 = squareMatrixAddorSub(P3, P7, 0, 0, 0, 0, n, true); // P3 + P7  int[][] C22 = squareMatrixAddorSub(T3, T4, 0, 0, 0, 0, n, false); // C22 = P5 + P1 - P3 - P7  // 合并C11、C12、C21、C22为C  for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { C[i][j] = C11[i][j]; } } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { C[i][j + n] = C12[i][j]; } } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { C[i + n][j] = C21[i][j]; } } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { C[i + n][j + n] = C22[i][j]; } } } return C; } 后记 当然，并不是所有的矩阵都是方阵， 也不是所有的方阵的元素个数的都是2的幂。为了让Strassen方法适用于一般的矩阵乘法，可以通过在原矩阵的行列补零得到上面要求的矩阵。在这之前，需要判断这个矩阵是不是上面的方阵，也就是判断方阵每行的元素个数是不是2的幂次方。\n一种简单的方法如下：\nprivate boolean isSquareMatrix(int[][] A) { int rowa = A.length, cola = A[0].length; if ((rowa == cola) \u0026amp;\u0026amp; ((rowa \u0026amp; (rowa - 1)) == 0)) return true; else return false; } 比如：8 \u0026amp; 7 = (1000 \u0026amp; 0111) = 0\n如果矩阵不是我们需要的方阵，那么在将其转换成理想形式的方阵之前， 还需要找到比矩阵每行和每列的元素个数都要大并且最接近的2的幂次方数，下面是一种可行的方法：\n// 获取比a大，最接近a的2的幂次方数  private int nextP2(int a){ int t = 1; while(t \u0026lt; a) t \u0026lt;\u0026lt;= 1; return t; } 准备工作都做好了，接下来就是将矩阵转化为我们理想的方阵了，方法很简单，直接将原来的矩阵复制进新的矩阵就行了：\nprivate int[][] convertMatrixToStandardSquareMatrix(int[][] A, int n){ int rowa = A.length, cola = A[0].length; int[][] C = new int[n][n]; for(int i = 0;i \u0026lt; rowa;i++){ for(int j = 0;j \u0026lt; cola;j++){ C[i][j] = A[i][j]; } } return C; } 如此以来，Strassen方法所需要的条件都有了，但这么计算出来的结果中会出现很多很多的0。这看起来是很不舒服的，于是，可以先保存原来矩阵的行数和列数，然后去掉多余的0，得到常规方法计算矩阵乘法的结果。\n// 处理不是2的指数次幂的矩阵变成方阵后运算多出来的那一大堆0  private int[][] removeZerosInMatrix(int[][] A, int rowa, int cola){ int[][] C = new int[rowa][cola]; for(int i = 0;i \u0026lt; rowa;i++){ for(int j = 0;j \u0026lt; cola;j++){ C[i][j] = A[i][j]; } } return C; }  ","href":"/blogs/matrix-multiplication/","title":"矩阵乘法"},{"content":" 问题  有一个数组A，寻找一个 A[] 的子数组 B[] ， 使得B的元素和大于A的任何一个子数组。比如A = [13, -3, 25, 20, -4, -20, -25, 18, 20, -5, 16, -5, -22, 18, -6, 8], 我们要求的 B[] 就是：[18, 20, -5, 16], 它的和大于 A[] 的任何一个子数组。\n 解决方案 暴力法求解 最简单也最直接的解题方式就是暴力法（Brute force）。用暴力法直接穷尽 A[] 的所有子数组， 然后选择其中最大的那个作为 B[] 就可以了。使用暴力法的时间复杂度为 \\( O(n^2) \\) 。 java代码如下:\npublic int[] findMaxSubarray(int left, int right, int[] data){ int i, j, maxLeft = left, maxRight = left, sum = Integer.MIN_VALUE, tempSum; for(i = left;i \u0026lt;= right;i++){ tempSum = 0; // data[i..j]的和  for(j = i;j \u0026lt;= right;j++){ tempSum += data[j]; if(tempSum \u0026gt; sum){ sum = tempSum; maxLeft = i; maxRight = j; } } } return Arrays.copyOfRange(data, maxLeft, maxRight + 1); } 虽然暴力法能够得到我们想要的结果，但是因为暴力法的解空间巨大，因此只适用于数量不大的场合。下面采取的是一种较为高效的方法——分治法。\n分治法求解 假如我们要求的是 A[left, right] 这个数组的最大子数组。分治法的思想是：divide -\u0026gt; conquer -\u0026gt; combine , 就是说：先把大问题分解成一系列的小问题，然后求解小问题，最后把小问题的解合并起来得到大问题的解。当然，有一个前提就是：大问题的解的确是有这些小问题构成的。 对于任何一个长度大于2的数组 A[left, right] ， 我们总能把它分解为两个子数组： A[left, mid] 和 A[mid + 1, right] 。假设我们要求的是 B[] = A[i, j] ,如此一来， A[i, j] 只有三种可能：\n 完全位于 A[] 的左半部分，即： left \u0026lt;= i \u0026lt;= j \u0026lt;= mid ; 完全位于 A[] 的右半部分，即： mid + 1 \u0026lt;= i \u0026lt;= j \u0026lt;= right ; 同时位于左右两部分， 即： left \u0026lt;= i \u0026lt;= j \u0026lt;= right ;  对于前两种情况，可以直接递归求解。对于第三种情况，我们就要采用其它的方式了。对于越过中点的第三种情况， A[i, j] 可以拆分为 A[i, mid] 和 A[mid + 1, j] 。 由于中点包含在结果之内，所以可以这么做：\n 对于左半部分， 从 A[mid] 开始， 向 A[left] 靠近， 寻找 A[i, mid] ; 对于右半部分， 从 A[mid + 1] 开始， 向 A[right] 靠近， 寻找 A[mid + 1, j] ;  使用分治法的时间复杂度为：O(nlogn).\njava实现的代码如下：\npublic int[] findMaxCrossingArray(int left, int mid, int right, int[] data){ int maxLeftSum = Integer.MIN_VALUE; int sum = 0; int i, j, maxLeft = mid, maxRight = mid + 1; for(i = mid;i \u0026gt;= left;i--){ // [left, mid]的maxSum  sum += data[i]; if(sum \u0026gt; maxLeftSum){ maxLeftSum = sum; maxLeft = i; } } sum = 0; int maxRightSum = Integer.MIN_VALUE; for(j = mid + 1;j \u0026lt;= right;j++){ // [mid + 1, right] 的maxSum  sum += data[j]; if(sum \u0026gt; maxRightSum){ maxRightSum = sum; maxRight = j; } } return Arrays.copyOfRange(data, maxLeft, maxRight + 1); // 得到A[i, j]  } 然后下面是递归求解原问题的代码：\npublic int[] findMaxSubarray(int left, int right, int[] data){ // 寻找最大子数组  if(left == right) return data; else{ int mid = (left + right) / 2; int[] maxLeftArray = findMaxSubarray(left, mid, data); int[] maxRightArray = findMaxSubarray(mid + 1, right, data); int[] maxCrossingArray = findMaxCrossingArray(left, mid, right, data); int sumLeft = sumArray(0, maxLeftArray.length - 1, maxLeftArray); int sumRight = sumArray(0, maxRightArray.length - 1, maxRightArray); int sumCrossing = sumArray(0, maxCrossingArray.length - 1, maxCrossingArray); if(sumLeft \u0026gt;= sumRight \u0026amp;\u0026amp; sumLeft \u0026gt;= sumCrossing) return maxLeftArray; else if(sumRight \u0026gt;= sumLeft \u0026amp;\u0026amp; sumRight \u0026gt;= sumCrossing) return maxRightArray; else return maxCrossingArray; } } 动态规划求解 《算法导论》在习题中讲到：\n Use the following ideas to develop a nonrecursive, linear-time algorithm for the maximum-subarray problem. Start at the left end of the array, and progress toward the right, keeping track of the maximum subarray seen so far. Knowing a maximum subarray of A[1..j], extend the answer to find a maximum subarray ending at index j + 1 by using the following observation: a maximum subarray of A[1..j + 1] is either a maximum subarray of A[1..j] or a subarray A[i..j + 1], for some 1 \u0026lt;= i \u0026lt;= j + 1. Determine a maximum subarray of the form A[i..j + 1] in constant time based on knowing a maximum subarray ending at index j .\n 用中文来说就是：\n 若已知A[1\u0026hellip;j]的最大子数组，基于如下性质可以得到 A[1..j + 1] 的最大子数组: A[1..j + 1] 的最大子数组要么是 A[1..j] 的最大子数组，要么是某个子数组 A[i..j + 1] (1 =\u0026lt; i \u0026lt;= j + 1) 。这个算法是线性时间O(n)。\n 因此，需要记录 A[1..j] 的最大子数组。于是我们可以这么想：如果前面的若干和小于0， 这对结果没有任何的帮助，应该丢弃，重新开始计算并更新位置标记；否则，向后延伸。 java代码如下：\npublic int[] findMaxSubarray(int left, int right, int[] data){ int maxLeft = left, maxRight = left, sum = Integer.MIN_VALUE, temp = left; int[] tempSum = new int[right - left + 1]; tempSum[0] = data[left]; for(int i = left + 1;i \u0026lt;= right;i++){ if(tempSum[i - left - 1] \u0026lt; 0){ // 前面的最大和小于0，直接丢弃, 从下一个开始考虑  tempSum[i] = data[i]; temp = i; } else{ // 向后延伸  tempSum[i - left] = tempSum[i - left - 1] + data[i]; } if(tempSum[i - left] \u0026gt; sum){ sum = tempSum[i - left]; maxRight = i; maxLeft = temp; } } return Arrays.copyOfRange(data, maxLeft, maxRight + 1); }","href":"/blogs/maximum-sub-array-problem/","title":"最大子数组问题"},{"content":"","href":"/categories/c%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"《C算法》学习笔记"},{"content":"  键索引搜索方法中，表中的第 i 个位置保存了键为 i 对应的项，以便达到快速访问的目的。它将键作为数组的索引，并且依赖于同一范围内不同整数的键作为表的索引。这种方法不适用于更一般的键。哈希方法扩展了键索引搜索，它通过算术运算把键转换为表地址，以达到快速访问的目的。\n 使用哈希的搜索算法包括两个部分：\n 哈希函数：将键转化为表地址 冲突调节：解决映射到同一表地址之间的键的冲突  哈希函数 如果我们有一个长度为 M 的表，哈希函数要做的就是把键转换为 [0, M-1] 之间的整数。\n取模哈希函数 一种常用的方法就是选择一个素数 M 做为表长，然后： h(x) = k mod M 。其中 k 为键所对应的整数。 对于整数键，还可以采用乘法取模法：h(x) = [k * α] mod M 。 α 常设为黄金比（0.618033\u0026hellip;）。\n冲突调节 链地址法 为每个散列地址建一个链表，将散列到同一个地址的关键字放入相应的链表中。适合难以预测填入散列表的元素个数并且内存不是太充足的情况。\n线性探测法 如果能够预测填入散列表的元素个数并且内存充足，那么可以使用线性探测法。 当产生冲突时，检查表中的下一个位置，直到找到一个空的位置，然后将项放进去。 线性探测法一次探测可以辨别三种可能的结果：\n 如果表位置包含一个与搜索键匹配的项，则命中； 如果表位置为空，则搜索失败； 如果表位置包含一个与搜索键不匹配的项，则继续探测更高地址直到出现以上两种情况。  再哈希法 再哈希法的基本策略和线性探测法一致。不同的是，他不检查冲突之后的每一个位置，而是使用第二个散列函数得到用于探测序列的固定增量。\n总结  线性探测法是罪最快的（前提：内存足够大，保证哈希表是稀疏的） 再哈希法对内存的使用效率最高，但是需要额外的时间来计算第二个哈希函数 链地址法最易实现和部署  ","href":"/blogs/hashing-table/","title":"哈希表"},{"content":" 树是满足一定要求的顶点和边的非空集合。\n二叉树 二叉树的每个节点至多有2个子节点。 一种表示方法：\nstruct Node{type key; Node *lchild, *richild;} typedef Node *link;  这种表示方法只适合从根节点开始自顶向下的操作，而不适合自底向上的操作。不过可以在节点的定义中加入指向父节点的连接支持这种功能。 与二叉树类似的还有M叉树，它的每个节点最多只有M个节点。广义的树每个节点可以有任意多个子节点，可以用二叉树来表示它们，方法就是——“左孩子，右兄弟”。树的序列就形成了有序森林。 \u0026gt; 二叉树和有序森林之间存在一一的对应关系。\n二叉树的一些数学性质  一棵二叉树有 N 个内部节点，有 N + 1 个外部节点（叶子节点）。 包含 N 个内部节点的二叉树有 2N 个链接： N - 1 个外部节点的链接和 N + 1 个内部节点的链接。 树中节点的所在的层是它的父节点的下一层（根节点位于第 0 层）。树的高度为树节点的最大层。树的路径长度为所有树节点的层总和：外部路径长度为所有外部节点的层总和，内部路径长度为所有内部节点的层总和。 这里有一个计算树路径长度的简便方法：对于所有的 k , 求 k 与 k 层节点数之积的总和。 具有 N 个内部节点的二叉树的外部路径长度比内部路径长度大 2N 。 具有 N 个内部节点的二叉树的高度的最小值为 lgN ，最大值为 N - 1 。 当树退化成只有一个叶子节点的时候，就是最坏的情况。 具有 N 个内部节点的二叉树内部路径长度最小值为 Nlg(N/4) ，最大值为 N(N - 1)/2 。  树的遍历  前序遍历 根-\u0026gt;左孩子-\u0026gt;右孩子 中序遍历 左孩子-\u0026gt;根-\u0026gt;右孩子 后序遍历 左孩子-\u0026gt;右孩子-\u0026gt;根 层次遍历 从上到下，从左到右  前序遍历（递归版）：\nvoid preorderTraverse(link h, void visit(link)){ if(h == root) return; visit(h); preorderTraverse(h -\u0026gt; lchild, visit); preorderTraverse(h -\u0026gt; rchild, visit); }  前序遍历（非递归版）：\nvoid preorderTraverse(link h, void visit(link)){ stack\u0026lt;link\u0026gt; stk(maxn); s.push(h); while(!s.empty()){ visit(s.top()); s.pop(); if(h -\u0026gt; lchild != null) s.push(h -\u0026gt; lchild); if(h -\u0026gt; rchild != null) s.push(h -\u0026gt; rchild); } }  后序遍历和中序遍历只需要交换前序遍历中访问节点的顺序即可。 层次遍历：\nvoid levelTraverse(link h, void visit(link)){ queue\u0026lt;link\u0026gt; q(maxn); q.push(h); while(!q.empty()){ visit(q.front()); q.pop(); if(h -\u0026gt; lchild != null) q.push(q -\u0026gt; lchild); if(h -\u0026gt; rchild != null) q.push(q -\u0026gt; rchild); } }  计算树含有的节点数：\nint count(link h){ if(h == null) return 0; return count(h -\u0026gt; lchild) + count(h -\u0026gt; rchild) + 1; }  计算树的高度：\nint height(link h){ if(h == null) return -1; return max(height(h -\u0026gt; lchild), height(h -\u0026gt; rchild)) + 1; }  二叉搜索树 二叉树搜索树是一棵二叉树，它要么是一棵空树，要么具有以下性质：\n 若任意节点的左子树不为空，则左子树上所有节点的值不大于它的根节点的值 若任意节点的右子树不为空，则右子树上所有节点的值不小于它的根节点的值 任意节点的左右子树都是二叉搜索树 树中没有键值相等的节点  二叉搜索树中的查找 在二叉搜索树h中查找v的过程如下：\n 若h是空树，则返回查找失败，否则： 若x为根节点对应的数据值，则查找成功，否则： 若x小于根节点对应的数据值，则查找左子树，否则： 查找右子树\nItem searchP(link h, type v){ if(h == 0) return nullItem; type t = h -\u0026gt; item.getKey(); if(t == v) return h -\u0026gt; item; if(v \u0026lt; t) searchP(h -\u0026gt; lchild, v); else searchP(h -\u0026gt; rchild, v); }   在二叉搜索树中插入节点 在二叉搜索树h中插入节点v的过程如下，其中插入的节点总是叶子节点：\n 若h是空树，则将v所指的节点作为根节点插入，否则： 若v对应的数据值小于根节点对应的数据值，则在左子树中插入，否则： 在右子树中插入\nvoid insertP(link \u0026amp;h, Item x){ if(h == 0) {h = new Node(x);return;} if(x.getKey() \u0026lt; h -\u0026gt; item.getKey()) insertP(h -\u0026gt; lchild, x); else insertP(h -\u0026gt; rchild, x); }   上面的插入只适用于插入的节点最终是叶子节点的情况，可以通过这种方式来构造一棵树来对数据进行排序。对于插入的节点不一定到达叶子节点的情况，需要考虑其它的插入方法。旋转是树的一种基本变换，它允许交换树中根及其一个孩子的角色，同时保持节点中键的次序。 涉及到3个链接和两个节点。\n 右旋（左孩子为轴，当前节点右旋）。结果就是：原来的左孩子成为了新的根，原来左孩子的左孩子依旧是新根的左孩子，旧根的右孩子依旧是旧根的右孩子。旧根成为了新根的右孩子，原来左孩子的右孩子成为了旧根（新根的右孩子）的左孩子。\n void rotateR(link \u0026amp;h){ link t = h -\u0026gt; lchild; h -\u0026gt; lchild = t -\u0026gt; rchild; t -\u0026gt; rchild = h; h = t; }   左旋和右旋相反。右孩子为轴，当前节点左旋。原来的右孩子成为了新的根，旧根成为了新根的左孩子。原来的右孩子的左孩子成为了旧根的右孩子。\n void rotateL(link \u0026amp;h){ link t = h -\u0026gt; rchild; h -\u0026gt; rchild = h -\u0026gt; lchild; t -\u0026gt; lchild = h; h = t; }  有了左旋和右旋之后，就能迅速得到在BST的根插入新节点的递归函数，再适当子树的根插入新项，然后通过旋转将它带到主树的根。\nvoid insertT(link \u0026amp;h, Item x){ if(h == 0){h = new Node(x);return;} if(x.getKey() \u0026lt; h -\u0026gt; item.getkey()){insertT(h -\u0026gt; lchild, x); rotateR(h);} else{insertT(h -\u0026gt; rchild,x); rotateL(h);} }  在二叉搜索树中选择节点 可以采用快速排序划分的思想来选择BST中第 k 小的节点。不过这需要给结点增加一个计数域，然后还需要修改其他所有的函数。\nItem selectR(link h, int k){ if(h == 0) return nullItem; int c = (h -\u0026gt; lchild == 0) ? 0 : h -\u0026gt; lchild -\u0026gt; cnt; if(c \u0026gt; k) return selectR(h -\u0026gt; lchild, k); if(c \u0026lt; k) return selectR(h -\u0026gt; rchild, k - c - 1); return h -\u0026gt; item; }  对二叉搜索树进行划分 可以将选择运算修改为划分运算，它重排树，利用左旋和右旋将第 k 小的元素放到根。\nlink partition(link \u0026amp;h, int k){ int c = (h -\u0026gt; lchild == 0) ? 0 : h -\u0026gt; lchild -\u0026gt; cnt; if(c \u0026gt; k) {partition(h -\u0026gt; lchild, k); rotateR(h);} if(c \u0026lt; k) {partition(h -\u0026gt; rchild, k - c - 1); rotateL(h);} }  在二叉搜索树中删除节点 从BST删除一个节点，首先检查该节点是否在其中一棵子树中。如果是则用递归删除节点后的结果替换子树。如果删除的节点在根部，则需要用合并两棵子树的结果替换原来的树。\nlink joinLR(link l, link r){ if(r == 0) return l; partition(r, 0); r -\u0026gt; lchild = l; return r; } void removeR(link \u0026amp;h, type v){ if(h == 0) return; type w = h -\u0026gt; item.getKey(); if(v \u0026lt; w) removeR(h -\u0026gt; lchild, v); if(v \u0026gt; w) removeR(h -\u0026gt; rchild, v); if(v == w){ link t = h; h = joinLR(h -\u0026gt; lchild, h -\u0026gt; rchild); delete t; } }  合并两棵二叉搜索树 书中的一个线性时间的递归实现：首先，利用根插入将第一课BST的根插入到第二棵BST中。这会得到两棵键小于根的子树和两棵键大于根的子树。然后递归的合并根左子树的前一对与根右子树的后一对来得到结果。\nlink joinAB(link a, link b){ if(a == 0) return b; if(b == 0) return a; insertT(b, a -\u0026gt; item); b -\u0026gt; lchild = jionAB(a -\u0026gt; lchild, b -\u0026gt; lchild); b -\u0026gt; rchild = jionAB(a -\u0026gt; rchild, b -\u0026gt; rchild); delete a; return b; }  2-3-4树 2-3-4树可以在O(logN)的时间内完成查找、插入、和删除操作。\n2-3-4树是一棵空树或者是具有以下三类节点的树：\n 2-节点 它具有一个键，以及具有较小键的左子树和具有较大键的右子树的两个链接。 3-节点 它具有两个键，以及具有较小键的左子树，较大键的右子树和介于节点键之间的中间子树的三个链接。 4-节点 它具有三个键，以及由节点键对应的区间定义的键值的树的四个链接。  节点的插入处理  如果搜索结束的节点是2-节点，将其变为3-节点。 如果搜索结束的节点是3-节点，将其变为4-节点。 如果搜索结束的节点是4-节点，将其分裂成两个2-节点，并将中间键上移到节点的父亲（父节点不是4-节点）。但如果父节点也是4-节点呢？更好的一个方法是：在沿树向下的过程中，分解任何4-节点，保证搜索路径不在4-节点终止。具体做法是：每当遇到一个2-节点（父亲）连接到4-节点（孩子），就把它转化为一个3-节点连接到连个2节点；每当遇到一个3-节点连接到4-节点，就把它转换为一个4-节点连接到两个2-节点。  红黑树 2-3-4树易于理解，但实现困难。 红黑树是2-3-4树的一种简单抽象表达方式。其基本思想是将2-3-4树表示为标准的BST(仅有2-节点)，但为每个节点添加一个额外的信息位，来为3-节点和4-节点编码。\n链接有两种不同的类型：\n 红链接 红链接将包含3-节点和4-节点的小二叉树捆绑在一起。 黑链接 黑链接将2-3-4树捆绑在一起。  红黑树有两个本质特性：\n 不用修改BST的标准搜索过程就能工作。 它们与2-3-4树直接对应。因此可以用上2-3-4树的简单插入平衡过程。  如果某个节点有2个红孩子，则它是4-节点的一部分。红黑树的插入开销很小：仅当看到4-节点的时候才采取平衡措施。分解不同4-节点的具体做法可以对照下图来说：  左一：4-节点的父亲是一个2-节点。 将中间键上移转换为一个3-节点与两个2-节点的连接（变色）。 左二：4-节点的父亲是一个3-节点，并且是它的右孩子。 变色。 左三：4-节点的父亲是一个3-节点，并且是它的左孩子。 先变色得到两个方向相同的红链接，然后右旋。 左四：4-节点的父亲是一个3-节点，并且是它的中间孩子。 先变色得到两个方向不同的红链接，然后右旋得到两个方向相同的红链接，然后再左旋。  用红黑树表示法实现2-3-4树的插入操作，首先要给修改节点定义，加入颜色位（用 1 表示红节点， 0 表示黑节点）。在沿树向下的路径中（递归调用之前），检查4-节点，并通过切换所有3-节点的颜色位来分裂它们。当到达底部时，为被插入的项新建一个红节点并返回它的指针。在沿向上的路径中（递归调用之后），检查是否需要执行一次旋转操作：如果路径上有两个相同方向的红链接，则从上方节点进行一次旋转，然后切换颜色位，以形成一个正确的4-节点；如果路径上有两个方向不同的红链接，则从下方的节点执行一次旋转，以简化为另一种情况，留作向上的下一步处理。\nint getColor(link x){if(x == 0) return 0; return x -\u0026gt; color;} void insertRB(link \u0026amp;h, Item x, int sw){ if(h == 0){h = new Node(x); return;} if(getColor(h -\u0026gt; lchild) \u0026amp;\u0026amp; getColor(h -\u0026gt; rchild)){ // 变色, 分裂4-节点为3-节点  h -\u0026gt; color = 1; h -\u0026gt; lchild -\u0026gt; color = 0; h -\u0026gt; rchild -\u0026gt; color = 0; } if(x.getKey() \u0026lt; h -\u0026gt; item.getKey()){ // 向左子树插入  insertRB(h -\u0026gt; lchild, x, 0); if(getColor(h) \u0026amp;\u0026amp; getColor(h -\u0026gt; lchild) \u0026amp;\u0026amp; sw) // 两个方向相同的红链接  rotateR(h); if(getColor(h -\u0026gt; lchild) \u0026amp;\u0026amp; getColor(h -\u0026gt; lchild -\u0026gt; lchild)){ rotateR(h); h -\u0026gt; color = 0; h -\u0026gt; rchild -\u0026gt; colot = 1; } } else{ // 向右子树插入  inserRB(h -\u0026gt; rchild, x, 1); if(getColor(h) \u0026amp;\u0026amp; getColor(h -\u0026gt; rchild) \u0026amp;\u0026amp; !sw) // 左旋  rotateL(h); if(getColor(h -\u0026gt; rchild) \u0026amp;\u0026amp; getColor(h -\u0026gt; rchild -\u0026gt; rchild)){ rotateL(h); h -\u0026gt; color = 0; h -\u0026gt; lchild -\u0026gt; color = 1; } } }  红黑树的结构性定义：\n红黑树是每个节点都带有颜色的BST，颜色为红色或黑色。除了BST的基本要求外，它还必须满足以下要求：\n 节点要么是红色，要么是黑色 根节点是黑色 所有叶子节点都是黑色 每个红节点必须有两个黑色的子节点（也就是说：不能有两个连续的红链接）。 从任一节点到其每个叶子节点的所有简单路径都包含相同数目的黑节点。  ","href":"/blogs/binary-tree/","title":"树"},{"content":"  学习《C算法》中排序这一部分时做的一些笔记。主要使用C++实现了书中的大部分排序算法。\n 开始之前 为了方便增加代码的灵活性，我采取了书中作者的部分方法。主要是用 type 代替了具体的数据类型，以及定义了两个用于比较的宏。通过改变下面内容， 可以很容易的进行其它数据类型的排序。\ntypedef int type; #define less(A, B) (A \u0026lt; B) #define equal(A, B) (A == B)  下面的 exchange() 函数用来交换两个元素：\nvoid exchange(type \u0026amp;a, type \u0026amp;b){type t = a; a = b; b = t;}  还有用来测试算法正确性的驱动函数，它通过读取用户输入的数字 n , 产生 n 个10000以内的随机数作为测试数据。然后调用相应的排序算法并输出排序结果。\nint main(){ int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); type *a = new type[n]; for(int i = 0;i \u0026lt; n;i++) a[i] = 10000 * (1.0 * rand() / RAND_MAX); //selectSort(a, 0, n - 1);  //insertSort1(a, 0, n - 1);  //insertSort2(a, 0, n - 1);  //bubbleSort(a, 0, n - 1);  //shakerSort(a, 0, n - 1);  //shellSort(a, 0, n - 1);  //countSort(a, 0, n - 1);  //quickSort(a, 0, n - 1);  //tri_quickSort(a, 0, n - 1);  //mergeSort(a, 0, n - 1);  //mergeTD(a, 0, n - 1);  //oddEvenSort(a, 0, n - 1);  //heapSort(a, 0, n - 1);  //radixSort(a, 0, n - 1);  for(int i = 0;i \u0026lt; n;i++) printf(\u0026#34;%-6d\u0026#34;, a[i]); printf(\u0026#34;\\n\u0026#34;); delete []a; system(\u0026#34;pause\u0026#34;); return 0; }  选择排序 步骤  首先，找出数组中最小的元素并用首位置的元素和它交换 然后， 找出数组中次小的元素并用第二个位置的元素和它交换 重复此步骤，直到整个数组排序完成。  具体实现 对于从 left 到 right - 1 的每个 i ,用 a[i], a[i + 1], \u0026hellip;, a[right] 中的最小元素进行交换。当索引 i 从左向右遍历时，其左边的元素所处的位置就是其在数组中的最终位置。 所以，当 i 到达最右端时，整个数组排序完成。\nvoid selectSort(type a[], int left, int right){ for(int i = left;i \u0026lt; right;i++){ int minp = i; // 假定未排序序列中的第一个为最小值  for(int j = i + 1;j \u0026lt;= right;j++) if(less(a[j], a[minp])) minp = j; exchange(a[i], a[minp]); } }  插入排序 步骤 对于未排序的序列，每次取其中的一个数。然后在已排序的序列中从后向前扫描， 找到合适的位置并插入。\n说明 和选择排序一样，在排序过程中，当前索引左边的元素已经有序，但这并不是他们的最终位置，如果碰到了比它们更小的元素，它们还必须后移，为较小的元素腾出位置。\nvoid insertSort1(type a[], int left, int right){ for(int i = left + 1;i \u0026lt;= right;i++) for(int j = i;j \u0026gt; left;j--) if(less(a[j], a[j - 1])) exchange(a[j], a[j - 1]); }  改进  与选择排序不同的时，插入排序的运行时间主要取决于输入中键的初始顺序。 当我们碰到的键不大于正被插入的键时，就可以停止 less() 和 exchange() 运算，因为左边的序列时已经排序好的了。特别地，当 less(a[j - 1], a[j]) 为真时，我们可以直接跳出内层循环。 不难发现，j \u0026gt; left 的测试通常是多余的（只有在插入元素时当前看到的最小元素并且到达了数组的起始处，它才为真）。一种改进方法是：让键在 a[left] 到 a[N] 中保持有序，并在 a[0] 中放入一个标记键，它至少与数组中的最小键相同。然后通过测试是否碰到了最小键来同时测试 less(a[j - 1], a[j]) 和 j \u0026gt; left 这两个条件，让内循环更小，程序更快。 对同一个元素的连续交换效率不高，如果进行两次或者更多的交换，中间变量 t 的值并没有改变。在第二次或以后的交换中，先保存再重新载入 t 的值就是浪费时间。\n 具体做法  将数组中最小值放到第一个位置，作为标记。 在内循环中，进行单个赋值，而不是连续交换。 当正被插入的元素已经就位时，终止内循环。对于每个 i ，把大于 a[i] 的排序表 a[left], ..., a[i - 1] 的所有元素整体向右移动一个位置，再把 a[i] 放入适当的位置。这样就完成了整个排序的过程。\nvoid insertSort2(type a[], int left, int right){ for(int i = left + 1, minp = left;i \u0026lt;= right;i++){ if(less(a[i], a[left])) minp = i; exchange(a[minp], a[left]); } for(int i = left + 2;i \u0026lt;= right;i++){ int j = i; type v = a[i]; // 先保存a[i]，确保它不会被右移的元素覆盖  //把大于a[i]的所有元素整体向右移动一个位置  for(;less(v, a[j - 1]);j--) a[j] = a[j - 1]; a[j] = v; // 放入a[i]到适当的位置 } }   冒泡排序 步骤  从左到右比较相邻的两个元素，如果第一个比第二个大，就交换它们 对每一对元素重复第1步，结束时，最大的元素在排序序列的最右端。 对除最后一个以外的所有元素重复以上步骤。 重复直到没有任何一对数字需要比较。  代码如下：\nvoid bubbleSort(type a[], int left, int right){ for(int i = left;i \u0026lt;= right;i++){ for(int j = left;j \u0026lt;= right - i - 1;j++) if(less(a[j + 1], a[j])) exchange(a[j + 1], a[j]); } }  摇摆排序 冒泡排序改良版。将单向扫描数组改成从头到尾，再从尾到头的交替方式\nvoid shakerSort(type a[], int left, int right){ for(int i = left;i \u0026lt;= right;i++){ for(int j = left;j \u0026lt;= right - i - 1;j++) if(less(a[j + 1], a[j])) exchange(a[j + 1], a[j]); for(int j = right - i - 1;j \u0026gt; i;j--) if(less(a[j], a[j - 1])) exchange(a[j], a[j - 1]); } }  希尔排序 希尔排序又叫缩小增量排序，它是插入排序扩展。 \u0026gt; 插入排序慢， 因为它一次只交换相邻的两个元素（步长为1）。如果最小键位于数组尾部，则将它移动到正确位置需要N步。 为了让元素能够能快的到达正确的位置，改变步长。每隔h取一个元素，可以得到一些h-有序序列。然后改变步长继续操作，最终当步长为1的时候，希尔排序变成插入排序，这就保证了排序能够完成。\n如果不使用标记，则在插入排序中，将步长由“1”换成“h”(也就是将每个“1”换成“h”)，得到的程序对序列进行h-排序。增加一个外循环来改变增量h，就可以得到最终程序。程序中选取的增量序列为：1，4，13，40，121，364，1093，3280，9841……\nvoid shellSort(type a[], int left, int right){ int h, i, j; for(h = 1;h \u0026lt; (right - left) / 3;h = h * 3 + 1); for(;h \u0026gt; 0;h /= 3){ // 调整增量  for(i = left + h;i \u0026lt;= right;i += h){ j = i; type v = a[i]; // 保存a[i]  for(;j \u0026gt;= left + h \u0026amp;\u0026amp; less(v, a[j - h]);j -= h) a[j] = a[j - h]; // 向后移动h个元素  a[j] = v; // 把a[i]放到正确位置  } } }  键索引计数排序 键索引排序把键当作索引进行排序，而不是把键当作被比较的抽象项。比如：排序一个包含N个项的文件，项的键为0~M-1之间的整数。我们可以用每个值来对键的个数进行计数，然后在第二遍扫描中使用计算出来的数将项移到正确的位置。通俗的讲：加入你们班有30个人，统计出来有5个人的绩点比你高，那么你的绩点就排在第6位。用这个方法可以得到其它人的排名，也就排好了序。对于重复值，需要特殊处理。 不过键索引基数排序局限于待排序数据的范围。\n步骤  首先，计数每个值的键的数量 然后，小计小于或等于每个值的键数。 接着，使用这些计数作为索引分拣键，比如 cnt[i] 表示小于 i 的个数，那个 a[i] 位于 aux[ant[i]] 写回原数组  代码如下：\nvoid countSort(type a[], int left, int right){ int i, j, M = 10000; // 键必须是小于M的整数  int N = right - left + 1, cnt[M]; type *aux = new type[N]; for(j = 0;j \u0026lt; M;j++) cnt[j] = 0; // 将计数初始化为0  for(i = left;i \u0026lt;= right;i++) cnt[a[i] + 1]++; //统计小于a[i]的值的出现频率  for(j = left;j \u0026lt; M;j++) cnt[j + 1] += cnt[j]; // 得到小于等于计数器对应计数值键的数量,将频率转换为索引  for(i = left;i \u0026lt;= right;i++) aux[cnt[a[i]]++] = a[i]; // 将键分布到辅助数组中  for(i = left;i \u0026lt;= right;i++) a[i] = aux[i]; // 回写  delete []aux; }  快速排序 快速排序是一种分治方法。它的工作方式是：将待排序的序列划分为两组，然后独立排序各个部分划分的准确位置取决于输入中元素的初始顺序。 方法的关键在于划分过程，它将数组重排，使下面3个条件成立：\n 对于某一个 i 值，元素 a[i] 处于数组中的最终位置; a[i] 左边的元素都不大于 a[i] ; a[i] 右边的元素都不小于 a[i] ;  划分方法  首先，任意选定 a[right] 作为划分元素（它将处于在数组中的最终位置）。 从左向右扫描，直到发现一个大于划分元素的元素；同时从右向左扫描，直到发现一个小于划分元素的元素，然后交换这两个元素。 按这种方式继续划分。确保左指针左边的元素都小于划分元素，右指针右边的元素都大于划分元素。 当左右指针相遇或者相互经过时，交换 a[right] 和右半部分最左边的元素（由左指针指向的元素），划分结束。\nint partition(type a[], int left, int right){ int i = left - 1, j = right; type v = a[right]; // a[right]为划分元素 for(;;){ for(;less(a[++i], v);); for(;less(v, a[--j]);) if(j == left) break; // 避免划分元素为序列中的最小元素的情况发生  if(j \u0026lt;= i) break; exchange(a[i], a[j]); } exchange(a[i], a[right]); //交换a[right]和a[i] return i; }   如果数组中只有一个元素，不需要进行任何运算。否则，调用 partition() 函数处理这个数组，它将 a[i] 放到最终位置 (left \u0026lt; i \u0026lt;= right) 并且重排其它元素，让递归调用能够正确完成整个排序过程。\nvoid quickSort(type a[], int left, int right){ if(right \u0026lt;= left) return; int i = partition(a, left, right); quickSort(a, left, i - 1); quickSort(a, i + 1, right); }  改进（三元素中值划分） 三元素中值划分使用一个更有可能在中间位置出现的元素作为划分元素。它从序列中选出三个元素的样本，然后用这三个元素的中值作为划分元素。分别从数组中的左、中、右选取一个元素。接着排序这三个元素，然后用 a[right - left] 交换中间那一个，再对 a[left + 1],...,a[right - 2] 运行划分算法。\n应对大量重复键的情况\u0026mdash;三路划分  当排序序列中的重复键较多的时候，快速排序的低下性能让人难以接受。 可以把序列分为三部分，分别是：小于划分元素的部分、等于划分元素的部分、大于划分元素的部分。 修改标准划分方案如下：将在左边部分碰到的和划分元素相等的键放到序列的左端，将右边部分碰到的和划分元素相等的键放到序列右端。 然后，当指针交叉而且相等键的位置已知的时候，将所有与划分元素相等的键交换到位  一点说明 程序将数组划分为三部分：小于划分元素的部分（ a[left],..., a[j] ）, 等于划分元素的部分（ a[j + 1],..., a[i - 1] ）,大于划分元素的部分( a[i],...,a[right] )。示意图如下：\nvoid tri_quickSort(type a[], int left, int right){ if(right \u0026lt;= left) return; type v = a[right]; // 划分元素  int i = left, j = right - 1, p = left, q = right - 1; for(;;){ for(;less(a[i], v);i++); for(;less(v, a[j]);j--) if(j == left) break; // 避免划分元素为序列中的最小元素的情况发生  if(j \u0026lt;= i) break; exchange(a[i], a[j]); if(equal(a[i], v)){p++;exchange(a[i], a[p]);} if(equal(a[j], v)){q--;exchange(a[j], a[q]);} } exchange(a[i], a[right]); i--;j++; int k; for(k = left;k \u0026lt; p;k++,i--) exchange(a[k], a[i]); for(k = right - 1;k \u0026gt; q;k--, j++) exchange(a[k], a[j]); tri_quickSort(a, left, i); tri_quickSort(a, j, right); }  奇偶排序 步骤  选取所有为奇数列（下标为1,3,5\u0026hellip;)的元素与其右侧元素比较，将小的放在前面 选取所有为偶数列（下标为2,4,6\u0026hellip;)的元素与其右侧元素比较，将小的放在前面 重复1和2直到所有序列有序为止。  实现 void oddEvenSort(type a[], int left, int right){ int i; bool oddSorted = false, evenSorted = false; while(!oddSorted || !evenSorted){ oddSorted = true; evenSorted = true; for(i = left;i \u0026lt; right;i += 2){ if(less(a[i + 1], a[i])){ exchange(a[i + 1], a[i]); evenSorted = false; } } for(i = left + 1; i \u0026lt; right;i += 2){ if(less(a[i + 1], a[i])){ exchange(a[i + 1], a[i]); oddSorted = false; } } } }  归并排序 归并 数组 a 的前半部分（ a[left],...,a[m] ）有序，后半部分（ a[m + 1],...,a[right] ）有序。归并这两部分，使整个数组有序。一般需要一个辅助数组 aux ,先把结果存到 aux 中，然后把排序结果从 aux 写回到 a 中。 一种常用的归并方法：\nvoid merge0(type a[], int left, int m, int right){ int len = right - left + 1; type *aux = new type[len]; int i = left, j = m + 1, k = 0; while(i \u0026lt;= m \u0026amp;\u0026amp; j \u0026lt;= right) aux[k++] = less(a[i], a[j]) ? a[i++] : a[j++]; while(i \u0026lt;= m) aux[k++] = a[i++]; while(j \u0026lt;= right) aux[k++] = a[j++]; for(i = left, k = 0;i \u0026lt;= right;i++, k++) a[i] = aux[k]; delete []aux; }  另一种归并方法： 将前半部分复制到 aux 中，然后将后半部分（ a[m + 1],...,a[right] ）逆序复制到 aux 中,使两个部分最大元素背靠背位于 aux 中间，形成双调序列。这样，两个部分中的最大元素分别成为一个标记。\nvoid merge1(type a[], int left, int m, int right){ int len = right - left + 1; type *aux = new type[len]; int i, j , k = 0; for(i = left;i \u0026lt;= m;i++) aux[k++] = a[i]; // 复制前半部分到aux  for(j = right;j \u0026gt;= m + 1;j--) aux[k++] = a[j]; // 逆序复制后半部分到aux  i = 0;j = len - 1; for(k = left;k \u0026lt;= right;k++){ if(less(aux[i], aux[j])) a[k] = aux[i++]; // 归并，最大元素为各自的标记  else a[k] = aux[j--]; } delete []aux; }  排序 将数组分为两部分： a[left],..., a[m] 和 a[m + 1], ..., a[right] 。然后对这两个数组进行独立排序（通过递归调用），然后将这两个有序序列归并到最终的序列。\nvoid mergeSort(type a[], int left, int right){ int m = (left + right) / 2; if(right \u0026lt;= left) return; mergeSort(a, left, m); mergeSort(a, m + 1, right); merge1(a, left, m, right); // 归并 }  巴切奇偶归并排序 首先要讲两个函数： 完全混洗(shuffle):将数组 a[left],...,a[right] 分为两半，前一半进入结果中的偶数编号位置，后一半进入结果中的奇数编号位置。 逆完全混洗(unshuffle):偶数编号位置的元素进入结果的前一半，奇数编号位置的元素进入结果的后一半。 这两个函数仅对带有偶数个元素的子数组使用。\nvoid shuffle(type a[], int left, int right){ int i, j, m = (left + right) / 2, len = right - left + 1; type *aux = new type[len]; for(i = left, j = 0;i \u0026lt;= m;i++, j += 2){ aux[j] = a[i]; aux[j + 1] = a[m + 1 + i - left]; } for(i = left, j = 0;i \u0026lt;= right;i++, j++) a[i] = aux[j]; delete []aux; } void unshuffle(type a[], int left, int right){ int i, j, m = (left + right) / 2, len = right - left + 1; int ma = len / 2; type *aux = new type[len]; for(i = left, j = 0;i \u0026lt;= right;i += 2, j++){ aux[j] = a[i]; aux[ma + j] = a[i + 1]; } for(i = left, j = 0;i \u0026lt;= right;i++, j++) a[i] = aux[j]; delete []aux; }  巴切的奇偶归并网络 这个网络输入两个已排好序的序列，对这两个序列进行归并排序。首先对这两个序列进行逆混洗，然后分别归并前后部分，接着再混洗，最后进行一次(1,2)、(3,4)\u0026hellip;这些相邻元素的比较交换得到排序结果。这里的代码只适合元素个数为 2^n 的序列。\nvoid mergeTD(type a[], int left, int right){ int i, m = (left + right) / 2; quickSort(a, left, m); quickSort(a, m + 1, right); if(left + 1 == right) if(less(a[right], a[left])) exchange(a[left], a[right]); if(left + 2 \u0026gt; right) return; // 不多于两个元素  unshuffle(a, left, right); // 逆混洗  mergeTD(a, left, m); mergeTD(a, m + 1, right); shuffle(a, left, right); // 混洗  for(i = left + 1;i \u0026lt; right;i += 2) //比较交换  if(less(a[i + 1], a[i])) exchange(a[i], a[i + 1]); }  堆排序 堆 大顶堆——堆中不存在大于根键的结点。与之对应的由小顶堆。这里使用大顶堆。 如果用数组来保存堆，如果下标从 0 开始，很容易知道位置 i 处结点的父亲位于 (i - 1) / 2 , 反之位置 i 处结点的孩子位于 (2i + 1) 和(2i + 2) 处。 堆中的第 i 个元素大于等于第 (2i + 1) 个元素和 (2i + 2) 个元素。 有关堆的很多算法都是首先对堆做一个简单的修改，这可能违反堆的条件，然后遍历堆，同时修正堆，确保整个堆满足堆的条件。 修正堆的情况有两种，一种是在堆底部添加新节点，然后需要向上遍历调整堆；另一种是用一个新节点替换掉根节点，然后需要向下遍历调整堆。 如果是由于节点的键变得大于它的父亲而违反了堆的性质，则可以通过交换该节点和它的父亲的位置。交换后，节点大于它的两个孩子（ 一个是原来的父亲，一个是原来父亲的另一个孩子），但它仍有可能大于现在的父亲，因此需要继续调整，直到遇到一个真正比它大的父节点或者到达根的位置才结束。 如果是由于节点的键变得小于它的一个或者两个孩子而违反了堆的性质。则可以通过交换此节点和它的大孩子来进行修改。这可能导致孩子 的违规，然后就按照这种方式继续调整，直到到达不小于它的所有孩子的节点或者叶子节点才结束。\n自底向上堆化 向上遍历堆，只要 a[k/2] \u0026lt; a[k] 就交换 k 处和 k/2 处的节点的位置。继续此过程，或者直到到达根节点为止\nvoid fixUp(type a[], int left, int right){ int s = right; int f = s / 2 - 1; while(f \u0026gt;= left){ if(a[f] \u0026lt; a[s]) exchange(a[f], a[s]); s = f; f = s / 2 - 1; } }  自顶向下堆化 向下遍历堆， 交换位置 k 处的节点和它孩子中较大的那个节点（如果有需要的话），当位置 k 处的节点不小于它的孩子或者到达了底端就停止。 需要注意的是：如果 N 为偶数，且 k = N/2 时， 它只有一个孩子节点。\nvoid fixDown(type a[], int left, int right){ int f = left; int s = 2 * f + 1; //左孩子  while(s \u0026lt;= right){ // 没有到达底端  if(s + 1 \u0026lt;= right \u0026amp;\u0026amp; less(a[s], a[s + 1])) s++; // 找大孩子  if(!less(a[f], a[s])) break; // 已经满足堆的条件，跳出  exchange(a[s], a[f]); // 交换  f = s; // 继续  s = 2 * f + 1; } }  排序方法 移出堆顶元素，然后调整堆。重复直到堆中只有一个元素。\nvoid heapSort(type a[], int left, int right){ int N = right - left + 1; int i = N / 2 - 1; // 初始化i为最后一个父节点，从最后一个父节点开始调整，因为所有的叶子节点都是堆了  for(;i \u0026gt;= 0;i--) fixDown(a, i, N); // 建大顶堆  for(i = right;i \u0026gt;= left;){ exchange(a[left], a[i]); // 把根节点交换到最后  fixDown(a, left, --i); // 调整  } }  基数排序  引入：当我们在电话簿中查找某个人的电话时，我们通常只输入前几个字母，然后就能得到电话号码所在的页。为了在排序算法中取得相似效率，可以将比较键的抽象转化为另一种抽象。将这些键分解为一系列定长片段或字节。然后每次处理其中的一个片段，这种排序方法叫做基数排序。基数排序算法把键当作以R为基数的数值系统表示的数，R可取不同的值，分别处理这些数中的单个数字。 基数排序有两种：一种时从左到右按顺序检查键中的位，称为最高位基数排序。另一种采用从右到左的顺序，称为最低为基数排序。\n 以16进制为例，可以通过右移运算取得int(这里int为32 位)型数组 a[i] 的各个字节的数字:最低位(a[i] \u0026gt;\u0026gt; 0) \u0026amp; 0xff 、次低位(a[i] \u0026gt;\u0026gt; 8) \u0026amp; 0xff 以及(a[i] \u0026gt;\u0026gt; 16) \u0026amp; 0xff 和(a[i] \u0026gt;\u0026gt; 24) \u0026amp; 0xff。我们需要256(0xff - 0x00 + 1 = 256)个桶。稍微修改键索引计数的程序就得到了基数排序的程序。\nvoid radix(int b, type a[], int left, int right){ int i, j, M = 256; int N = right - left + 1, cnt[M]; type *aux = new type[N]; for(j = 0;j \u0026lt; M;j++) cnt[j] = 0; // 初始化计数为0  for(i = left;i \u0026lt;= right;i++) cnt[((a[i] \u0026gt;\u0026gt; b * 8) \u0026amp; 0xff) + 1]++; // 统计出现频率  for(j = left;j \u0026lt; M;j++) cnt[j + 1] += cnt[j]; //得到小于等于计数器对应计数值键的数量,将频率转换为索引  for(i = left;i \u0026lt;= right;i++) aux[cnt[(a[i] \u0026gt;\u0026gt; b * 8) \u0026amp; 0xff]++] = a[i]; //将键分不到辅助数组中  for(i = left;i \u0026lt;= right;i++) a[i] = aux[i]; // 回写  delete []aux; } void radixSort(type a[], int left, int right){ radix(0, a, left, right); radix(1, a, left, right); radix(2, a, left, right); radix(3, a, left, right); } ","href":"/blogs/sorting/","title":"各种排序算法"},{"content":"","href":"/tags/git/","title":"Git"},{"content":" 开始 文件的三种状态  已提交(committed) 数据已经安全的保存在了本地的数据库中 已修改(modified) 修改了文件，但还没保存到数据库中 已暂存(staged) 对一个已修改的文件的当前版本做了标记，使之包含在下次的提交快照中。  项目的三个工作区域  Git仓库目录 保存项目的元数据和对象数据库 工作目录 对项目的某个版本独立提取出来的内容 暂存区域 保存下次将要提交的文件列表信息，是一个文件  基本的Git工作流程  在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，将暂存区域中的文件的快照永久保存到Git仓库目录  初次运行前  设置用户名与邮箱地址 --global 表示使用 global config file , 用于所有配置。如果是对于需要使用不同用户名和邮箱的特定项目就不需要这个选项。\n$ git config --global user.name username $ git config --global user.email example@xxx.com 设置文本编辑器\n$ git config --global core.editor code 查看配置信息\n$ git config --list 获取帮助\n  有三种方式可以获取帮助，windows中默认支支持前两种\n$ git help \u0026lt;verb\u0026gt; $ git \u0026lt;verb\u0026gt; --help $ man git-\u0026lt;verb\u0026gt; 基础 获取Git仓库  在现有目录中初始化Git仓库\n$ git init  如果不是在一个空文件夹下执行这个命令，那么我们可以多做一点事情：开始跟踪指定文件并提交。使用 git add 命令来实现对指定文件的跟踪，然后执行 git commit 提交。\n 克隆现有仓库\n$ git clone [url]  这个命令将会克隆Git仓库服务器上几乎所有的数据。\n记录每次更新到仓库  检查文件当前状态\n$ git status 跟踪新文件\n$ git add (files)  跟踪后的文件会处于暂存状态。可以运行 git status 命令查看。 如果修改了已跟踪的文件，它的状态会变为已修改，要暂存这次更新，就需要运行 git add 命令 。注意： git add 是一个多功能命令，可以理解为“添加内容到下一次提交中”。\n 查看已暂存或未暂存的修改\n$ git diff  注意：git diff 只显示尚未暂存的改动，可以加上 --cache 选项来查看已经暂存的改动。可以使用这个命令来分析文件的差异。\n 提交更新\n$ git commit  这会启动默认的文本编辑器以便输入本次提交的说明。可以使用 -m 选项来把提交信息与命令放在同一行。如：\n$ git commit -m \u0026#34;add readme.md\u0026#34;  跳过使用暂存区域 在提交的时候，给 git commit 命令加上 -a 选项，Git就会自动把所有已跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤。\n 移除文件 要从Git中移除某个文件，就必须要从已跟踪文件清单中移除（准确来说，是暂存区域），然后提交。使用的命令是 git rm ,它还会从工作目录中删除指定文件，这样就不会被跟踪了。 如果想把文件从Git仓库中删除（亦从暂存区域删除），加上 --cache 选项即可。\n 移动文件 使用命令 git mv 即可。它亦可以用来重命名文件：\n$ git mv old_file new_file 查看提交历史\n$ git log  这默认会按文件提交时间列出所有的更新，并且最新的跟新在最上面。一个常用的选项是 -p ,用来显示每次提交内容的差异。\n 撤销操作  重新提交，下面的命令会用第二次提交取代第一次提交的结果：\n$ git commit --amend 取消暂存的文件：\n$ git reset \u0026lt;file\u0026gt; 撤销对文件的修改：\n$ git checkout --\u0026lt;file\u0026gt; 远程仓库的使用  查看远程仓库\n$ git remote 添加远程仓库\n$ git remote add \u0026lt;shortname\u0026gt; \u0026lt;url\u0026gt;  这会添加一个远程仓库并指定使用间写 shortname 来引用它。\n 从远程仓库抓取\n$ git fetch [remote-name] 推送到远程仓库\n$ git push [remote-name] [branch-name] 查看远程仓库\n$ git remote show [remote-name] 重命名远程仓库\n$ git remote rename [old-name] [new-name] 删除远程仓库\n$ git remote rm [remote-name]  ","href":"/blogs/about-git/","title":"Git初探"},{"content":" 问题由来  这是一个很经典的问题了，大概就是说： 已知n个人（以编号1，2，3\u0026hellip;n分别表示）围成一个圆圈。 从第一个人开始报数，数到m的那个人出列自杀；他的下一个人又从1开始报数，数到m的那个人又出列自杀； 依此规律重复下去，找出最后剩下来的那个人。更一般的，找出自杀顺序。\n 用C++链表实现 为了以一种圆圈的形式排列人群， 我们可以构建一个循环链表，每个人和他左边的那个人之间都有一个链接。用整数 i 代表循环中的第 i 个人。从 1 开始，每次生成一个结点插入链表尾部……直到最后一个人 n 进入链表， 然后让 n 的下一个指向 1，这样就构成了一个循环链表。设置一个变量 t 记录当前所报数字。从链表头部开始（ t = 1）用迭代器 it 遍历链表，当 t == m 时，it 刚好指向要该自杀的那个人，于是输出并从链表中删除。当 it 到达链表尾部时，让 it 指向链表头，这样就形成了一个环。重复操作，直到剩下最后一个人。\n#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;list\u0026gt;using namespace std; int main(){ int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); list\u0026lt;int\u0026gt; ring; for(int i = 1;i \u0026lt;= n;i++) ring.push_back(i); int t = 1; //计数  for(list\u0026lt;int\u0026gt;::iterator it = ring.begin();ring.size() != 1;){ if(t++ == m){ printf(\u0026#34;%-3d\u0026#34;, *it); it = ring.erase(it); // 自杀  t = 1; } else it++; // 指向下一个  if(it == ring.end()) it = ring.begin(); } printf(\u0026#34;\\nalive: %d\\n\u0026#34;, *ring.begin()); system(\u0026#34;pause\u0026#34;); return 0; }  用数组模拟链表实现 我们可以用数组的索引来实现链表，而不是用指针。方法就是：用数组元素 item[i] 存储编号为 i 的人，用数组元素 next[i] 存储 i 的下一个在数组中的位置。那么有 item[i] == i + 1。注意最开始的时候 next[n - 1] = 0 。用位置变量 pos 跟踪元素，首先让 pos = n - 1 ,这样 pos 才是指向第一个人的，通过 m - 1 次 pos = next[pos] 得到自杀的那个人的前一个人位置，然后用 next[pos] = next[next[pos]] 删除第 m 个人。这种方式还是很浪费空间的。\n#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstdlib\u0026gt;#include\u0026lt;vector\u0026gt;using namespace std; int main(){ int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); vector\u0026lt;int\u0026gt; item, next; for(int i = 1;i \u0026lt;= n;i++){ item.push_back(i); next.push_back(i % n); // 存放i的下一个的数组下标  } int t, pos = n - 1; // 使pos指向链表首元素  for(int i = 0;i \u0026lt; n - 1;i++){ for(t = 0;t \u0026lt; m - 1;t++) pos = next[pos]; printf(\u0026#34;%-3d\u0026#34;, item[next[pos]]); next[pos] = next[next[pos]]; // 自杀  } printf(\u0026#34;\\nalive: %d\\n\u0026#34;, item[pos]); system(\u0026#34;pause\u0026#34;); return 0; } ","href":"/blogs/josepus-problem/","title":"约瑟夫问题"},{"content":" 筛法原理  给出要筛数值的范围maxn，找出maxn以内所有的素数。先用2去筛，即把2留下，把2的倍数剔除掉；再用下一个素数，也就是3筛，把3留下，把3的倍数剔除掉；接下去用下一个素数5筛，把5留下，把5的倍数剔除掉；不断重复下去\u0026hellip;\u0026hellip;。\n 算法 可以通过维护一个标记数组 a[]来进行判断。\n 若 i 为素数，则 a[i] = 1 ，否则 a[i] = 0。 首先，将所有的 a[i] 都设置为 1，表示已知的都是素数。然后将所有以已知素数的倍数为索引的数组元素设为 0。 如果将所有较小素数的倍数都设置为 0 之后，a[i] 仍为 1，则 i 为素数。\n#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstdlib\u0026gt;const int maxn = 10000; int main(){ int i, j, t, a[maxn]; for(i = 2;i \u0026lt; maxn;i++) a[i] = 1; for(i = 2;i \u0026lt; maxn;i++){ if(a[i] == 1){ t = maxn / i; for(j = i;j \u0026lt; t;j++) a[i * j] = 0; } } for(i = 2;i \u0026lt; maxn;i++){ if(a[i] == 1) printf(\u0026#34;%4d \u0026#34;, i); } system(\u0026#34;pause\u0026#34;); return 0; }   ","href":"/blogs/seive-of-eratosthenes/","title":"厄拉多筛法求素数"},{"content":" 记录一下最近学习的并查集。\n问题引入 假定有一个整数对序列，其中每个整数代表某种类型的一个对象，而且将 p-q 解释为“p与q连通”。关系是可传递的，如果 p-q 和 q-r ，则有 p-r 。我们的目标是编写一段程序，从集合中过滤额外连接对。当程序输入一个连接对 p-q ，若之前的连接对不能通过传递关系推导出 p-q ，则输出 p-q ， 否则忽略 p-q ，读取下一个整数对。\n过程示例:\n3-4 3-4\n4-0 4-0\n3-0\n4-1 4-1\n5-6 5-6\n0-5 0-5\n3-5\n2-9 2-9\n我们的问题是设计一个程序，它通过已有的信息，来判断新的对象是否连通。整数可能代表一个大型网络中的计算机，整数对可能代表网络中的连通情况。同样，整数也可以代表一个电网中的触电， 整数对就是电线……这些问题的规模可能都非常巨大，算法的好坏直接决定了开销的大小。\n并和查 并查集主要有以下两个操作:\n 并： 合并两个集合 查： 判断两个元素是否属于同一个集合  解决方案 我们可以通过查找（union）和并集（union）运算来解决连通性问题。每当从输入读取一个新的 p-q 对后，分别进行 p 和 q 的查找， 如果它们位于同一个集合中，就直接分析下一个 p-q 对。否则，就进行并集操作并输出。 最可能想到的是依次保存每一个 p-q 对，然后进行遍历，判断它们是否连通。可问题的规模可能很大，这时候这个方法就捉襟见肘了。我们其实并不用保存所有的 p-q 对，使用一个整数数组来保存实现find和union操作的必备信息即可。\n快速查找（quick-find）简单算法  假设A和B是朋友，B和C是朋友，A和B互不认识，但他们通过B这个共同的朋友联系在了一块儿。C还会有朋友D……,所有能通过某种朋友关系建立联系的朋友就构成了一个朋友圈。设想每个朋友圈都有一个圈主，圈主唯一的确定了这个圈子。为了简化问题，每当有一个新的人加入圈子，他就成为了这个圈子的圈主。 于是我们可以用一个数组 A[] 来进行存储。如果 i 代表一个人，那么 A[i] 就是他的圈主。现在我们来判断 p 和 q 是不是位于同一个圈子, 解决最开始提出的问题。\n 使用一个整数数组 A[] , 它具有如下性质：当且仅当 A[p] = A[q] 时，p与q连通。首先用 i 初始化 A[i] , 为了对 p 和 q 实现并集的运算，遍历数组，将所有和 A[p] 值相同项的替换为 A[q] 的值。\n#include\u0026lt;cstdio\u0026gt;const int N = 10000; int main(){ int p, q, A[N]; for(int i = 0;i \u0026lt; N;i++) A[i] = i; while(scanf(\u0026#34;%d-%d\u0026#34;, \u0026amp;p, \u0026amp;q) == 2){ if(A[p] == A[q]) continue; for(int i = 0, t = A[p];i \u0026lt; N;i++){ if(A[i] == t) A[i] = A[q]; } printf(\u0026#34;%d-%d\\n\u0026#34;, p, q); } }  可以用树来表示quick-find的过程。如下图中左半部分所示，每输入一个 p-q 对， A[q] 就成为父节点。下图的右半部分描述的是quick-union的过程， 每次只有一个值发生了改变。也就是 q 成为了 p 的父节点。 快速并集（quick-union）算法  前面的快速查找算法能够正确解决问题，当面对百万级的输入，效率就不行了。下面是quick-find的互补方法——quick-union。 可以用树来描述描述p和q是不是位于同一个集合，如果p和q有相同的根节点，那么他们位于同一个集合。如果p和q不在同一个集合中， 为了形成并集，使p和q拥有相同的根节点即可。 和quick_find的不同在于： * 这里 A[i] 的值指向的是它的父亲在数组中的下标（比如 A[1] = 2 ， 1的父亲在数组中的下标为2）。 * 根节点的值指向它本身，即：若 i 为根节点，则 A[i] = i ;根节点总是存在的。 * 通过分别通过 i 和 j 递归查找 p 和 q 的根节点。\n 用下面的代码替换quick-find中的 while 循环体\nint i , j; for(i = p;i != A[i];i = A[i]); for(j = q;j != A[j];j = A[j]); if(i == j) continue; //p和q的根相同，说明p和q连通 A[i] = j; // 进行并集操作 printf(\u0026#34;%d-%d\\n\u0026#34;, p, q);  加权快速并集（weighted-quick-union）算法  quick-union是对quick-find的一种改进，但仍然有缺陷。每次进行并集操作就相当于把一棵树的树根链接到另一棵树的树根上去。 而找到根节点所化的时间和当前结点到根节点的距离有关，距离越短，for循环执行的次数就越少 如果能够直接把较小的树的根直接连接到较大的树的根上，就能缩短时间。 于是我们可以设置辅助数组 S[] 来跟踪每个结点子树中结点的数量，然后总是把较小的树的根连接到较大的树的根上去。\n #include\u0026lt;cstdio\u0026gt;const int N = 10000; int main(){ int p, q, A[N], S[N]; for(int i = 0;i \u0026lt; N;i++){A[i] = i;S[N] = 1;} while(scanf(\u0026#34;%d-%d\u0026#34;, \u0026amp;p, \u0026amp;q) == 2){ int i , j; for(i = p;i != A[i];i = A[i]); for(j = q;j != A[j];j = A[j]); if(i == j) continue; //p和q的根相同，说明p和q连通  A[i] = j; // 进行并集操作  if(S[i] \u0026lt; S[j]){A[i] = j;S[j] += S[i];} // 寻找大树  else {A[j] = i;S[i] += S[j];} printf(\u0026#34;%d-%d\\n\u0026#34;, p, q); } }  路径压缩  如果能够在并集操作中，使每个结点都能直接指向树根，那么将大大节省开销。最终的结果就是几乎把整棵树压平，接近于理想情况。 可以对上面的算法做一个简单的改进——通过某种方法让 A[i] 存储的不再是它父亲在数组中的下标，而是越过父节点更靠近根节点的结点在数组中的下标。比如父结点的父节点。\n 对代码进行一下调整：\nfor(i = p;i != A[i];i = A[i]) A[i] = A[A[i]]; for(j = q;j != A[j];j = A[j]) A[i] = A[A[i]]; ","href":"/blogs/union-find/","title":"并查集"},{"content":"","href":"/tags/hugo/","title":"Hugo"},{"content":"","href":"/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"环境搭建"},{"content":"  本文主要是想记录一下自己在win10下使用hugo和github pages搭建博客的过程，备忘。 为什么我要用hugo而不用hexo呢,最主要是因为hugo构建网站的速度非常快，直接秒好。\n 环境要求  Go语言 Git hugo  搭建环境 Go语言  下载 如何安装 添加环境变量 验证安装  win+R打开命令行窗口，输入：\ngo version 如果输出当前安装的go语言的版本号，即安装成功。\nGit  how to install Git中文教程  hugo  如何安装 添加hugo环境变量 验证安装\nhugo version  现在我们需要的环境都创建好了，接下来就可以在建立自己的网站了。\n创建网站 首先在本地建立一个存放自己网站的文件夹，然后通过命令行进入刚才创建的文件夹，继续操作。\n建立新网站mysite # mysite是将要创建的网站名 hugo new site mysite 添加theme # 进入mysite cd mysite  默认情况下hugo生成的网站是没有任何theme的，所有我们需要自己去下载theme。 如果网速好的话，我们可以一次性下载所有的themes到themes文件夹下：\n git clone --depth 1 --recursive https://github.com/gohugoio/hugoThemes.git themes 也可以只下载一个theme\ncd themes # 没有的话就创建一个 使用git clone命令下载单个主题，用法如下：\ngit clone URL_TO_THEME # URL_TO_THEME是theme的地址  比如我要下载hyde这个theme:\ngit clone https://github.com/spf13/hyde 添加内容并发布网站 在网站的根目录下执行：\nhugo new posts/my-first-article.md 这样我们就成功的建立了my-first-article这篇文章，它位于网站根目录下的posts文件夹里。随便写你想写的内容，然后启动hugo服务器，下面-D表示当前内容为草稿，-t hyde表示采用hyde作为网站的theme：\nhugo setver -D -t hyde 现在在浏览器输入：http://localhost:1313/。然后你就能看到你刚才写的网站了。现在你可以继续修改my-first-article的内容，浏览器会实时更新的的改动，不过这可能并不会被你发觉，因为hugo的速度实在是太快了，哈哈哈。\n正式发布\u0026ndash;托管到github 本地网站建好了，不过现在只有你自己能够看到。如果你想让别人也看到你的网站的话，我猜你肯定不想用自己的电脑做服务器吧。这个时候你可以利用github pages来都达到你的目的。\n 如果你没有github账号的话，那么首先注册github。千万别忘了你的用户名，后面会用上。假设我的用户名是sarkar。 登录github, 建立两个repository。一个是工程仓库（假定为mysite), 用来存放hugo内容和其他的资源文件。另一个就是sarkar.github.io, 这就是用来放你的网站内容的地方了(记得把这里的和以后的sarkar都换成你自己的github用户名)。 回到网站的根目录下，也就是mysite目录，在这之前打开你准备发布的.md文件，将draft: true改为draft: false。这样就可以正式的发布内容了，不再是草稿。然后执行命令：\nhugo -t hyde --baseUrl=\u0026#34;https://sarkar.github.io\u0026#34;  记得把username换成你自己的github用户名。 \u0026gt;命令会在网站网站的根目录下生成一个public文件夹，里面包含了hugo生成的所有静态页面。接下来要做的就是把这下静态页面给push到github上去。\u0026gt;\n首先需要进到pulib目录, 然后执行以下命令：\ncd public # 进入public目录 git init git remote add origin https://github.com/sarkar/sarkar.github.io.git git add -A git commit -m \u0026#34;first commit\u0026#34; git push -u origin master 不出意外的话，应该会弹出一个github的登陆窗口或者类似的东西。然后静待本地文件全部push完成。到浏览器输入sarkar.github.io应该就能访问到了刚才建立的网站了。\n","href":"/blogs/building-your-blogsite-with-github-pages-and-hugo/","title":"用hugo和github pages搭建个人博客"},{"content":"","href":"/page/","title":"Pages"},{"content":"","href":"/search/","title":"Search"},{"content":"","href":"/search/","title":"Search"},{"content":"","href":"/series/","title":"Series"}]
