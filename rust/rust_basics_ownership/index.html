<!doctype html><html lang=zh-cn dir=auto><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="所有权（ownership） 是 Rust 独一无二的功能，也是 Rust 中的核心功能之一。Rust 不需要开发者手动回收内存，也没有垃圾收集器，但它还能保证内存">
<meta name=theme-color content="#ffcd00">
<meta property="og:title" content="Rust 基础：所有权 • Nicholas Zhan">
<meta property="og:description" content="所有权（ownership） 是 Rust 独一无二的功能，也是 Rust 中的核心功能之一。Rust 不需要开发者手动回收内存，也没有垃圾收集器，但它还能保证内存">
<meta property="og:url" content="https://zhannicholas.github.io/rust/rust_basics_ownership/">
<meta property="og:site_name" content="Nicholas Zhan">
<meta property="og:type" content="article"><meta property="og:image" content="https://www.gravatar.com/avatar/85f2cc2a45fd9533b91a65214224f9d7?s=256"><meta property="article:section" content="rust"><meta property="article:tag" content="Rust"><meta property="article:published_time" content="2021-09-25T10:51:29+08:00"><meta property="article:modified_time" content="2021-09-25T10:51:29+08:00"><meta name=twitter:card content="summary">
<meta name=generator content="Hugo 0.90.1">
<title>Rust 基础：所有权 • Nicholas Zhan</title>
<link rel=canonical href=https://zhannicholas.github.io/rust/rust_basics_ownership/>
<link rel=icon href=/favicon.ico>
<link rel=stylesheet href=/assets/css/main.ab98e12b.css><link rel=stylesheet href=/css/custom.css><style>:root{--color-accent:#ffcd00}</style>
</head>
<body class="page type-rust has-sidebar">
<div class=site><div id=sidebar class=sidebar>
<a class=screen-reader-text href=#main-menu>跳到主菜单</a>
<div class=container><section class="widget widget-about sep-after">
<header>
<div class=logo>
<a href=/>
<img src=/images/logo.png>
</a>
</div>
<h2 class="title site-title">
<a href=/>
Nicholas Zhan
</a>
</h2>
<div class=desc>
Java Developer, Runner, Cyclist
</div>
</header>
</section>
<section class="widget widget-search sep-after">
<header>
<h4 class="title widget-title">搜索</h4>
</header>
<form action=/search id=search-form class=search-form>
<label>
<span class=screen-reader-text>搜索</span>
<input id=search-term class=search-term type=search name=q placeholder=搜索&mldr;>
</label></form>
</section>
<section class="widget widget-sidebar_menu sep-after"><nav id=sidebar-menu class="menu sidebar-menu" aria-label=侧边栏菜单>
<div class=container>
<ul><li class="item has-children">
<a href=/java/>Java</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span>
</button>
<ul class=sub-menu><li class=item>
<a href=/java/jakartaee/>Jakarta EE</a></li><li class=item>
<a href=/java/jvm/>JVM</a></li><li class=item>
<a href=/java/concurrency/>并发</a></li></ul></li><li class="item has-current">
<a href=/rust/>Rust</a></li><li class=item>
<a href=/distributed_computing/>分布式计算</a></li><li class=item>
<a href=/operating_systems/>操作系统</a></li><li class="item has-children">
<a href=/computer_networks/>计算机网络</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span>
</button>
<ul class=sub-menu><li class=item>
<a href=/computer_networks/http/>HTTP</a></li><li class=item>
<a href=/computer_networks/fundamentals/>基础知识</a></li></ul></li></ul>
</div>
</nav>
</section><section class="widget widget-taxonomy_cloud sep-after">
<header>
<h4 class="title widget-title">标签</h4>
</header>
<div class="container list-container">
<ul class="list taxonomy-cloud"><li>
<a href=/tags/communication/ style=font-size:1em>Communication</a>
</li><li>
<a href=/tags/c%E7%AE%97%E6%B3%95/ style=font-size:1.2380952380952381em>C算法</a>
</li><li>
<a href=/tags/english/ style=font-size:1em>English</a>
</li><li>
<a href=/tags/gc/ style=font-size:1.0952380952380953em>GC</a>
</li><li>
<a href=/tags/git/ style=font-size:1em>Git</a>
</li><li>
<a href=/tags/http/ style=font-size:1.3333333333333333em>HTTP</a>
</li><li>
<a href=/tags/hugo/ style=font-size:1em>Hugo</a>
</li><li>
<a href=/tags/jakartaee/ style=font-size:1.0952380952380953em>JakartaEE</a>
</li><li>
<a href=/tags/java/ style=font-size:2em>Java</a>
</li><li>
<a href=/tags/jdbc/ style=font-size:1em>JDBC</a>
</li><li>
<a href=/tags/jvm/ style=font-size:1.1428571428571428em>JVM</a>
</li><li>
<a href=/tags/leetcode/ style=font-size:1.0952380952380953em>Leetcode</a>
</li><li>
<a href=/tags/life/ style=font-size:1em>Life</a>
</li><li>
<a href=/tags/linux/ style=font-size:1.1428571428571428em>Linux</a>
</li><li>
<a href=/tags/mybatis/ style=font-size:1em>MyBatis</a>
</li><li>
<a href=/tags/networks/ style=font-size:1.0952380952380953em>Networks</a>
</li><li>
<a href=/tags/os/ style=font-size:1.2857142857142856em>OS</a>
</li><li>
<a href=/tags/ostep/ style=font-size:1.0952380952380953em>OSTEP</a>
</li><li>
<a href=/tags/python/ style=font-size:1em>Python</a>
</li><li>
<a href=/tags/redis/ style=font-size:1.3333333333333333em>Redis</a>
</li><li>
<a href=/tags/rpc/ style=font-size:1em>RPC</a>
</li><li>
<a href=/tags/rust/ style=font-size:1.3333333333333333em>Rust</a>
</li><li>
<a href=/tags/shell/ style=font-size:1.2380952380952381em>Shell</a>
</li><li>
<a href=/tags/sicp/ style=font-size:1em>SICP</a>
</li><li>
<a href=/tags/spring/ style=font-size:1em>Spring</a>
</li><li>
<a href=/tags/spring-boot/ style=font-size:1em>Spring Boot</a>
</li><li>
<a href=/tags/tomcat/ style=font-size:1em>Tomcat</a>
</li><li>
<a href=/tags/zookeeper/ style=font-size:1em>ZooKeeper</a>
</li><li>
<a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/ style=font-size:1.0476190476190477em>分布式计算</a>
</li><li>
<a href=/tags/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/ style=font-size:1.0476190476190477em>多处理器编程的艺术</a>
</li><li>
<a href=/tags/%E5%B7%A5%E7%A8%8B%E6%80%9D%E7%BB%B4/ style=font-size:1em>工程思维</a>
</li><li>
<a href=/tags/%E5%B9%B6%E5%8F%91/ style=font-size:1.2857142857142856em>并发</a>
</li><li>
<a href=/tags/%E6%90%9C%E7%B4%A2/ style=font-size:1em>搜索</a>
</li><li>
<a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/ style=font-size:1.0476190476190477em>数据库</a>
</li><li>
<a href=/tags/%E6%B8%B8%E8%AE%B0/ style=font-size:1em>游记</a>
</li><li>
<a href=/tags/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ style=font-size:1.0476190476190477em>现代操作系统</a>
</li><li>
<a href=/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/ style=font-size:1em>生产者消费者</a>
</li><li>
<a href=/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/ style=font-size:1.1428571428571428em>算法导论</a>
</li><li>
<a href=/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/ style=font-size:1em>设计原则</a>
</li><li>
<a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ style=font-size:1.5714285714285714em>设计模式</a>
</li></ul>
</div>
</section>
</div>
<div class=sidebar-overlay></div>
</div><div class=main><nav id=main-menu class="menu main-menu" aria-label=主菜单>
<div class=container>
<a class=screen-reader-text href=#content>跳到内容</a>
<button id=sidebar-toggler class=sidebar-toggler aria-controls=sidebar>
<span class=screen-reader-text>Toggle Sidebar</span>
<span class=open><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
</span>
<span class=close><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
</span>
</button>
<ul><li class=item>
<a href=/>主页</a>
</li><li class=item>
<a href=/posts/>博客</a>
</li><li class=item>
<a href=/notebook/>笔记本</a>
</li><li class=item>
<a href=/itinerary/>游山玩水</a>
</li></ul>
</div>
</nav><div class=header-widgets>
<div class=container>
<style>.widget-breadcrumbs li:after{content:'\2f '}</style>
<section class="widget widget-breadcrumbs sep-after">
<nav id=breadcrumbs>
<ol><li><a href=/>主页</a></li><li><a href=/rust/>Rust</a></li><li><span>Rust 基础：所有权</span></li></ol>
</nav>
</section></div>
</div>
<header id=header class="header site-header">
<div class="container sep-after">
<div class=header-info><p class="site-title title">Nicholas Zhan</p><p class="desc site-desc">Java Developer, Runner, Cyclist</p>
</div>
</div>
</header>
<main id=content>
<article lang=zh-cn class=entry>
<header class="header entry-header">
<div class="container sep-after">
<div class=header-info>
<h1 class=title>Rust 基础：所有权</h1>
</div>
<div class=entry-meta>
<span class=posted-on><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
<span class=screen-reader-text>Posted on </span>
<time class=entry-date datetime=2021-09-25T10:51:29+08:00>2021, Sep 25</time>
</span>
<span class=byline><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M21 21V20c0-2.76-4-5-9-5s-9 2.24-9 5v1"/><path d="M16 6.37A4 4 0 1112.63 3 4 4 0 0116 6.37z"/></svg>
<span class=screen-reader-text> by </span><a href=/authors/zhannicholas>Nicholas Zhan</a></span>
<span class=reading-time><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 15 15"/></svg>
11 mins read
</span>
</div>
</div>
</header>
<details class="container entry-toc">
<summary class=title>
<span>目录</span>
</summary>
<nav id=TableOfContents>
<ul>
<li><a href=#栈与堆>栈与堆</a></li>
<li><a href=#所有权规则>所有权规则</a></li>
<li><a href=#变量与数据的交互方式>变量与数据的交互方式</a>
<ul>
<li><a href=#移动move>移动（Move）</a></li>
<li><a href=#克隆clone>克隆（Clone）</a></li>
<li><a href=#栈上数据的复制copy>栈上数据的复制（Copy）</a></li>
</ul>
</li>
<li><a href=#所有权与函数>所有权与函数</a></li>
<li><a href=#引用>引用</a>
<ul>
<li><a href=#可变引用>可变引用</a></li>
</ul>
</li>
<li><a href=#切片slice>切片（Slice）</a>
<ul>
<li><a href=#字符串切片>字符串切片</a></li>
<li><a href=#其它类型的切片>其它类型的切片</a></li>
</ul>
</li>
<li><a href=#参考资料>参考资料</a></li>
</ul>
</nav>
</details>
<div class="container entry-content">
<p><strong>所有权（ownership）</strong> 是 Rust 独一无二的功能，也是 Rust 中的核心功能之一。Rust 不需要开发者手动回收内存，也没有垃圾收集器，但它还能保证内存安全，这就是所有权的强大之处。</p>
<p>在 Rust 中，内存的管理是通过所有权系统（ownership system）进行的，编译器会在编译时根据一系列的规则进行检查。更加令人赞叹的是，所有权系统中的任何功能都不会减慢程序的运行速度！</p>
<h2 id=栈与堆>栈与堆</h2>
<p>在开始学习所有权这个概念之前，我们有必要先回顾一下数据在内存中的存放形式。在 Rust 中，数据被存放在栈（stack）或堆（heap）中。</p>
<p>栈与堆组织数据的方式不同。在栈中，数据时先入后出（FILO）的，即最后存入的数据最先被使用。而在堆中，数据的使用就没有顺序要求，数据在堆中的组织情况比栈中要差很多。此外，存放在栈中的数据占用的空间必须是 <strong>编译期间已知且固定的</strong>，对于那些大小不固定或编译时无法知道大小的数据，应当被存放在堆上。在我们往堆中存数据时，内存分配器会从堆中找出一块大小合适的内存空间，标记其已使用，然后返回给我们一个指向分配地址的指针，后续我们就可以使用这个指针访问堆中的数据。这个指针会被存储在栈上，因为它的大小是固定且已知的。</p>
<p>将数据存储在栈上的速度要快于存储在堆上的速度。因为当数据被放在栈上时，内存分配器不需要为新数据找出一块空闲空间，数据总是被放在栈顶。如果数据要被放到堆上，内存分配器不仅需要从堆中找出一块合适的空闲空间，还需要防止这块空间被其它数据抢占。类似地，访问栈上数据的速度要快于访问堆上数据的速度。因为堆上的数据需要通过栈上的指针才能定位到，这比栈上的数据多了一次内存访问。</p>
<p>当我们调用一个函数时，传递给函数的值（或指向堆中数据的指针）和函数中的局部变量都是存放在栈上的。当函数调用结束后，这些值都会从栈中弹出。</p>
<p>讲了这么多，现在该所有权出场了。所有权负责 <strong>跟踪哪部分代码正在使用堆中的哪部分数据，最大限度地减少堆中的重复数据，清理堆中未使用的数据，防止内存空间被耗尽</strong>。简单来说，所有权管理着堆中的数据。</p>
<p>那么，Rust 中的哪些数据会被分配在堆上呢？答案是那些大小在编译期间不可知或者大小不固定的数据，比如字符串类型（<code>String</code>）。标量类型（整型、浮点型、布尔类型和字符类型）或复合类型（元组和数组）的数据都是存放在栈上的，作用域结束时就会被从栈上弹出。</p>
<p>需要注意的是：字符串类型（<code>String</code>）和字符串字面量（string literal）是不同的。字符串字面量（比如 <code>let s = "hello, world";</code>）是代码中硬编码的（编译时大小已知）、不可变的，而字符串类型的数据被存储在堆上，字符串类型的数据是可变的。我们可以使用 <code>String</code> 的 <code>from</code> 函数从字符串字面量创建一个 <code>String</code> 类型的变量，比如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
    s.push_str(<span style=color:#e6db74>&#34;, world!&#34;</span>); <span style=color:#75715e>// push_str() appends a literal to a String
</span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;{}&#34;</span>, s); <span style=color:#75715e>// This will print `hello, world!`
</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=所有权规则>所有权规则</h2>
<p>所有权的规则如下，它们不可被违反：</p>
<ul>
<li>Rust 中的每个值都有一个变量，这个变量就是这个值的 <strong>所有者（owner）</strong></li>
<li>每个值在同一时刻有且只有一个所有者</li>
<li>当所有者（变量）超出作用域（scope），值就会被丢弃（drop），值占据的内存被归还</li>
</ul>
<p>变量在进入作用域后开始生效，此后，变量在超出作用域之前一直都是有效的。举个例子：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    { <span style=color:#75715e>// s is not valid here, it’s not yet declared
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello&#34;</span>;   <span style=color:#75715e>// s is valid from this point forward
</span><span style=color:#75715e></span>
        <span style=color:#75715e>// do stuff with s
</span><span style=color:#75715e></span>    }  <span style=color:#75715e>// this scope is now over, and s is no longer valid
</span><span style=color:#75715e></span>}
</code></pre></div><p>实际上，当变量超出作用域时，Rust 会自动为我们调用一个叫 <code>drop</code> 的特殊函数进行内存的归还。在上面这个例子中，<code>drop</code> 会在第一个 <code>}</code> 处被调用。</p>
<h2 id=变量与数据的交互方式>变量与数据的交互方式</h2>
<p>在 Rust 中，多个变量可以以不同的方式与同一份数据进行交互，最常见的交互方式有移动（move）和克隆（clone）。</p>
<h3 id=移动move>移动（Move）</h3>
<p>先来看一段简单的代码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
    <span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> x;
    println!(<span style=color:#e6db74>&#34;x = {}, y = {}.&#34;</span>, x, y);
}
</code></pre></div><p>这段代码很简单，也能通过编译，最终运行会打印出结果 <code>x = 5, y = 5.</code>。如果将 <code>let x = 5;</code> 修改为 <code>let x = "5";</code>，仍然能得到一样的运行结果。但是，如果我将 <code>let x = 5;</code> 修改成 <code>let x = String::from("5");</code>，编译都过不去了😂。我并没有改动代码的结构，唯一改变的只有变量 <code>x</code> 的类型，这里面到底发生了什么？🤔</p>
<p>要回答这个问题，我们需要了解 Rust 中 <code>String</code> 在内存中的存储形式。为了能够使用官方的图，让我将代码修改为官方的代码😁：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
    <span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> s1;
    println!(<span style=color:#e6db74>&#34;s1 = {}, s2 = {}&#34;</span>, s1, s2);
}
</code></pre></div><p>在 Rust 中，<code>String</code> 由三部分组成：指向字符串实际内容的指针、长度和容量。它们存放在栈上，对应下图中的左侧部分，字符串的实际内容则存放在堆上，对应下图中的右侧部分：</p>
<p><img src=/images/rust/trpl04-01.svg alt></p>
<p>当变量 <code>s1</code> 被赋值给 <code>s2</code> 后，字符串 <code>s1</code> 在栈上的数据被复制了一份给 <code>s2</code> 用，而堆上的内容没有被复制：</p>
<p><img src=/images/rust/trpl04-02.svg alt></p>
<p>这个过程似曾相识，它就像 Java 中的浅拷贝（shallow copy）一样。在，Rust 中，实际的过程不完全是这样，因为当 <code>s1</code> 和 <code>s2</code> 都超出作用域时，显然不应该归还两次内存。Rust 为了保证内存安全，并没有进行复制操作，而是在在执行 <code>let s2 = s1;</code> 之后使 <code>s1</code> 失效。这样，当 <code>s1</code> 超出作用域时，Rust 就不需要因为它释放任何内存了。让 <code>s1</code> 失效的操作在 Rust 中被称为 <strong>移动（move）</strong>，<code>let s2 = s1;</code> 的实际作用是让 <code>s1</code> 移动到 <code>s2</code>。所以，正确的图是下面这样的：</p>
<p><img src=/images/rust/trpl04-04.svg alt></p>
<p>这就是上面代码编译失败的原因，这下应该能看懂编译器给出的信息了：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>&gt; cargo run
   Compiling ownership v0.1.0 (F:\Code\Rust\rust-study\ownership)
warning<span style=color:#960050;background-color:#1e0010>:</span> unused variable<span style=color:#960050;background-color:#1e0010>:</span> `s2`
 --&gt; src\main.rs<span style=color:#960050;background-color:#1e0010>:</span>3<span style=color:#960050;background-color:#1e0010>:</span>9
  |
3 |     let s2 = s1;
  |         ^^ help<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#66d9ef>if</span> this is intentional, prefix it with an underscore<span style=color:#960050;background-color:#1e0010>:</span> `_s2`
  |
  = note<span style=color:#960050;background-color:#1e0010>:</span> `<span style=color:#75715e>#[warn(unused_variables)]` on by default</span>

error<span style=color:#66d9ef>[E0382]</span><span style=color:#960050;background-color:#1e0010>:</span> borrow of moved value<span style=color:#960050;background-color:#1e0010>:</span> `s1`
 --&gt; src\main.rs<span style=color:#960050;background-color:#1e0010>:</span>4<span style=color:#960050;background-color:#1e0010>:</span>28
  |
2 |     let s1 = String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
  |              -- value moved here
4 |     println!(<span style=color:#e6db74>&#34;{}, world!&#34;</span>, s1);
  |                            ^^ value borrowed here after move

error<span style=color:#960050;background-color:#1e0010>:</span> aborting due to previous error; 1 warning emitted

<span style=color:#66d9ef>For</span> more information about this error, <span style=color:#66d9ef>try</span> `rustc --explain E0382`.
error<span style=color:#960050;background-color:#1e0010>:</span> could not compile `ownership`

To learn more, run the command again with --verbose.
F:\Code\Rust\rust-study\ownership [master +4 ~0 -0 !]&gt; cargo run
   Compiling ownership v0.1.0 (F:\Code\Rust\rust-study\ownership)
error<span style=color:#66d9ef>[E0382]</span><span style=color:#960050;background-color:#1e0010>:</span> borrow of moved value<span style=color:#960050;background-color:#1e0010>:</span> `s1`
 --&gt; src\main.rs<span style=color:#960050;background-color:#1e0010>:</span>4<span style=color:#960050;background-color:#1e0010>:</span>34
  |
2 |     let s1 = String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |     println!(<span style=color:#e6db74>&#34;s1 = {}, s2 = {}&#34;</span>, s1, s2);
  |                                  ^^ value borrowed here after move

error<span style=color:#960050;background-color:#1e0010>:</span> aborting due to previous error

<span style=color:#66d9ef>For</span> more information about this error, <span style=color:#66d9ef>try</span> `rustc --explain E0382`.
error<span style=color:#960050;background-color:#1e0010>:</span> could not compile `ownership`

To learn more, run the command again with --verbose.
</code></pre></div><h3 id=克隆clone>克隆（Clone）</h3>
<p>Rust 不会自动进行数据的深拷贝（deep copy），因为深拷贝会对程序的性能造成很大的影响。如果我们希望 Rust 进行数据的深拷贝，需要使用 <code>clone</code> 方法。例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
    <span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> s1.clone();
    println!(<span style=color:#e6db74>&#34;s1 = {}, s2 = {}&#34;</span>, s1, s2);
}
</code></pre></div><p>这样一来，<code>s1</code> 和 <code>s2</code> 涉及的数据就是下图中展示的这样了：</p>
<p><img src=/images/rust/trpl04-03.svg alt></p>
<h3 id=栈上数据的复制copy>栈上数据的复制（Copy）</h3>
<p>现在来思考为啥 <code>let x = 5;</code> 或 <code>let x = "5";</code>时代码能够正常运行。这是因为 <code>5</code> 和 <code>"5"</code> 的大小都是固定的，程序编译时就可以知道它们的大小，所以数据被分配在了栈上。而 <strong>Rust 对栈上数据的复制采取的是深拷贝</strong>，深拷贝就不存在移动了。</p>
<p>还记得编译错误“move occurs because <code>s1</code> has type <code>String</code>, which does not implement the <code>Copy</code> trait”吗？Rust 中有一个特殊的注解叫做 <strong><code>Copy</code></strong>。如果某种数据类型实现了 <code>Copy</code>，旧变量在赋值之后仍然是可以使用的。此外，Rust 中还有一个特殊的注解叫做 <strong><code>Drop</code></strong>，它会在变量超出作用域后做些事情。Rust 不允许我们将 <code>Copy</code> 放在了实现了<code>Drop</code> 的类型上，如果我们这么做，编译会失败。</p>
<p>那么，哪些类型实现了 <code>Copy</code> 呢？说实话，有点多，具体的内容可以查看 <a href=https://doc.rust-lang.org/std/marker/trait.Copy.html#>Trait Copy</a>。你会发现，所有的标量类型都实现了 <code>Copy</code>。</p>
<h2 id=所有权与函数>所有权与函数</h2>
<p>传递变量给函数时所有权的变化与变量赋值一样。根据数据类型的不同，可能发生移动（丢失所有权）或复制，下面例子中的注释解释得非常清楚：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);  <span style=color:#75715e>// s comes into scope
</span><span style=color:#75715e></span>
    takes_ownership(s);             <span style=color:#75715e>// s&#39;s value moves into the function...
</span><span style=color:#75715e></span>                                    <span style=color:#75715e>// ... and so is no longer valid here
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;                      <span style=color:#75715e>// x comes into scope
</span><span style=color:#75715e></span>
    makes_copy(x);                  <span style=color:#75715e>// x would move into the function,
</span><span style=color:#75715e></span>                                    <span style=color:#75715e>// but i32 is Copy, so it&#39;s okay to still
</span><span style=color:#75715e></span>                                    <span style=color:#75715e>// use x afterward
</span><span style=color:#75715e></span>
} <span style=color:#75715e>// Here, x goes out of scope, then s. But because s&#39;s value was moved, nothing
</span><span style=color:#75715e></span>  <span style=color:#75715e>// special happens.
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>takes_ownership</span>(some_string: String) { <span style=color:#75715e>// some_string comes into scope
</span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;{}&#34;</span>, some_string);
} <span style=color:#75715e>// Here, some_string goes out of scope and `drop` is called. The backing
</span><span style=color:#75715e></span>  <span style=color:#75715e>// memory is freed.
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>makes_copy</span>(some_integer: <span style=color:#66d9ef>i32</span>) { <span style=color:#75715e>// some_integer comes into scope
</span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;{}&#34;</span>, some_integer);
} <span style=color:#75715e>// Here, some_integer goes out of scope. Nothing special happens.
</span></code></pre></div><p>如果函数带返回值呢？这个时候所有权也会发生转移：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> gives_ownership();         <span style=color:#75715e>// gives_ownership moves its return value into s1
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);     <span style=color:#75715e>// s2 comes into scope
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>let</span> s3 <span style=color:#f92672>=</span> takes_and_gives_back(s2);  <span style=color:#75715e>// s2 is moved into takes_and_gives_back, which also
</span><span style=color:#75715e></span>                                        <span style=color:#75715e>// moves its return value into s3
</span><span style=color:#75715e></span>} <span style=color:#75715e>// Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
</span><span style=color:#75715e></span>  <span style=color:#75715e>// moved, so nothing happens. s1 goes out of scope and is dropped.
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>gives_ownership</span>() -&gt; String {             <span style=color:#75715e>// gives_ownership will move its
</span><span style=color:#75715e></span>                                             <span style=color:#75715e>// return value into the function that calls it
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>let</span> some_string <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>); <span style=color:#75715e>// some_string comes into scope
</span><span style=color:#75715e></span>
    some_string                              <span style=color:#75715e>// some_string is returned and moves out to the calling function
</span><span style=color:#75715e></span>}

<span style=color:#75715e>// takes_and_gives_back will take a String and return one
</span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>takes_and_gives_back</span>(a_string: String) -&gt; String { <span style=color:#75715e>// a_string comes into scope
</span><span style=color:#75715e></span>    a_string  <span style=color:#75715e>// a_string is returned and moves out to the calling function
</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=引用>引用</h2>
<p>如果每次都进行 <code>takes_and_gives_back</code> 这种夺取所有权而后又归还所有权的操作，未免也太过繁琐。幸运的是，Rust 为我们提供了 <strong>引用（reference）</strong>，它可以消除 <code>takes_and_gives_bakc</code> 的尴尬之处。</p>
<p>下面是使用引用的一个例子：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
    <span style=color:#66d9ef>let</span> len <span style=color:#f92672>=</span> calculate_length(<span style=color:#f92672>&amp;</span>s1);
    println!(<span style=color:#e6db74>&#34;The length of &#39;{}&#39; is {}.&#34;</span>, s1, len);
}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>calculate_length</span>(s: <span style=color:#66d9ef>&amp;</span>String) -&gt; <span style=color:#66d9ef>usize</span> {  <span style=color:#75715e>// s is a reference to a String
</span><span style=color:#75715e></span>    s.len()
} <span style=color:#75715e>// Here, s goes out of scope. But because it does not have ownership of what it refers to, nothing happens.
</span></code></pre></div><p>引用允许我们引用某个变量，而不会夺取变量对数据的所有权。引用相关的操作符是 <code>&</code>，与之相反的操作叫解引用（dereferencing），操作符是 <code>*</code>。在以上代码中，<code>&s1</code> 创建了一个指向 <code>s1</code> 的引用，<code>s1</code> 依然持有字符串 <code>"hello"</code> 的所有权。</p>
<p><img src=/images/rust/trpl04-05.svg alt></p>
<p>由于 <code>&s1</code> 不具有数据的所有权，所以当 <code>&s1</code> 超出作用域时，数据不会被丢弃。Rust 将引用作为函数参数的操作称为 <strong>借用（borrowing）</strong>，这有点像现实生活中别人借了我们的东西又归还一样，所有权不会转移。</p>
<p>默认情况下，Rust 是不允许我们修改借用的数据的：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
    change(<span style=color:#f92672>&amp;</span>s);
}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>change</span>(some_string: <span style=color:#66d9ef>&amp;</span>String) {
    some_string.push_str(<span style=color:#e6db74>&#34;, world&#34;</span>);
}
</code></pre></div><p>以上代码会编译失败，并且编译器会告诉我们错误原因，并给出正确的修改建议：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>&gt; cargo run
   Compiling ownership v0.1.0 (F:\Code\Rust\rust-study\ownership)
error<span style=color:#66d9ef>[E0596]</span><span style=color:#960050;background-color:#1e0010>:</span> cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src\main.rs<span style=color:#960050;background-color:#1e0010>:</span>7<span style=color:#960050;background-color:#1e0010>:</span>5
  |
6 | fn change(some_string<span style=color:#960050;background-color:#1e0010>:</span> &amp;String) {
  |                        ------- help<span style=color:#960050;background-color:#1e0010>:</span> consider changing this to be a mutable reference<span style=color:#960050;background-color:#1e0010>:</span> `&amp;mut String`
7 |     some_string.push_str(<span style=color:#e6db74>&#34;, world&#34;</span>);
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

error<span style=color:#960050;background-color:#1e0010>:</span> aborting due to previous error

<span style=color:#66d9ef>For</span> more information about this error, <span style=color:#66d9ef>try</span> `rustc --explain E0596`.
error<span style=color:#960050;background-color:#1e0010>:</span> could not compile `ownership`

To learn more, run the command again with --verbose.
</code></pre></div><h3 id=可变引用>可变引用</h3>
<p>在上面的错误中，编译器建议我们将 <code>change</code> 函数的参数由 <code>&String</code> 修改为 <code>&mut String</code>，即从不可变引用（immutable reference）修改为可变引用（mutable reference）。这操作和普通变量的可变与不可变类似。正确的代码应该是：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
    change(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> s);
}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>change</span>(some_string: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> String) {
    some_string.push_str(<span style=color:#e6db74>&#34;, world&#34;</span>);
}
</code></pre></div><p>这里进行了三处修改：首先将 <code>s</code> 改为可变的 <code>mut s</code>，然后是传递给 <code>change</code> 的参数修改为 <code>&mut s</code>，最后是 <code>change</code> 函数的定义修改为 <code>&mut String</code>，三者缺一不可。</p>
<p>但是，可变引用有一个非常大的限制：<strong>同一时刻，同一数据的可变引用只能有一个，而不可变引用却可以有多个</strong>。例如，下面的代码会编译失败：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
    <span style=color:#66d9ef>let</span> r1 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> s;
    <span style=color:#66d9ef>let</span> r2 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> s;
    println!(<span style=color:#e6db74>&#34;{}, {}&#34;</span>, r1, r2);
}
</code></pre></div><p>编译器简单明了地指出了我的错误：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>&gt; cargo run
   Compiling ownership v0.1.0 (F:\Code\Rust\rust-study\ownership)
error<span style=color:#66d9ef>[E0499]</span><span style=color:#960050;background-color:#1e0010>:</span> cannot borrow `s` as mutable more than once at a time
 --&gt; src\main.rs<span style=color:#960050;background-color:#1e0010>:</span>4<span style=color:#960050;background-color:#1e0010>:</span>14
  |
3 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
4 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
5 |     println!(<span style=color:#e6db74>&#34;{}, {}&#34;</span>, r1, r2);
  |                        -- first borrow later used here

error<span style=color:#960050;background-color:#1e0010>:</span> aborting due to previous error

<span style=color:#66d9ef>For</span> more information about this error, <span style=color:#66d9ef>try</span> `rustc --explain E0499`.
error<span style=color:#960050;background-color:#1e0010>:</span> could not compile `ownership`

To learn more, run the command again with --verbose.
</code></pre></div><p>Rust 这么做的原因是为了防止编译期间的数据竞争（和 Java 并发中的数据竞争类似）。数据竞争会导致程序的行为超出预期，加大运行时诊断问题的难度。</p>
<p>那么应该如何修改上面有问题的代码呢？拆分两个变量的作用域即可：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
    {
      <span style=color:#66d9ef>let</span> r1 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> s;
    }
    <span style=color:#66d9ef>let</span> r2 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> s;
    println!(<span style=color:#e6db74>&#34;{}, {}&#34;</span>, r1, r2);
}
</code></pre></div><p><strong>在 Rust 中，引用的作用域从声明开始，结束于引用最后一次被使用</strong>。Rust 不允许同一份数据在一个作用域内同时出现可变引用和不可变引用的情况。例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);

    <span style=color:#66d9ef>let</span> r1 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s; <span style=color:#75715e>// no problem
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> r2 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s; <span style=color:#75715e>// no problem
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> r3 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> s; <span style=color:#75715e>// BIG PROBLEM
</span><span style=color:#75715e></span>
    println!(<span style=color:#e6db74>&#34;{}, {}, and {}&#34;</span>, r1, r2, r3);
}
</code></pre></div><p>会出现以下编译错误：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>&gt; cargo run  
   Compiling ownership v0.1.0 (F:\Code\Rust\rust-study\ownership)
error<span style=color:#66d9ef>[E0502]</span><span style=color:#960050;background-color:#1e0010>:</span> cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src\main.rs<span style=color:#960050;background-color:#1e0010>:</span>5<span style=color:#960050;background-color:#1e0010>:</span>14
  |
3 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
4 |     let r2 = &amp;s; // no problem
5 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
6 |     println!(<span style=color:#e6db74>&#34;{}, {}, and {}&#34;</span>, r1, r2, r3);
  |                                -- immutable borrow later used here

error<span style=color:#960050;background-color:#1e0010>:</span> aborting due to previous error

<span style=color:#66d9ef>For</span> more information about this error, <span style=color:#66d9ef>try</span> `rustc --explain E0502`.
error<span style=color:#960050;background-color:#1e0010>:</span> could not compile `ownership`

To learn more, run the command again with --verbose.
</code></pre></div><p>但如果我将代码修改为：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
    <span style=color:#66d9ef>let</span> r1 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s; <span style=color:#75715e>// no problem
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> r2 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s; <span style=color:#75715e>// no problem
</span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;{} and {}&#34;</span>, r1, r2);
    <span style=color:#75715e>// variables r1 and r2 will not be used after this point
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> r3 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> s; <span style=color:#75715e>// no problem
</span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;{}&#34;</span>, r3);
}
</code></pre></div><p>程序就能通过编译并正常运行。这是因为，<code>r3</code> 被声明之前，<code>r1</code> 和 <code>r2</code> 的作用域已经结束了，不存在作用域的重叠。</p>
<h2 id=切片slice>切片（Slice）</h2>
<p>切片（slice）允许我们引用集合中的一段连续元素，它是一种没有所有权的数据类型。</p>
<h3 id=字符串切片>字符串切片</h3>
<p>字符串切片（string slice）是一个指向 <code>String</code> 中的一部分内容的引用，这部分内容是原字符串的一个子串。例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello world&#34;</span>);
    <span style=color:#66d9ef>let</span> hello <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>5</span>];   <span style=color:#75715e>// hello
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> world <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>6</span><span style=color:#f92672>..</span><span style=color:#ae81ff>11</span>];  <span style=color:#75715e>// world
</span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;{}, {}&#34;</span>, hello, world); <span style=color:#75715e>// hello, world
</span><span style=color:#75715e></span>}
</code></pre></div><p>在上面这段代码中，<code>hello</code> 和 <code>world</code> 都只引用了 <code>s</code> 中的一部分：</p>
<p><img src=/images/rust/trpl04-06.svg alt></p>
<p>字符串切片类型在 Rust 中用 <code>&str</code> 表示，它比 <code>String</code> 更加灵活。因为 <code>&str</code> 不仅可以引用 <code>String</code> 的一部分，还能引用 <code>String</code> 的所有内容。利用 <code>&str</code>，我们可以编写获取字符串中第一个单词的函数：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>first_word</span>(s: <span style=color:#66d9ef>&amp;</span>String) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> {
    <span style=color:#66d9ef>let</span> bytes <span style=color:#f92672>=</span> s.as_bytes();

    <span style=color:#66d9ef>for</span> (i, <span style=color:#f92672>&amp;</span>item) <span style=color:#66d9ef>in</span> bytes.iter().enumerate() {
        <span style=color:#66d9ef>if</span> item <span style=color:#f92672>==</span> <span style=color:#e6db74>b&#39; &#39;</span> {
            <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>i];
        }
    }
    <span style=color:#f92672>&amp;</span>s[<span style=color:#f92672>..</span>]
}
</code></pre></div><p>现在可以来回答为啥字符串字面量是不可变的这个问题了。因为字符串字面量的数据类型是 <code>&str</code>，而 <code>&str</code> 是不可变引用。</p>
<h3 id=其它类型的切片>其它类型的切片</h3>
<p>除了字符串切片（<code>&str</code>），Rust 中还有很多其它类型的切片，比如数组的切片：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>
<span style=color:#75715e>#![allow(unused)]</span>
<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
<span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
<span style=color:#66d9ef>let</span> slice <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>a[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>3</span>];
assert_eq!(slice, <span style=color:#f92672>&amp;</span>[<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>]);
}
</code></pre></div><p>在以上代码中，<code>slice</code> 是数组 <code>a</code> 的切片，它的数据类型是 <code>&[int32]</code>。</p>
<h2 id=参考资料>参考资料</h2>
<ol>
<li>Steve Klabnik, Carol Nichols. <a href=https://doc.rust-lang.org/stable/book/>The Rust Programming Language</a>.</li>
</ol>
</div>
<footer class=entry-footer>
<div class="container sep-before"><div class=categories><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5A2 2 0 014 3H9l2 3h9a2 2 0 012 2z"/></svg>
<span class=screen-reader-text>分类: </span><a class=category href=/categories/rust/>Rust</a></div>
<div class=tags><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2H12l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=screen-reader-text>标签: </span><a class=tag href=/tags/rust/>Rust</a></div>
</div>
</footer>
</article>
<nav class=entry-nav>
<div class=container><div class="prev-entry sep-before">
<a href=/rust/rust_basics_control_flow/>
<span aria-hidden=true><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="20" y1="12" x2="4" y2="12"/><polyline points="10 18 4 12 10 6"/></svg>
Previous</span>
<span class=screen-reader-text>上一篇: </span>Rust 基础：控制流</a>
</div><div class="next-entry sep-before">
<a href=/rust/rust_basics_struct/>
<span class=screen-reader-text>下一篇: </span>Rust 基础：结构体<span aria-hidden=true>下一个<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="4" y1="12" x2="20" y2="12"/><polyline points="14 6 20 12 14 18"/></svg>
</span>
</a>
</div></div>
</nav>
</main>
<footer id=footer class=footer>
<div class="container sep-before"><section class="widget widget-social_menu sep-after"><nav aria-label=社交菜单>
<ul><li>
<a href=https://github.com/zhannicholas target=_blank rel="noopener me">
<span class=screen-reader-text>Open Github account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a>
</li><li>
<a href=https://t.me/zhannicholas target=_blank rel="noopener me">
<span class=screen-reader-text>Open Telegram account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M23.91 3.79 20.3 20.84c-.25 1.21-.98 1.5-2 .94l-5.5-4.07-2.66 2.57c-.3.3-.55.56-1.1.56-.72.0-.6-.27-.84-.95L6.3 13.7.85 12c-1.18-.35-1.19-1.16.26-1.75l21.26-8.2c.97-.43 1.9.24 1.53 1.73z"/></svg>
</a>
</li><li>
<a href=mailto:zhan_nicholas@outlook.com target=_blank rel="noopener me">
<span class=screen-reader-text>Contact via Email</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
</a>
</li><li>
<a href=https://linkedin.com/in/%e4%bc%9f%e4%bc%9f-%e8%a9%b9-27871a104 target=_blank rel="noopener me">
<span class=screen-reader-text>Open Linkedin account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg>
</a>
</li></ul>
</nav>
</section><div class=copyright>
<p> &copy; 2018-2021 Nicholas Zhan </p>
</div>
</div>
</footer>
</div>
</div><script>window.__assets_js_src="/assets/js/"</script>
<script src=/assets/js/main.c3bcf2df.js></script><script src=/js/custom.js></script>
</body>
</html>