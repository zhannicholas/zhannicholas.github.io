<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类就是单例类。 从单例模式"><meta name=theme-color content="#ffcd00"><meta property="og:title" content="《设计模式的艺术》读书笔记一：单例模式 • Nicholas Zhan"><meta property="og:description" content="单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类就是单例类。 从单例模式"><meta property="og:url" content="https://zhannicholas.github.io/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"><meta property="og:site_name" content="Nicholas Zhan"><meta property="og:type" content="article"><meta property="og:image" content="https://www.gravatar.com/avatar/85f2cc2a45fd9533b91a65214224f9d7?s=256"><meta property="article:section" content="reading_notes"><meta property="article:tag" content="设计模式"><meta property="article:published_time" content="2018-10-01T13:28:15+08:00"><meta property="article:modified_time" content="2018-10-01T13:28:15+08:00"><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.81.0"><title>《设计模式的艺术》读书笔记一：单例模式 • Nicholas Zhan</title><link rel=canonical href=https://zhannicholas.github.io/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/assets/css/main.ab98e12b.css><link rel=stylesheet href=/css/custom.css><style>:root{--color-accent:#ffcd00}</style></head><body class="page type-reading_notes has-sidebar"><div class=site><div id=sidebar class=sidebar><a class=screen-reader-text href=#main-menu>跳到主菜单</a><div class=container><section class="widget widget-about sep-after"><header><div class=logo><a href=/><img src=/images/logo.png></a></div><h2 class="title site-title"><a href=/>Nicholas Zhan</a></h2><div class=desc>Java Developer, Runner, Cyclist</div></header></section><section class="widget widget-sidebar_menu sep-after"><nav id=sidebar-menu class="menu sidebar-menu" aria-label=侧边栏菜单><div class=container><ul><li class="item has-children"><a href=/posts/databases/>Database</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/posts/databases/redis/>Redis</a></li><li class=item><a href=/posts/databases/fundamentals/>基础理论</a></li></ul></li><li class="item has-children"><a href=/posts/java/>Java</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/posts/java/jakartaee/>Jakarta EE</a></li><li class=item><a href=/posts/java/jvm/>JVM</a></li><li class=item><a href=/posts/java/concurrency/>并发</a></li></ul></li><li class="item has-children"><a href=/posts/operating_systems/>操作系统</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/posts/operating_systems/memory_management/>内存管理</a></li><li class=item><a href=/posts/operating_systems/virtualization/>虚拟化</a></li><li class=item><a href=/posts/operating_systems/processes_management/>进程管理</a></li></ul></li><li class="item has-children"><a href=/posts/computer_networks/>计算机网络</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/posts/computer_networks/http/>HTTP</a></li><li class=item><a href=/posts/computer_networks/fundamentals/>基础知识</a></li></ul></li><li class="item has-children"><a href=/reading_notes/>读书笔记</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/reading_notes/algorithms_in_c/>C算法</a></li><li class=item><a href=/reading_notes/ostep/>OSTEP</a></li><li class=item><a href=/reading_notes/sicp_in_python/>SICP in Python</a></li><li class=item><a href=/reading_notes/the_art_of_multiprocessor_programming/>多处理器编程的艺术</a></li><li class=item><a href=/reading_notes/modern_operating_systems/>现代操作系统</a></li><li class=item><a href=/reading_notes/introduction_to_algorithms/>算法导论</a></li><li class=item><a href=/reading_notes/%E7%AE%97%E6%B3%95%E8%B6%A3%E9%A2%98/>算法趣题</a></li><li class=item><a href=/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/>设计模式的艺术</a></li></ul></li></ul></div></nav></section><section class="widget widget-taxonomy_cloud sep-after"><header><h4 class="title widget-title">分类</h4></header><div class="container list-container"><ul class="list taxonomy-cloud"><li><a href=/categories/db/ style=font-size:1.1818181818181819em>DB</a></li><li><a href=/categories/java/ style=font-size:1.5151515151515151em>Java</a></li><li><a href=/categories/leetcode/ style=font-size:1.0606060606060606em>Leetcode</a></li><li><a href=/categories/linux/ style=font-size:1em>Linux</a></li><li><a href=/categories/networks/ style=font-size:1.303030303030303em>Networks</a></li><li><a href=/categories/notebook/ style=font-size:1em>Notebook</a></li><li><a href=/categories/os/ style=font-size:1.1515151515151516em>OS</a></li><li><a href=/categories/tools/ style=font-size:1em>Tools</a></li><li><a href=/categories/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/ style=font-size:1.0606060606060606em>新手上路</a></li><li><a href=/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ style=font-size:2em>读书笔记</a></li></ul></div></section></div><div class=sidebar-overlay></div></div><div class=main><a class=screen-reader-text href=#content>跳到内容</a>
<button id=sidebar-toggler class=sidebar-toggler aria-controls=sidebar>
<span class=screen-reader-text>Toggle Sidebar</span>
<span class=open><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></span><span class=close><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span></button><div class=header-widgets><div class=container><style>.widget-breadcrumbs li:after{content:'\2f '}</style><section class="widget widget-breadcrumbs sep-after"><nav id=breadcrumbs><ol><li><a href=/>Home</a></li><li><a href=/reading_notes/>读书笔记</a></li><li><a href=/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/>设计模式的艺术</a></li><li><span>《设计模式的艺术》读书笔记一：单例模式</span></li></ol></nav></section></div></div><header id=header class="header site-header"><div class="container sep-after"><div class=header-info><p class="site-title title">Nicholas Zhan</p><p class="desc site-desc">Java Developer, Runner, Cyclist</p></div></div></header><main id=content><article lang=zh-cn class=entry><header class="header entry-header"><div class="container sep-after"><div class=header-info><h1 class=title>《设计模式的艺术》读书笔记一：单例模式</h1></div><div class=entry-meta><span class=posted-on><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg><span class=screen-reader-text>Posted on</span>
<time class=entry-date datetime=2018-10-01T13:28:15+08:00>2018, Oct 01</time></span>
<span class=byline><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M21 21V20c0-2.76-4-5-9-5s-9 2.24-9 5v1"/><path d="M16 6.37A4 4 0 1112.63 3 4 4 0 0116 6.37z"/></svg><span class=screen-reader-text>by </span><a href=/authors/zhannicholas>Nicholas Zhan</a></span>
<span class=reading-time><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 15 15"/></svg>4 mins read</span></div></div></header><details class="container entry-toc"><summary class=title><span>目录</span></summary><nav id=TableOfContents></nav></details><div class="container entry-content"><blockquote><p>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类就是单例类。</p></blockquote><p>从单例模式的定义来看，它有3个要点：</p><ol><li>它只有唯一一个实例；</li><li>它必须自行创建这个实例；</li><li>它必须向整个系统提供这个实例；</li></ol><h1 id=基本实现方案>基本实现方案</h1><ol><li>将构造函数设为私有，确保外界无法通过 new 创建该对象；</li><li>提供公有的静态方法，返回单例类的唯一实例，供外界访问；</li><li>创建唯一的实例，并通过公有的静态方法返回；</li></ol><p>单例模式的结构图如下：</p><p><img src=/images/design-patterns/Singleton.jpg alt=Singleton title=单例模式结构图></p><p>根据这个图，可以很容易写出对应的代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>// 单例类
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Singleton</span> <span style=color:#f92672>{</span>
    <span style=color:#75715e>// 私有静态成员变量
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Singleton instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>

    <span style=color:#75715e>// 私有构造函数
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Singleton</span><span style=color:#f92672>(){}</span>

    <span style=color:#75715e>// 公有静态成员方法，返回单例
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Singleton <span style=color:#a6e22e>getInstance</span><span style=color:#f92672>(){</span>
        <span style=color:#66d9ef>if</span><span style=color:#f92672>(</span>instance <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
            instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton<span style=color:#f92672>();</span>
        <span style=color:#66d9ef>return</span> instance<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h1 id=饿汉式单例类eager-singleton>饿汉式单例类(Eager Singleton)</h1><p>饿汉式单例类的结构图如下：</p><p><img src=/images/design-patterns/EagerSingleton.jpg alt=EagerSingleton title=饿汉式单例结构图></p><p>从图中可以看出，当类 <strong>加载</strong> 的时候，静态变量<code>instance</code>就会被初始化，此时会调用私有的构造函数创建类的唯一实例。代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#75715e>// 饿汉式单例类
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EagerSingleton</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> EagerSingleton instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> EagerSingleton<span style=color:#f92672>();</span>
    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>EagerSingleton</span><span style=color:#f92672>(){}</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> EagerSingleton <span style=color:#a6e22e>getInstance</span><span style=color:#f92672>(){</span>
        <span style=color:#66d9ef>return</span> instance<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h1 id=懒汉式单例类lazy-singleton>懒汉式单例类(Lazy Singleton)</h1><p>懒汉式单例类的结构图如下：</p><p><img src=/images/design-patterns/LazySingleton.jpg alt=EagerSingleton title=懒汉式单例结构图></p><p>从图中可以看出，和饿汉式单例不同的是：懒汉式单例在类加载的时候不实例化，而是第一次调用<code>getInstance()</code>的时候才被实例化。这就是 <strong>延迟加载（Lazy Load）技术</strong> ，也就是在需要的时候才加载实例。在Java中，为了避免多个县城同时调用<code>getInstance()</code>方法，可以使用关键字 <strong><code>synchronized</code></strong> 进行线程锁定 。代码如下（这个方法有缺陷）：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#75715e>// 有缺陷的懒汉类
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LazySingleton1</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> LazySingleton1 instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>LazySingleton1</span><span style=color:#f92672>(){}</span>
    <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> LazySingleton1 <span style=color:#a6e22e>getInstance</span><span style=color:#f92672>(){</span>
        <span style=color:#66d9ef>if</span><span style=color:#f92672>(</span>instance <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
            instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LazySingleton1<span style=color:#f92672>();</span>
        <span style=color:#66d9ef>return</span> instance<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>上面的代码中， <strong><code>synchronized</code></strong> 锁定了整个<code>getInstance()</code>方法，会影响系统的性能，一个改进的方法是：只锁定创建实例的那一行代码。修改后的<code>getInstance()</code>方法如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> LazySingleton1 <span style=color:#a6e22e>getInstance</span><span style=color:#f92672>(){</span>
        <span style=color:#66d9ef>if</span><span style=color:#f92672>(</span>instance <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>){</span>
            <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span>LazySingleton1<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>){</span>
                instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LazySingleton1<span style=color:#f92672>();</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>return</span> instance<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
</code></pre></div><p>上面的代码看似解决了问题，然而并没有。考虑某一瞬间，如果多个线程同时调用<code>getInstance()</code>方法，如果此时<code>instance == null</code>,这些线程就都能通过<code>if</code>语句的判断。由于使用了<code>synchronized</code>，后面的线程会处于排队等待的状态。当前面的线程执行完由<code>synchronized</code>锁定的代码之后，实例已经被创建，而后面的线程此时并不知道实例已经被创建的事实，天真的创建了新的实例。如此一来，系统中就会出现多个单例对象，这就违背了单例模式的设计思想。一个可行的解决方案是：采用 <strong>双重检查锁定（Double-Check Locking）</strong> 。也就是在<code>synchronized</code>锁定的代码中再进行一次<code>instance == null</code> 的判断，这样后面的线程就不会通过新的判断条件，也就不会新建线程了。使用双重锁定需要使用Java中的<code>volatile</code>关键字，被它修饰的成员变量可以确保多个线程都能正确处理。修改后的代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#75715e>// 采用双重检查锁定的懒汉类
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LazySingleton2</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>static</span> LazySingleton2 instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>LazySingleton2</span><span style=color:#f92672>(){}</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> LazySingleton2 <span style=color:#a6e22e>getInstance</span><span style=color:#f92672>(){</span>
        <span style=color:#66d9ef>if</span><span style=color:#f92672>(</span>instance <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>){</span>   <span style=color:#75715e>// 第一重判断
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span>LazySingleton2<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>){</span>
                <span style=color:#66d9ef>if</span><span style=color:#f92672>(</span>instance <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>){</span>   <span style=color:#75715e>// 第二重判断
</span><span style=color:#75715e></span>                    instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LazySingleton2<span style=color:#f92672>();</span>
                <span style=color:#f92672>}</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>return</span> instance<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>由于使用<code>volatile</code>关键字会屏蔽JVM所做的一些代码优化，因此使用DCL来实现单例模式也不够完美。一种更好的实现方法是：采用 <strong><code>IoDH技术</code></strong> 。</p><h1 id=采用iodh技术实现单例模式>采用IoDH技术实现单例模式</h1><p><strong>Initialization on Demand Holder(IoDH)技术</strong> 克服饿汉类单例和懒汉类单例的缺点，既能实现延迟加载，又能保证线程安全。在实现的时候，需要在单例类添加一个 <strong>静态内部类</strong> ，然后在这个静态内部类中创建单例对象，再将该单例对象返回给外界使用。代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#75715e>// 使用IoDH技术实现
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BetterSingleton</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>BetterSingleton</span><span style=color:#f92672>(){}</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HolderClass</span><span style=color:#f92672>{</span>
        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>static</span> BetterSingleton instance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BetterSingleton<span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> BetterSingleton <span style=color:#a6e22e>getInstance</span><span style=color:#f92672>(){</span>
        <span style=color:#66d9ef>return</span> HolderClass<span style=color:#f92672>.</span><span style=color:#a6e22e>instance</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h1 id=总结>总结</h1><p>一篇读书笔记下来，对单例模式的理解更是加深了不少，尤其是双重检查锁定机制。总的来说：单例模式适用于系统只需要一个实例对象或者只能通过一个公共访问点访问单个实例的情况。采用单例模式，能够实现对唯一实例的访问，由于只有一个实例，减少了对系统资源的占用，不失为一种节约系统资源的好方式。但是，单例模式缺乏抽象层，不利于扩展和代码的复用。还有就是，单例类通常具有很多职责，这违背了SRP。</p></div><footer class=entry-footer><div class="container sep-before"><div class=categories><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5A2 2 0 014 3H9l2 3h9a2 2 0 012 2z"/></svg><span class=screen-reader-text>分类: </span><a class=category href=/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a></div><div class=tags><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2H12l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=screen-reader-text>标签: </span><a class=tag href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></div></div></footer></article><nav class=entry-nav><div class=container><div class="prev-entry sep-before"><a href=/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%847%E4%B8%AA%E5%8E%9F%E5%88%99/><span aria-hidden=true><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="20" y1="12" x2="4" y2="12"/><polyline points="10 18 4 12 10 6"/></svg>Previous</span>
<span class=screen-reader-text>上一篇: </span>面向对象设计的7个原则</a></div><div class="next-entry sep-before"><a href=/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/><span class=screen-reader-text>下一篇: </span>《设计模式的艺术》读书笔记二：简单工厂模式<span aria-hidden=true>下一个<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="4" y1="12" x2="20" y2="12"/><polyline points="14 6 20 12 14 18"/></svg></span></a></div></div></nav></main><footer id=footer class=footer><div class="container sep-before"><section class="widget widget-social_menu sep-after"><nav aria-label=社交菜单><ul><li><a href=https://github.com/zhannicholas target=_blank rel="noopener me"><span class=screen-reader-text>Open Github account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li><a href=https://t.me/zhannicholas target=_blank rel="noopener me"><span class=screen-reader-text>Open Telegram account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><title>Telegram icon</title><path d="M23.91 3.79 20.3 20.84c-.25 1.21-.98 1.5-2 .94l-5.5-4.07-2.66 2.57c-.3.3-.55.56-1.1.56-.72.0-.6-.27-.84-.95L6.3 13.7.85 12c-1.18-.35-1.19-1.16.26-1.75l21.26-8.2c.97-.43 1.9.24 1.53 1.73z"/></svg></a></li><li><a href=mailto:zhan_nicholas@outlook.com target=_blank rel="noopener me"><span class=screen-reader-text>Contact via Email</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></li><li><a href=https://linkedin.com/in/%e4%bc%9f%e4%bc%9f-%e8%a9%b9-27871a104 target=_blank rel="noopener me"><span class=screen-reader-text>Open Linkedin account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li></ul></nav></section><div class=copyright><p>&copy; 2018-2021 Nicholas Zhan</p></div></div></footer></div></div><script>window.__assets_js_src="/assets/js/"</script><script src=/assets/js/main.c3bcf2df.js></script><script src=/js/custom.js></script></body></html>