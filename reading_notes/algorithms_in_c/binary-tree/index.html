<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="树是满足一定要求的顶点和边的非空集合。 二叉树 二叉树的每个节点至多有2个子节点。 一种表示方法： struct Node{type key; Node *lchild, *richild;} typedef Node *link; 这种表示方法只适合从根节点开始"><meta name=theme-color content="#ffcd00"><meta property="og:title" content="树 • Nicholas Zhan"><meta property="og:description" content="树是满足一定要求的顶点和边的非空集合。 二叉树 二叉树的每个节点至多有2个子节点。 一种表示方法： struct Node{type key; Node *lchild, *richild;} typedef Node *link; 这种表示方法只适合从根节点开始"><meta property="og:url" content="https://zhannicholas.github.io/reading_notes/algorithms_in_c/binary-tree/"><meta property="og:site_name" content="Nicholas Zhan"><meta property="og:type" content="article"><meta property="og:image" content="https://www.gravatar.com/avatar/85f2cc2a45fd9533b91a65214224f9d7?s=256"><meta property="article:section" content="reading_notes"><meta property="article:tag" content="C算法"><meta property="article:published_time" content="2018-06-02T10:07:28+08:00"><meta property="article:modified_time" content="2018-06-02T10:07:28+08:00"><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.81.0"><title>树 • Nicholas Zhan</title><link rel=canonical href=https://zhannicholas.github.io/reading_notes/algorithms_in_c/binary-tree/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/assets/css/main.ab98e12b.css><link rel=stylesheet href=/css/custom.css><style>:root{--color-accent:#ffcd00}</style></head><body class="page type-reading_notes has-sidebar"><div class=site><div id=sidebar class=sidebar><a class=screen-reader-text href=#main-menu>跳到主菜单</a><div class=container><section class="widget widget-about sep-after"><header><div class=logo><a href=/><img src=/images/logo.png></a></div><h2 class="title site-title"><a href=/>Nicholas Zhan</a></h2><div class=desc>Java Developer, Runner, Cyclist</div></header></section><section class="widget widget-sidebar_menu sep-after"><nav id=sidebar-menu class="menu sidebar-menu" aria-label=侧边栏菜单><div class=container><ul><li class="item has-children"><a href=/posts/databases/>Database</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/posts/databases/redis/>Redis</a></li><li class=item><a href=/posts/databases/fundamentals/>基础理论</a></li></ul></li><li class="item has-children"><a href=/posts/java/>Java</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/posts/java/jakartaee/>Jakarta EE</a></li><li class=item><a href=/posts/java/concurrency/>Java并发</a></li><li class=item><a href=/posts/java/java_lang/>Java语言</a></li><li class=item><a href=/posts/java/jvm/>JVM</a></li></ul></li><li class="item has-children"><a href=/posts/operating_systems/>操作系统</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/posts/operating_systems/memory_management/>内存管理</a></li><li class=item><a href=/posts/operating_systems/virtualization/>虚拟化</a></li><li class=item><a href=/posts/operating_systems/processes_management/>进程管理</a></li></ul></li><li class="item has-children"><a href=/posts/computer_networks/>计算机网络</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/posts/computer_networks/http/>HTTP</a></li><li class=item><a href=/posts/computer_networks/fundamentals/>基础知识</a></li></ul></li><li class="item has-children"><a href=/reading_notes/>读书笔记</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/reading_notes/algorithms_in_c/>C算法</a></li><li class=item><a href=/reading_notes/ostep/>OSTEP</a></li><li class=item><a href=/reading_notes/sicp_in_python/>SICP in Python</a></li><li class=item><a href=/reading_notes/the_art_of_multiprocessor_programming/>多处理器编程的艺术</a></li><li class=item><a href=/reading_notes/modern_operating_systems/>现代操作系统</a></li><li class=item><a href=/reading_notes/introduction_to_algorithms/>算法导论</a></li><li class=item><a href=/reading_notes/%E7%AE%97%E6%B3%95%E8%B6%A3%E9%A2%98/>算法趣题</a></li><li class=item><a href=/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/>设计模式的艺术</a></li></ul></li></ul></div></nav></section><section class="widget widget-taxonomy_cloud sep-after"><header><h4 class="title widget-title">分类</h4></header><div class="container list-container"><ul class="list taxonomy-cloud"><li><a href=/categories/db/ style=font-size:1.1818181818181819em>DB</a></li><li><a href=/categories/java/ style=font-size:1.4545454545454546em>Java</a></li><li><a href=/categories/leetcode/ style=font-size:1.0606060606060606em>Leetcode</a></li><li><a href=/categories/linux/ style=font-size:1em>Linux</a></li><li><a href=/categories/networks/ style=font-size:1.303030303030303em>Networks</a></li><li><a href=/categories/os/ style=font-size:1.1515151515151516em>OS</a></li><li><a href=/categories/tools/ style=font-size:1em>Tools</a></li><li><a href=/categories/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/ style=font-size:1.0606060606060606em>新手上路</a></li><li><a href=/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ style=font-size:2em>读书笔记</a></li></ul></div></section></div><div class=sidebar-overlay></div></div><div class=main><a class=screen-reader-text href=#content>跳到内容</a>
<button id=sidebar-toggler class=sidebar-toggler aria-controls=sidebar>
<span class=screen-reader-text>Toggle Sidebar</span>
<span class=open><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></span><span class=close><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span></button><div class=header-widgets><div class=container><style>.widget-breadcrumbs li:after{content:'\2f '}</style><section class="widget widget-breadcrumbs sep-after"><nav id=breadcrumbs><ol><li><a href=/>Home</a></li><li><a href=/reading_notes/>读书笔记</a></li><li><a href=/reading_notes/algorithms_in_c/>C算法</a></li><li><span>树</span></li></ol></nav></section></div></div><header id=header class="header site-header"><div class="container sep-after"><div class=header-info><p class="site-title title">Nicholas Zhan</p><p class="desc site-desc">Java Developer, Runner, Cyclist</p></div></div></header><main id=content><article lang=zh-cn class=entry><header class="header entry-header"><div class="container sep-after"><div class=header-info><h1 class=title>树</h1></div><div class=entry-meta><span class=posted-on><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg><span class=screen-reader-text>Posted on</span>
<time class=entry-date datetime=2018-06-02T10:07:28+08:00>2018, Jun 02</time></span>
<span class=byline><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M21 21V20c0-2.76-4-5-9-5s-9 2.24-9 5v1"/><path d="M16 6.37A4 4 0 1112.63 3 4 4 0 0116 6.37z"/></svg><span class=screen-reader-text>by </span><a href=/authors/zhannicholas>Nicholas Zhan</a></span>
<span class=reading-time><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 15 15"/></svg>8 mins read</span></div></div></header><details class="container entry-toc"><summary class=title><span>目录</span></summary><nav id=TableOfContents><ul><li><a href=#二叉树的一些数学性质>二叉树的一些数学性质</a></li><li><a href=#树的遍历>树的遍历</a></li><li><a href=#二叉搜索树>二叉搜索树</a><ul><li><a href=#二叉搜索树中的查找>二叉搜索树中的查找</a></li><li><a href=#在二叉搜索树中插入节点>在二叉搜索树中插入节点</a></li><li><a href=#在二叉搜索树中选择节点>在二叉搜索树中选择节点</a></li><li><a href=#对二叉搜索树进行划分>对二叉搜索树进行划分</a></li><li><a href=#在二叉搜索树中删除节点>在二叉搜索树中删除节点</a></li><li><a href=#合并两棵二叉搜索树>合并两棵二叉搜索树</a></li></ul></li><li><a href=#2-3-4树>2-3-4树</a><ul><li><a href=#节点的插入处理>节点的插入处理</a></li></ul></li><li><a href=#红黑树>红黑树</a></li></ul></nav></details><div class="container entry-content"><p>树是满足一定要求的顶点和边的非空集合。</p><h1 id=二叉树>二叉树</h1><p>二叉树的每个节点至多有2个子节点。
一种表示方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span>{type key; Node <span style=color:#f92672>*</span>lchild, <span style=color:#f92672>*</span>richild;}
<span style=color:#66d9ef>typedef</span> Node <span style=color:#f92672>*</span>link;
</code></pre></div><p>这种表示方法只适合从根节点开始自顶向下的操作，而不适合自底向上的操作。不过可以在节点的定义中加入指向父节点的连接支持这种功能。
与二叉树类似的还有M叉树，它的每个节点最多只有M个节点。广义的树每个节点可以有任意多个子节点，可以用二叉树来表示它们，方法就是——“左孩子，右兄弟”。树的序列就形成了有序森林。</p><blockquote><p>二叉树和有序森林之间存在一一的对应关系。</p></blockquote><h2 id=二叉树的一些数学性质>二叉树的一些数学性质</h2><ul><li>一棵二叉树有 <strong><code>N</code></strong> 个内部节点，有 <strong><code>N + 1</code></strong> 个外部节点（叶子节点）。</li><li>包含 <strong><code>N</code></strong> 个内部节点的二叉树有 <strong><code>2N</code></strong> 个链接： <strong><code>N - 1</code></strong> 个外部节点的链接和 <strong><code>N + 1</code></strong> 个内部节点的链接。</li><li>树中节点的所在的层是它的父节点的下一层（根节点位于第 <strong><code>0</code></strong> 层）。树的高度为树节点的最大层。树的路径长度为所有树节点的层总和：外部路径长度为所有外部节点的层总和，内部路径长度为所有内部节点的层总和。
这里有一个计算树路径长度的简便方法：对于所有的 <strong><code>k</code></strong> , 求 <strong><code>k</code></strong> 与 <strong><code>k</code></strong> 层节点数之积的总和。</li><li>具有 <strong><code>N</code></strong> 个内部节点的二叉树的外部路径长度比内部路径长度大 <strong><code>2N</code></strong> 。</li><li>具有 <strong><code>N</code></strong> 个内部节点的二叉树的高度的最小值为 <strong><code>lgN</code></strong> ，最大值为 <strong><code>N - 1</code></strong> 。
当树退化成只有一个叶子节点的时候，就是最坏的情况。</li><li>具有 <strong><code>N</code></strong> 个内部节点的二叉树内部路径长度最小值为 <strong><code>Nlg(N/4)</code></strong> ，最大值为 <strong><code>N(N - 1)/2</code></strong> 。</li></ul><h2 id=树的遍历>树的遍历</h2><ul><li>前序遍历
根->左孩子->右孩子</li><li>中序遍历
左孩子->根->右孩子</li><li>后序遍历
左孩子->右孩子->根</li><li>层次遍历
从上到下，从左到右</li></ul><p>前序遍历（递归版）：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>preorderTraverse</span>(link h, <span style=color:#66d9ef>void</span> visit(link)){
    <span style=color:#66d9ef>if</span>(h <span style=color:#f92672>==</span> root) <span style=color:#66d9ef>return</span>;
    visit(h);
    preorderTraverse(h <span style=color:#f92672>-&gt;</span> lchild, visit);
    preorderTraverse(h <span style=color:#f92672>-&gt;</span> rchild, visit);
}
</code></pre></div><p>前序遍历（非递归版）：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>preorderTraverse</span>(link h, <span style=color:#66d9ef>void</span> visit(link)){
    stack<span style=color:#f92672>&lt;</span>link<span style=color:#f92672>&gt;</span> stk(maxn);
    s.push(h);
    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>s.empty()){
        visit(s.top());
        s.pop();
        <span style=color:#66d9ef>if</span>(h <span style=color:#f92672>-&gt;</span> lchild <span style=color:#f92672>!=</span> null) s.push(h <span style=color:#f92672>-&gt;</span> lchild);
        <span style=color:#66d9ef>if</span>(h <span style=color:#f92672>-&gt;</span> rchild <span style=color:#f92672>!=</span> null) s.push(h <span style=color:#f92672>-&gt;</span> rchild);
    }
}
</code></pre></div><p>后序遍历和中序遍历只需要交换前序遍历中访问节点的顺序即可。
层次遍历：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>levelTraverse</span>(link h, <span style=color:#66d9ef>void</span> visit(link)){
    queue<span style=color:#f92672>&lt;</span>link<span style=color:#f92672>&gt;</span> q(maxn);
    q.push(h);
    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>q.empty()){
        visit(q.front());
        q.pop();
        <span style=color:#66d9ef>if</span>(h <span style=color:#f92672>-&gt;</span> lchild <span style=color:#f92672>!=</span> null) q.push(q <span style=color:#f92672>-&gt;</span> lchild);
        <span style=color:#66d9ef>if</span>(h <span style=color:#f92672>-&gt;</span> rchild <span style=color:#f92672>!=</span> null) q.push(q <span style=color:#f92672>-&gt;</span> rchild);
    }
}
</code></pre></div><p>计算树含有的节点数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>count</span>(link h){
    <span style=color:#66d9ef>if</span>(h <span style=color:#f92672>==</span> null) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>return</span> count(h <span style=color:#f92672>-&gt;</span> lchild) <span style=color:#f92672>+</span> count(h <span style=color:#f92672>-&gt;</span> rchild) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
}
</code></pre></div><p>计算树的高度：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>height</span>(link h){
    <span style=color:#66d9ef>if</span>(h <span style=color:#f92672>==</span> null) <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>return</span> max(height(h <span style=color:#f92672>-&gt;</span> lchild), height(h <span style=color:#f92672>-&gt;</span> rchild)) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
}
</code></pre></div><h2 id=二叉搜索树>二叉搜索树</h2><p>二叉树搜索树是一棵二叉树，它要么是一棵空树，要么具有以下性质：</p><ol><li>若任意节点的左子树不为空，则左子树上所有节点的值不大于它的根节点的值</li><li>若任意节点的右子树不为空，则右子树上所有节点的值不小于它的根节点的值</li><li>任意节点的左右子树都是二叉搜索树</li><li>树中没有键值相等的节点</li></ol><h3 id=二叉搜索树中的查找>二叉搜索树中的查找</h3><p>在二叉搜索树h中查找v的过程如下：</p><ol><li>若h是空树，则返回查找失败，否则：</li><li>若x为根节点对应的数据值，则查找成功，否则：</li><li>若x小于根节点对应的数据值，则查找左子树，否则：</li><li>查找右子树</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++>Item <span style=color:#a6e22e>searchP</span>(link h, type v){
    <span style=color:#66d9ef>if</span>(h <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> nullItem;
    type t <span style=color:#f92672>=</span> h <span style=color:#f92672>-&gt;</span> item.getKey();
    <span style=color:#66d9ef>if</span>(t <span style=color:#f92672>==</span> v) <span style=color:#66d9ef>return</span> h <span style=color:#f92672>-&gt;</span> item;
    <span style=color:#66d9ef>if</span>(v <span style=color:#f92672>&lt;</span> t) searchP(h <span style=color:#f92672>-&gt;</span> lchild, v);
    <span style=color:#66d9ef>else</span> searchP(h <span style=color:#f92672>-&gt;</span> rchild, v);
}
</code></pre></div><h3 id=在二叉搜索树中插入节点>在二叉搜索树中插入节点</h3><p>在二叉搜索树h中插入节点v的过程如下，其中插入的节点总是叶子节点：</p><ol><li>若h是空树，则将v所指的节点作为根节点插入，否则：</li><li>若v对应的数据值小于根节点对应的数据值，则在左子树中插入，否则：</li><li>在右子树中插入</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insertP</span>(link <span style=color:#f92672>&amp;</span>h, Item x){
    <span style=color:#66d9ef>if</span>(h <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {h <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node(x);<span style=color:#66d9ef>return</span>;}
    <span style=color:#66d9ef>if</span>(x.getKey() <span style=color:#f92672>&lt;</span> h <span style=color:#f92672>-&gt;</span> item.getKey()) insertP(h <span style=color:#f92672>-&gt;</span> lchild, x);
    <span style=color:#66d9ef>else</span> insertP(h <span style=color:#f92672>-&gt;</span> rchild, x);
}
</code></pre></div><p>上面的插入只适用于插入的节点最终是叶子节点的情况，可以通过这种方式来构造一棵树来对数据进行排序。对于插入的节点不一定到达叶子节点的情况，需要考虑其它的插入方法。旋转是树的一种基本变换，它允许交换树中根及其一个孩子的角色，同时保持节点中键的次序。
涉及到3个链接和两个节点。</p><blockquote><p>右旋（<strong>左孩子为轴，当前节点右旋</strong>）。结果就是：原来的左孩子成为了新的根，原来左孩子的左孩子依旧是新根的左孩子，旧根的右孩子依旧是旧根的右孩子。旧根成为了新根的右孩子，原来左孩子的右孩子成为了旧根（新根的右孩子）的左孩子。</p></blockquote><p><img src=/images/algorithms_in_c/rotateR.jpg alt=rotateR></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rotateR</span>(link <span style=color:#f92672>&amp;</span>h){
    link t <span style=color:#f92672>=</span> h <span style=color:#f92672>-&gt;</span> lchild;
    h <span style=color:#f92672>-&gt;</span> lchild <span style=color:#f92672>=</span> t <span style=color:#f92672>-&gt;</span> rchild;
    t <span style=color:#f92672>-&gt;</span> rchild <span style=color:#f92672>=</span> h;
    h <span style=color:#f92672>=</span> t;
}
</code></pre></div><blockquote><p>左旋和右旋相反。<strong>右孩子为轴，当前节点左旋</strong>。原来的右孩子成为了新的根，旧根成为了新根的左孩子。原来的右孩子的左孩子成为了旧根的右孩子。</p></blockquote><p><img src=/images/algorithms_in_c/rotateL.jpg alt=rotateL></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rotateL</span>(link <span style=color:#f92672>&amp;</span>h){
    link t <span style=color:#f92672>=</span> h <span style=color:#f92672>-&gt;</span> rchild;
    h <span style=color:#f92672>-&gt;</span> rchild <span style=color:#f92672>=</span> h <span style=color:#f92672>-&gt;</span> lchild;
    t <span style=color:#f92672>-&gt;</span> lchild <span style=color:#f92672>=</span> h;
    h <span style=color:#f92672>=</span> t;
}
</code></pre></div><p>有了左旋和右旋之后，就能迅速得到在BST的根插入新节点的递归函数，再适当子树的根插入新项，然后通过旋转将它带到主树的根。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insertT</span>(link <span style=color:#f92672>&amp;</span>h, Item x){
    <span style=color:#66d9ef>if</span>(h <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>){h <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node(x);<span style=color:#66d9ef>return</span>;}
    <span style=color:#66d9ef>if</span>(x.getKey() <span style=color:#f92672>&lt;</span> h <span style=color:#f92672>-&gt;</span> item.getkey()){insertT(h <span style=color:#f92672>-&gt;</span> lchild, x); rotateR(h);}
    <span style=color:#66d9ef>else</span>{insertT(h <span style=color:#f92672>-&gt;</span> rchild,x); rotateL(h);}
}
</code></pre></div><h3 id=在二叉搜索树中选择节点>在二叉搜索树中选择节点</h3><p>可以采用快速排序划分的思想来选择BST中第 <strong><code>k</code></strong> 小的节点。不过这需要给结点增加一个计数域，然后还需要修改其他所有的函数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++>Item <span style=color:#a6e22e>selectR</span>(link h, <span style=color:#66d9ef>int</span> k){
    <span style=color:#66d9ef>if</span>(h <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> nullItem;
    <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> (h <span style=color:#f92672>-&gt;</span> lchild <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>:</span> h <span style=color:#f92672>-&gt;</span> lchild <span style=color:#f92672>-&gt;</span> cnt;
    <span style=color:#66d9ef>if</span>(c <span style=color:#f92672>&gt;</span> k) <span style=color:#66d9ef>return</span> selectR(h <span style=color:#f92672>-&gt;</span> lchild, k);
    <span style=color:#66d9ef>if</span>(c <span style=color:#f92672>&lt;</span> k) <span style=color:#66d9ef>return</span> selectR(h <span style=color:#f92672>-&gt;</span> rchild, k <span style=color:#f92672>-</span> c <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
    <span style=color:#66d9ef>return</span> h <span style=color:#f92672>-&gt;</span> item;
}
</code></pre></div><h3 id=对二叉搜索树进行划分>对二叉搜索树进行划分</h3><p>可以将选择运算修改为划分运算，它重排树，利用左旋和右旋将第 <strong><code>k</code></strong> 小的元素放到根。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++>link <span style=color:#a6e22e>partition</span>(link <span style=color:#f92672>&amp;</span>h, <span style=color:#66d9ef>int</span> k){
    <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> (h <span style=color:#f92672>-&gt;</span> lchild <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>:</span> h <span style=color:#f92672>-&gt;</span> lchild <span style=color:#f92672>-&gt;</span> cnt;
    <span style=color:#66d9ef>if</span>(c <span style=color:#f92672>&gt;</span> k) {partition(h <span style=color:#f92672>-&gt;</span> lchild, k); rotateR(h);}
    <span style=color:#66d9ef>if</span>(c <span style=color:#f92672>&lt;</span> k) {partition(h <span style=color:#f92672>-&gt;</span> rchild, k <span style=color:#f92672>-</span> c <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>); rotateL(h);}
}
</code></pre></div><h3 id=在二叉搜索树中删除节点>在二叉搜索树中删除节点</h3><p>从BST删除一个节点，首先检查该节点是否在其中一棵子树中。如果是则用递归删除节点后的结果替换子树。如果删除的节点在根部，则需要用合并两棵子树的结果替换原来的树。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++>link <span style=color:#a6e22e>joinLR</span>(link l, link r){
    <span style=color:#66d9ef>if</span>(r <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> l;
    partition(r, <span style=color:#ae81ff>0</span>);
    r <span style=color:#f92672>-&gt;</span> lchild <span style=color:#f92672>=</span> l;
    <span style=color:#66d9ef>return</span> r;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>removeR</span>(link <span style=color:#f92672>&amp;</span>h, type v){
    <span style=color:#66d9ef>if</span>(h <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span>;
    type w <span style=color:#f92672>=</span> h <span style=color:#f92672>-&gt;</span> item.getKey();
    <span style=color:#66d9ef>if</span>(v <span style=color:#f92672>&lt;</span> w) removeR(h <span style=color:#f92672>-&gt;</span> lchild, v);
    <span style=color:#66d9ef>if</span>(v <span style=color:#f92672>&gt;</span> w) removeR(h <span style=color:#f92672>-&gt;</span> rchild, v);
    <span style=color:#66d9ef>if</span>(v <span style=color:#f92672>==</span> w){
        link t <span style=color:#f92672>=</span> h;
        h <span style=color:#f92672>=</span> joinLR(h <span style=color:#f92672>-&gt;</span> lchild, h <span style=color:#f92672>-&gt;</span> rchild);
        <span style=color:#66d9ef>delete</span> t;
    }
}
</code></pre></div><h3 id=合并两棵二叉搜索树>合并两棵二叉搜索树</h3><p>书中的一个线性时间的递归实现：首先，利用根插入将第一课BST的根插入到第二棵BST中。这会得到两棵键小于根的子树和两棵键大于根的子树。然后递归的合并根左子树的前一对与根右子树的后一对来得到结果。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++>link <span style=color:#a6e22e>joinAB</span>(link a, link b){
    <span style=color:#66d9ef>if</span>(a <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> b;
    <span style=color:#66d9ef>if</span>(b <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> a;
    insertT(b, a <span style=color:#f92672>-&gt;</span> item);
    b <span style=color:#f92672>-&gt;</span> lchild <span style=color:#f92672>=</span> jionAB(a <span style=color:#f92672>-&gt;</span> lchild, b <span style=color:#f92672>-&gt;</span> lchild);
    b <span style=color:#f92672>-&gt;</span> rchild <span style=color:#f92672>=</span> jionAB(a <span style=color:#f92672>-&gt;</span> rchild, b <span style=color:#f92672>-&gt;</span> rchild);
    <span style=color:#66d9ef>delete</span> a;
    <span style=color:#66d9ef>return</span> b;
}
</code></pre></div><h2 id=2-3-4树>2-3-4树</h2><p>2-3-4树可以在O(logN)的时间内完成查找、插入、和删除操作。</p><p>2-3-4树是一棵空树或者是具有以下三类节点的树：</p><ul><li>2-节点
它具有一个键，以及具有较小键的左子树和具有较大键的右子树的两个链接。</li><li>3-节点
它具有两个键，以及具有较小键的左子树，较大键的右子树和介于节点键之间的中间子树的三个链接。</li><li>4-节点
它具有三个键，以及由节点键对应的区间定义的键值的树的四个链接。</li></ul><h3 id=节点的插入处理>节点的插入处理</h3><ul><li>如果搜索结束的节点是2-节点，将其变为3-节点。</li><li>如果搜索结束的节点是3-节点，将其变为4-节点。</li><li>如果搜索结束的节点是4-节点，将其分裂成两个2-节点，并将中间键上移到节点的父亲（父节点不是4-节点）。但如果父节点也是4-节点呢？更好的一个方法是：在沿树向下的过程中，分解任何4-节点，保证搜索路径不在4-节点终止。具体做法是：每当遇到一个2-节点（父亲）连接到4-节点（孩子），就把它转化为一个3-节点连接到连个2节点；每当遇到一个3-节点连接到4-节点，就把它转换为一个4-节点连接到两个2-节点。</li></ul><h2 id=红黑树>红黑树</h2><p>2-3-4树易于理解，但实现困难。
红黑树是2-3-4树的一种简单抽象表达方式。其基本思想是将2-3-4树表示为标准的BST(仅有2-节点)，但为每个节点添加一个额外的信息位，来为3-节点和4-节点编码。</p><p>链接有两种不同的类型：</p><ul><li>红链接
红链接将包含3-节点和4-节点的小二叉树捆绑在一起。</li><li>黑链接
黑链接将2-3-4树捆绑在一起。</li></ul><p><img src=/images/algorithms_in_c/2-3-4.jpg alt=2-3-4-and-red-black-tree></p><p>红黑树有两个本质特性：</p><ol><li>不用修改BST的标准搜索过程就能工作。</li><li>它们与2-3-4树直接对应。因此可以用上2-3-4树的简单插入平衡过程。</li></ol><p>如果某个节点有2个红孩子，则它是4-节点的一部分。红黑树的插入开销很小：仅当看到4-节点的时候才采取平衡措施。分解不同4-节点的具体做法可以对照下图来说：
<img src=/images/algorithms_in_c/balance-red-black-tree.jpg alt=balance-red-black-tree></p><ul><li>左一：4-节点的父亲是一个2-节点。
将中间键上移转换为一个3-节点与两个2-节点的连接（变色）。</li><li>左二：4-节点的父亲是一个3-节点，并且是它的右孩子。
变色。</li><li>左三：4-节点的父亲是一个3-节点，并且是它的左孩子。
先变色得到两个方向相同的红链接，然后右旋。</li><li>左四：4-节点的父亲是一个3-节点，并且是它的中间孩子。
先变色得到两个方向不同的红链接，然后右旋得到两个方向相同的红链接，然后再左旋。</li></ul><p>用红黑树表示法实现2-3-4树的插入操作，首先要给修改节点定义，加入颜色位（用 <strong><code>1</code></strong> 表示红节点， <strong><code>0</code></strong> 表示黑节点）。在沿树向下的路径中（递归调用之前），检查4-节点，并通过切换所有3-节点的颜色位来分裂它们。当到达底部时，为被插入的项新建一个红节点并返回它的指针。在沿向上的路径中（递归调用之后），检查是否需要执行一次旋转操作：如果路径上有两个相同方向的红链接，则从上方节点进行一次旋转，然后切换颜色位，以形成一个正确的4-节点；如果路径上有两个方向不同的红链接，则从下方的节点执行一次旋转，以简化为另一种情况，留作向上的下一步处理。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getColor</span>(link x){<span style=color:#66d9ef>if</span>(x <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>; <span style=color:#66d9ef>return</span> x <span style=color:#f92672>-&gt;</span> color;}
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insertRB</span>(link <span style=color:#f92672>&amp;</span>h, Item x, <span style=color:#66d9ef>int</span> sw){
    <span style=color:#66d9ef>if</span>(h <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>){h <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Node(x); <span style=color:#66d9ef>return</span>;}
    <span style=color:#66d9ef>if</span>(getColor(h <span style=color:#f92672>-&gt;</span> lchild) <span style=color:#f92672>&amp;&amp;</span> getColor(h <span style=color:#f92672>-&gt;</span> rchild)){  <span style=color:#75715e>// 变色, 分裂4-节点为3-节点
</span><span style=color:#75715e></span>        h <span style=color:#f92672>-&gt;</span> color <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
        h <span style=color:#f92672>-&gt;</span> lchild <span style=color:#f92672>-&gt;</span> color <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
        h <span style=color:#f92672>-&gt;</span> rchild <span style=color:#f92672>-&gt;</span> color <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    }
    <span style=color:#66d9ef>if</span>(x.getKey() <span style=color:#f92672>&lt;</span> h <span style=color:#f92672>-&gt;</span> item.getKey()){  <span style=color:#75715e>// 向左子树插入
</span><span style=color:#75715e></span>        insertRB(h <span style=color:#f92672>-&gt;</span> lchild, x, <span style=color:#ae81ff>0</span>);
        <span style=color:#66d9ef>if</span>(getColor(h) <span style=color:#f92672>&amp;&amp;</span> getColor(h <span style=color:#f92672>-&gt;</span> lchild) <span style=color:#f92672>&amp;&amp;</span> sw)  <span style=color:#75715e>// 两个方向相同的红链接
</span><span style=color:#75715e></span>            rotateR(h);
        <span style=color:#66d9ef>if</span>(getColor(h <span style=color:#f92672>-&gt;</span> lchild) <span style=color:#f92672>&amp;&amp;</span> getColor(h <span style=color:#f92672>-&gt;</span> lchild <span style=color:#f92672>-&gt;</span> lchild)){
            rotateR(h);
            h <span style=color:#f92672>-&gt;</span> color <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
            h <span style=color:#f92672>-&gt;</span> rchild <span style=color:#f92672>-&gt;</span> colot <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
        }
    }
    <span style=color:#66d9ef>else</span>{  <span style=color:#75715e>// 向右子树插入
</span><span style=color:#75715e></span>        inserRB(h <span style=color:#f92672>-&gt;</span> rchild, x, <span style=color:#ae81ff>1</span>);
        <span style=color:#66d9ef>if</span>(getColor(h) <span style=color:#f92672>&amp;&amp;</span> getColor(h <span style=color:#f92672>-&gt;</span> rchild) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>sw)  <span style=color:#75715e>// 左旋
</span><span style=color:#75715e></span>            rotateL(h);
        <span style=color:#66d9ef>if</span>(getColor(h <span style=color:#f92672>-&gt;</span> rchild) <span style=color:#f92672>&amp;&amp;</span> getColor(h <span style=color:#f92672>-&gt;</span> rchild <span style=color:#f92672>-&gt;</span> rchild)){
            rotateL(h);
            h <span style=color:#f92672>-&gt;</span> color <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
            h <span style=color:#f92672>-&gt;</span> lchild <span style=color:#f92672>-&gt;</span> color <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
        }
    }
}
</code></pre></div><p>红黑树的结构性定义：</p><p>红黑树是每个节点都带有颜色的BST，颜色为红色或黑色。除了BST的基本要求外，它还必须满足以下要求：</p><ol><li>节点要么是红色，要么是黑色</li><li>根节点是黑色</li><li>所有叶子节点都是黑色</li><li>每个红节点必须有两个黑色的子节点（也就是说：不能有两个连续的红链接）。</li><li>从任一节点到其每个叶子节点的所有简单路径都包含相同数目的黑节点。</li></ol></div><footer class=entry-footer><div class="container sep-before"><div class=categories><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5A2 2 0 014 3H9l2 3h9a2 2 0 012 2z"/></svg><span class=screen-reader-text>分类: </span><a class=category href=/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a></div><div class=tags><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2H12l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=screen-reader-text>标签: </span><a class=tag href=/tags/c%E7%AE%97%E6%B3%95/>C算法</a></div></div></footer></article><nav class=entry-nav><div class=container><div class="prev-entry sep-before"><a href=/reading_notes/algorithms_in_c/sorting/><span aria-hidden=true><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="20" y1="12" x2="4" y2="12"/><polyline points="10 18 4 12 10 6"/></svg>Previous</span>
<span class=screen-reader-text>上一篇: </span>各种排序算法</a></div><div class="next-entry sep-before"><a href=/reading_notes/algorithms_in_c/hashing-table/><span class=screen-reader-text>下一篇: </span>哈希表<span aria-hidden=true>下一个<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="4" y1="12" x2="20" y2="12"/><polyline points="14 6 20 12 14 18"/></svg></span></a></div></div></nav></main><footer id=footer class=footer><div class="container sep-before"><section class="widget widget-social_menu sep-after"><nav aria-label=社交菜单><ul><li><a href=https://github.com/zhannicholas target=_blank rel="noopener me"><span class=screen-reader-text>Open Github account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li><a href=https://t.me/zhannicholas target=_blank rel="noopener me"><span class=screen-reader-text>Open Telegram account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><title>Telegram icon</title><path d="M23.91 3.79 20.3 20.84c-.25 1.21-.98 1.5-2 .94l-5.5-4.07-2.66 2.57c-.3.3-.55.56-1.1.56-.72.0-.6-.27-.84-.95L6.3 13.7.85 12c-1.18-.35-1.19-1.16.26-1.75l21.26-8.2c.97-.43 1.9.24 1.53 1.73z"/></svg></a></li><li><a href=mailto:zhan_nicholas@outlook.com target=_blank rel="noopener me"><span class=screen-reader-text>Contact via Email</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></li><li><a href=https://linkedin.com/in/%e4%bc%9f%e4%bc%9f-%e8%a9%b9-27871a104 target=_blank rel="noopener me"><span class=screen-reader-text>Open Linkedin account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li></ul></nav></section><div class=copyright><p>&copy; 2018-2021 Nicholas Zhan</p></div></div></footer></div></div><script>window.__assets_js_src="/assets/js/"</script><script src=/assets/js/main.c3bcf2df.js></script><script src=/js/custom.js></script></body></html>