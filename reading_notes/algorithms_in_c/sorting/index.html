<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="学习《C算法》中排序这一部分时做的一些笔记。主要使用C++实现了书中的大部分排序算法。 开始之前 为了方便增加代码的灵活性，我采取了书中作者的部"><meta name=theme-color content="#ffcd00"><meta property="og:title" content="各种排序算法 • Nicholas Zhan"><meta property="og:description" content="学习《C算法》中排序这一部分时做的一些笔记。主要使用C++实现了书中的大部分排序算法。 开始之前 为了方便增加代码的灵活性，我采取了书中作者的部"><meta property="og:url" content="https://zhannicholas.github.io/reading_notes/algorithms_in_c/sorting/"><meta property="og:site_name" content="Nicholas Zhan"><meta property="og:type" content="article"><meta property="og:image" content="https://www.gravatar.com/avatar/85f2cc2a45fd9533b91a65214224f9d7?s=256"><meta property="article:section" content="reading_notes"><meta property="article:tag" content="C算法"><meta property="article:published_time" content="2018-05-30T18:55:31+08:00"><meta property="article:modified_time" content="2018-05-30T18:55:31+08:00"><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.81.0"><title>各种排序算法 • Nicholas Zhan</title><link rel=canonical href=https://zhannicholas.github.io/reading_notes/algorithms_in_c/sorting/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/assets/css/main.ab98e12b.css><link rel=stylesheet href=/css/custom.css><style>:root{--color-accent:#ffcd00}</style></head><body class="page type-reading_notes has-sidebar"><div class=site><div id=sidebar class=sidebar><a class=screen-reader-text href=#main-menu>跳到主菜单</a><div class=container><section class="widget widget-about sep-after"><header><div class=logo><a href=/><img src=/images/logo.png></a></div><h2 class="title site-title"><a href=/>Nicholas Zhan</a></h2><div class=desc>Java Developer, Runner, Cyclist</div></header></section><section class="widget widget-sidebar_menu sep-after"><nav id=sidebar-menu class="menu sidebar-menu" aria-label=侧边栏菜单><div class=container><ul><li class="item has-children"><a href=/posts/databases/>Database</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/posts/databases/redis/>Redis</a></li><li class=item><a href=/posts/databases/fundamentals/>基础理论</a></li></ul></li><li class="item has-children"><a href=/posts/java/>Java</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/posts/java/jakartaee/>Jakarta EE</a></li><li class=item><a href=/posts/java/jvm/>JVM</a></li><li class=item><a href=/posts/java/concurrency/>并发</a></li></ul></li><li class="item has-children"><a href=/posts/operating_systems/>操作系统</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/posts/operating_systems/memory_management/>内存管理</a></li><li class=item><a href=/posts/operating_systems/virtualization/>虚拟化</a></li><li class=item><a href=/posts/operating_systems/processes_management/>进程管理</a></li></ul></li><li class="item has-children"><a href=/posts/computer_networks/>计算机网络</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/posts/computer_networks/http/>HTTP</a></li><li class=item><a href=/posts/computer_networks/fundamentals/>基础知识</a></li></ul></li><li class="item has-children"><a href=/reading_notes/>读书笔记</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/reading_notes/algorithms_in_c/>C算法</a></li><li class=item><a href=/reading_notes/ostep/>OSTEP</a></li><li class=item><a href=/reading_notes/sicp_in_python/>SICP in Python</a></li><li class=item><a href=/reading_notes/the_art_of_multiprocessor_programming/>多处理器编程的艺术</a></li><li class=item><a href=/reading_notes/modern_operating_systems/>现代操作系统</a></li><li class=item><a href=/reading_notes/introduction_to_algorithms/>算法导论</a></li><li class=item><a href=/reading_notes/%E7%AE%97%E6%B3%95%E8%B6%A3%E9%A2%98/>算法趣题</a></li><li class=item><a href=/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/>设计模式的艺术</a></li></ul></li></ul></div></nav></section><section class="widget widget-taxonomy_cloud sep-after"><header><h4 class="title widget-title">分类</h4></header><div class="container list-container"><ul class="list taxonomy-cloud"><li><a href=/categories/db/ style=font-size:1.1818181818181819em>DB</a></li><li><a href=/categories/java/ style=font-size:1.5151515151515151em>Java</a></li><li><a href=/categories/leetcode/ style=font-size:1.0606060606060606em>Leetcode</a></li><li><a href=/categories/linux/ style=font-size:1em>Linux</a></li><li><a href=/categories/networks/ style=font-size:1.303030303030303em>Networks</a></li><li><a href=/categories/notebook/ style=font-size:1em>Notebook</a></li><li><a href=/categories/os/ style=font-size:1.1515151515151516em>OS</a></li><li><a href=/categories/tools/ style=font-size:1em>Tools</a></li><li><a href=/categories/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/ style=font-size:1.0606060606060606em>新手上路</a></li><li><a href=/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ style=font-size:2em>读书笔记</a></li></ul></div></section></div><div class=sidebar-overlay></div></div><div class=main><a class=screen-reader-text href=#content>跳到内容</a>
<button id=sidebar-toggler class=sidebar-toggler aria-controls=sidebar>
<span class=screen-reader-text>Toggle Sidebar</span>
<span class=open><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></span><span class=close><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span></button><div class=header-widgets><div class=container><style>.widget-breadcrumbs li:after{content:'\2f '}</style><section class="widget widget-breadcrumbs sep-after"><nav id=breadcrumbs><ol><li><a href=/>Home</a></li><li><a href=/reading_notes/>读书笔记</a></li><li><a href=/reading_notes/algorithms_in_c/>C算法</a></li><li><span>各种排序算法</span></li></ol></nav></section></div></div><header id=header class="header site-header"><div class="container sep-after"><div class=header-info><p class="site-title title">Nicholas Zhan</p><p class="desc site-desc">Java Developer, Runner, Cyclist</p></div></div></header><main id=content><article lang=zh-cn class=entry><header class="header entry-header"><div class="container sep-after"><div class=header-info><h1 class=title>各种排序算法</h1></div><div class=entry-meta><span class=posted-on><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg><span class=screen-reader-text>Posted on</span>
<time class=entry-date datetime=2018-05-30T18:55:31+08:00>2018, May 30</time></span>
<span class=byline><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M21 21V20c0-2.76-4-5-9-5s-9 2.24-9 5v1"/><path d="M16 6.37A4 4 0 1112.63 3 4 4 0 0116 6.37z"/></svg><span class=screen-reader-text>by </span><a href=/authors/zhannicholas>Nicholas Zhan</a></span>
<span class=reading-time><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 15 15"/></svg>12 mins read</span></div></div></header><details class="container entry-toc"><summary class=title><span>目录</span></summary><nav id=TableOfContents><ul><li><a href=#选择排序>选择排序</a><ul><li><a href=#步骤>步骤</a></li><li><a href=#具体实现>具体实现</a></li></ul></li><li><a href=#插入排序>插入排序</a><ul><li><a href=#步骤-1>步骤</a></li><li><a href=#说明>说明</a></li><li><a href=#改进>改进</a></li></ul></li><li><a href=#冒泡排序>冒泡排序</a><ul><li><a href=#步骤-2>步骤</a></li></ul></li><li><a href=#摇摆排序>摇摆排序</a></li><li><a href=#希尔排序>希尔排序</a></li><li><a href=#键索引计数排序>键索引计数排序</a><ul><li><a href=#步骤-3>步骤</a></li></ul></li><li><a href=#快速排序>快速排序</a><ul><li><a href=#划分方法>划分方法</a></li><li><a href=#改进三元素中值划分>改进（三元素中值划分）</a></li><li><a href=#应对大量重复键的情况---三路划分>应对大量重复键的情况&mdash;三路划分</a></li></ul></li><li><a href=#奇偶排序>奇偶排序</a><ul><li><a href=#步骤-4>步骤</a></li><li><a href=#实现>实现</a></li></ul></li><li><a href=#归并排序>归并排序</a><ul><li><a href=#归并>归并</a></li><li><a href=#排序>排序</a></li><li><a href=#巴切奇偶归并排序>巴切奇偶归并排序</a></li></ul></li><li><a href=#堆排序>堆排序</a><ul><li><a href=#堆>堆</a></li><li><a href=#自底向上堆化>自底向上堆化</a></li><li><a href=#自顶向下堆化>自顶向下堆化</a></li><li><a href=#排序方法>排序方法</a></li></ul></li><li><a href=#基数排序>基数排序</a></li></ul></nav></details><div class="container entry-content"><blockquote><p>学习《C算法》中排序这一部分时做的一些笔记。主要使用C++实现了书中的大部分排序算法。</p></blockquote><h1 id=开始之前>开始之前</h1><p>为了方便增加代码的灵活性，我采取了书中作者的部分方法。主要是用 <strong><code>type</code></strong> 代替了具体的数据类型，以及定义了两个用于比较的宏。通过改变下面内容， 可以很容易的进行其它数据类型的排序。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>int</span> type;
<span style=color:#75715e>#define less(A, B) (A &lt; B)
</span><span style=color:#75715e>#define equal(A, B) (A == B)
</span></code></pre></div><p>下面的 <strong><code>exchange()</code></strong> 函数用来交换两个元素：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>exchange</span>(type <span style=color:#f92672>&amp;</span>a, type <span style=color:#f92672>&amp;</span>b){type t <span style=color:#f92672>=</span> a; a <span style=color:#f92672>=</span> b; b <span style=color:#f92672>=</span> t;}
</code></pre></div><p>还有用来测试算法正确性的驱动函数，它通过读取用户输入的数字 <strong><code>n</code></strong> , 产生 <strong><code>n</code></strong> 个10000以内的随机数作为测试数据。然后调用相应的排序算法并输出排序结果。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
    <span style=color:#66d9ef>int</span> n;
    scanf(<span style=color:#e6db74>&#34;%d&#34;</span>, <span style=color:#f92672>&amp;</span>n);
    type <span style=color:#f92672>*</span>a <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> type[n];
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;i <span style=color:#f92672>&lt;</span> n;i<span style=color:#f92672>++</span>) a[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>10000</span> <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>*</span> rand() <span style=color:#f92672>/</span> RAND_MAX);
    <span style=color:#75715e>//selectSort(a, 0, n - 1);
</span><span style=color:#75715e></span>    <span style=color:#75715e>//insertSort1(a, 0, n - 1);
</span><span style=color:#75715e></span>    <span style=color:#75715e>//insertSort2(a, 0, n - 1);
</span><span style=color:#75715e></span>    <span style=color:#75715e>//bubbleSort(a, 0, n - 1);
</span><span style=color:#75715e></span>    <span style=color:#75715e>//shakerSort(a, 0, n - 1);
</span><span style=color:#75715e></span>    <span style=color:#75715e>//shellSort(a, 0, n - 1);
</span><span style=color:#75715e></span>    <span style=color:#75715e>//countSort(a, 0, n - 1);
</span><span style=color:#75715e></span>    <span style=color:#75715e>//quickSort(a, 0, n - 1);
</span><span style=color:#75715e></span>    <span style=color:#75715e>//tri_quickSort(a, 0, n - 1);
</span><span style=color:#75715e></span>    <span style=color:#75715e>//mergeSort(a, 0, n - 1);
</span><span style=color:#75715e></span>    <span style=color:#75715e>//mergeTD(a, 0, n - 1);
</span><span style=color:#75715e></span>    <span style=color:#75715e>//oddEvenSort(a, 0, n - 1);
</span><span style=color:#75715e></span>    <span style=color:#75715e>//heapSort(a, 0, n - 1);
</span><span style=color:#75715e></span>    <span style=color:#75715e>//radixSort(a, 0, n - 1);
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;i <span style=color:#f92672>&lt;</span> n;i<span style=color:#f92672>++</span>) printf(<span style=color:#e6db74>&#34;%-6d&#34;</span>, a[i]);
    printf(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
    <span style=color:#66d9ef>delete</span> []a;
    system(<span style=color:#e6db74>&#34;pause&#34;</span>);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><h2 id=选择排序>选择排序</h2><h3 id=步骤>步骤</h3><ol><li>首先，找出数组中最小的元素并用首位置的元素和它交换</li><li>然后， 找出数组中次小的元素并用第二个位置的元素和它交换</li><li>重复此步骤，直到整个数组排序完成。</li></ol><h3 id=具体实现>具体实现</h3><p>对于从 <strong><code>left</code></strong> 到 <strong><code>right - 1</code></strong> 的每个 <strong><code>i</code></strong> ,用 <strong><code>a[i]</code></strong>, <strong><code>a[i + 1]</code></strong>, &mldr;, <strong><code>a[right]</code></strong> 中的最小元素进行交换。当索引 <strong><code>i</code></strong> 从左向右遍历时，其左边的元素所处的位置就是其在数组中的最终位置。
所以，当 <strong><code>i</code></strong> 到达最右端时，整个数组排序完成。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>selectSort</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> left;i <span style=color:#f92672>&lt;</span> right;i<span style=color:#f92672>++</span>){
        <span style=color:#66d9ef>int</span> minp <span style=color:#f92672>=</span> i;  <span style=color:#75715e>// 假定未排序序列中的第一个为最小值
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;j <span style=color:#f92672>&lt;=</span> right;j<span style=color:#f92672>++</span>)
            <span style=color:#66d9ef>if</span>(less(a[j], a[minp])) minp <span style=color:#f92672>=</span> j;
        exchange(a[i], a[minp]);
    }
}
</code></pre></div><h2 id=插入排序>插入排序</h2><h3 id=步骤-1>步骤</h3><p>对于未排序的序列，每次取其中的一个数。然后在已排序的序列中从后向前扫描， 找到合适的位置并插入。</p><h3 id=说明>说明</h3><p>和选择排序一样，在排序过程中，当前索引左边的元素已经有序，但这并不是他们的最终位置，如果碰到了比它们更小的元素，它们还必须后移，为较小的元素腾出位置。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insertSort1</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;i <span style=color:#f92672>&lt;=</span> right;i<span style=color:#f92672>++</span>)
        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i;j <span style=color:#f92672>&gt;</span> left;j<span style=color:#f92672>--</span>)
            <span style=color:#66d9ef>if</span>(less(a[j], a[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>])) exchange(a[j], a[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]);
}
</code></pre></div><h3 id=改进>改进</h3><blockquote><p>与选择排序不同的时，插入排序的运行时间主要取决于输入中键的初始顺序。
当我们碰到的键不大于正被插入的键时，就可以停止 <strong><code>less()</code></strong> 和 <strong><code>exchange()</code></strong> 运算，因为左边的序列时已经排序好的了。特别地，当 <strong><code>less(a[j - 1], a[j])</code></strong> 为真时，我们可以直接跳出内层循环。
不难发现，<strong><code>j > left</code></strong> 的测试通常是多余的（只有在插入元素时当前看到的最小元素并且到达了数组的起始处，它才为真）。一种改进方法是：让键在 <strong><code>a[left]</code></strong> 到 <strong><code>a[N]</code></strong> 中保持有序，并在 <strong><code>a[0]</code></strong> 中放入一个标记键，它至少与数组中的最小键相同。然后通过测试是否碰到了最小键来同时测试 <strong><code>less(a[j - 1], a[j])</code></strong> 和 <strong><code>j > left</code></strong> 这两个条件，让内循环更小，程序更快。
对同一个元素的连续交换效率不高，如果进行两次或者更多的交换，中间变量 <strong><code>t</code></strong> 的值并没有改变。在第二次或以后的交换中，先保存再重新载入 <strong><code>t</code></strong> 的值就是浪费时间。</p></blockquote><h4 id=具体做法>具体做法</h4><ul><li>将数组中最小值放到第一个位置，作为标记。</li><li>在内循环中，进行单个赋值，而不是连续交换。</li><li>当正被插入的元素已经就位时，终止内循环。对于每个 <strong><code>i</code></strong> ，把大于 <strong><code>a[i]</code></strong> 的排序表 <strong><code>a[left], ..., a[i - 1]</code></strong> 的所有元素整体向右移动一个位置，再把 <strong><code>a[i]</code></strong> 放入适当的位置。这样就完成了整个排序的过程。</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insertSort2</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, minp <span style=color:#f92672>=</span> left;i <span style=color:#f92672>&lt;=</span> right;i<span style=color:#f92672>++</span>){
        <span style=color:#66d9ef>if</span>(less(a[i], a[left])) minp <span style=color:#f92672>=</span> i;
        exchange(a[minp], a[left]);
    }
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>;i <span style=color:#f92672>&lt;=</span> right;i<span style=color:#f92672>++</span>){
        <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> i;
        type v <span style=color:#f92672>=</span> a[i];  <span style=color:#75715e>// 先保存a[i]，确保它不会被右移的元素覆盖
</span><span style=color:#75715e></span>        <span style=color:#75715e>//把大于a[i]的所有元素整体向右移动一个位置
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(;less(v, a[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]);j<span style=color:#f92672>--</span>) a[j] <span style=color:#f92672>=</span> a[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
        a[j] <span style=color:#f92672>=</span> v;  <span style=color:#75715e>// 放入a[i]到适当的位置
</span><span style=color:#75715e></span>    }
}
</code></pre></div><h2 id=冒泡排序>冒泡排序</h2><h3 id=步骤-2>步骤</h3><ol><li>从左到右比较相邻的两个元素，如果第一个比第二个大，就交换它们</li><li>对每一对元素重复第1步，结束时，最大的元素在排序序列的最右端。</li><li>对除最后一个以外的所有元素重复以上步骤。</li><li>重复直到没有任何一对数字需要比较。</li></ol><p>代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>bubbleSort</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> left;i <span style=color:#f92672>&lt;=</span> right;i<span style=color:#f92672>++</span>){
        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> left;j <span style=color:#f92672>&lt;=</span> right <span style=color:#f92672>-</span> i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;j<span style=color:#f92672>++</span>)
            <span style=color:#66d9ef>if</span>(less(a[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>], a[j])) exchange(a[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>], a[j]);
    }
}
</code></pre></div><h2 id=摇摆排序>摇摆排序</h2><p>冒泡排序改良版。将单向扫描数组改成从头到尾，再从尾到头的交替方式</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shakerSort</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> left;i <span style=color:#f92672>&lt;=</span> right;i<span style=color:#f92672>++</span>){
        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> left;j <span style=color:#f92672>&lt;=</span> right <span style=color:#f92672>-</span> i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;j<span style=color:#f92672>++</span>)
            <span style=color:#66d9ef>if</span>(less(a[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>], a[j])) exchange(a[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>], a[j]);
        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;j <span style=color:#f92672>&gt;</span> i;j<span style=color:#f92672>--</span>)
            <span style=color:#66d9ef>if</span>(less(a[j], a[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>])) exchange(a[j], a[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]);
    }
}
</code></pre></div><h2 id=希尔排序>希尔排序</h2><p>希尔排序又叫缩小增量排序，它是插入排序扩展。</p><blockquote><p>插入排序慢， 因为它一次只交换相邻的两个元素（步长为1）。如果最小键位于数组尾部，则将它移动到正确位置需要N步。
为了让元素能够能快的到达正确的位置，改变步长。每隔h取一个元素，可以得到一些h-有序序列。然后改变步长继续操作，最终当步长为1的时候，希尔排序变成插入排序，这就保证了排序能够完成。</p></blockquote><p>如果不使用标记，则在插入排序中，将步长由“1”换成“h”(也就是将每个“1”换成“h”)，得到的程序对序列进行h-排序。增加一个外循环来改变增量h，就可以得到最终程序。程序中选取的增量序列为：1，4，13，40，121，364，1093，3280，9841……</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shellSort</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>int</span> h, i, j;
    <span style=color:#66d9ef>for</span>(h <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;h <span style=color:#f92672>&lt;</span> (right <span style=color:#f92672>-</span> left) <span style=color:#f92672>/</span> <span style=color:#ae81ff>3</span>;h <span style=color:#f92672>=</span> h <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
    <span style=color:#66d9ef>for</span>(;h <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>;h <span style=color:#f92672>/=</span> <span style=color:#ae81ff>3</span>){  <span style=color:#75715e>// 调整增量
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> h;i <span style=color:#f92672>&lt;=</span> right;i <span style=color:#f92672>+=</span> h){
            j <span style=color:#f92672>=</span> i;
            type v <span style=color:#f92672>=</span> a[i]; <span style=color:#75715e>// 保存a[i]
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span>(;j <span style=color:#f92672>&gt;=</span> left <span style=color:#f92672>+</span> h <span style=color:#f92672>&amp;&amp;</span> less(v, a[j <span style=color:#f92672>-</span> h]);j <span style=color:#f92672>-=</span> h) a[j] <span style=color:#f92672>=</span> a[j <span style=color:#f92672>-</span> h]; <span style=color:#75715e>// 向后移动h个元素
</span><span style=color:#75715e></span>        a[j] <span style=color:#f92672>=</span> v;  <span style=color:#75715e>// 把a[i]放到正确位置
</span><span style=color:#75715e></span>        }
    }
}
</code></pre></div><h2 id=键索引计数排序>键索引计数排序</h2><p>键索引排序把键当作索引进行排序，而不是把键当作被比较的抽象项。比如：排序一个包含N个项的文件，项的键为0~M-1之间的整数。我们可以用每个值来对键的个数进行计数，然后在第二遍扫描中使用计算出来的数将项移到正确的位置。通俗的讲：加入你们班有30个人，统计出来有5个人的绩点比你高，那么你的绩点就排在第6位。用这个方法可以得到其它人的排名，也就排好了序。对于重复值，需要特殊处理。
不过键索引基数排序局限于待排序数据的范围。</p><h3 id=步骤-3>步骤</h3><ol><li>首先，计数每个值的键的数量</li><li>然后，小计小于或等于每个值的键数。</li><li>接着，使用这些计数作为索引分拣键，比如 <strong><code>cnt[i]</code></strong> 表示小于 <strong><code>i</code></strong> 的个数，那个 <strong><code>a[i]</code></strong> 位于 <strong><code>aux[ant[i]]</code></strong></li><li>写回原数组</li></ol><p>代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>countSort</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>int</span> i, j, M <span style=color:#f92672>=</span> <span style=color:#ae81ff>10000</span>; <span style=color:#75715e>// 键必须是小于M的整数
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, cnt[M];
    type <span style=color:#f92672>*</span>aux <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> type[N];
    <span style=color:#66d9ef>for</span>(j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> M;j<span style=color:#f92672>++</span>) cnt[j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 将计数初始化为0
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> left;i <span style=color:#f92672>&lt;=</span> right;i<span style=color:#f92672>++</span>) cnt[a[i] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]<span style=color:#f92672>++</span>;  <span style=color:#75715e>//统计小于a[i]的值的出现频率
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(j <span style=color:#f92672>=</span> left;j <span style=color:#f92672>&lt;</span> M;j<span style=color:#f92672>++</span>) cnt[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+=</span> cnt[j]; <span style=color:#75715e>// 得到小于等于计数器对应计数值键的数量,将频率转换为索引
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> left;i <span style=color:#f92672>&lt;=</span> right;i<span style=color:#f92672>++</span>) aux[cnt[a[i]]<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> a[i]; <span style=color:#75715e>// 将键分布到辅助数组中
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> left;i <span style=color:#f92672>&lt;=</span> right;i<span style=color:#f92672>++</span>) a[i] <span style=color:#f92672>=</span> aux[i];  <span style=color:#75715e>// 回写
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>delete</span> []aux;
}
</code></pre></div><h2 id=快速排序>快速排序</h2><p>快速排序是一种分治方法。它的工作方式是：将待排序的序列划分为两组，然后独立排序各个部分划分的准确位置取决于输入中元素的初始顺序。
方法的关键在于划分过程，它将数组重排，使下面3个条件成立：</p><ol><li>对于某一个 <strong><code>i</code></strong> 值，元素 <strong><code>a[i]</code></strong> 处于数组中的最终位置;</li><li><strong><code>a[i]</code></strong> 左边的元素都不大于 <strong><code>a[i]</code></strong> ;</li><li><strong><code>a[i]</code></strong> 右边的元素都不小于 <strong><code>a[i]</code></strong> ;</li></ol><h3 id=划分方法>划分方法</h3><ol><li>首先，任意选定 <strong><code>a[right]</code></strong> 作为划分元素（它将处于在数组中的最终位置）。</li><li>从左向右扫描，直到发现一个大于划分元素的元素；同时从右向左扫描，直到发现一个小于划分元素的元素，然后交换这两个元素。</li><li>按这种方式继续划分。确保左指针左边的元素都小于划分元素，右指针右边的元素都大于划分元素。</li><li>当左右指针相遇或者相互经过时，交换 <strong><code>a[right]</code></strong> 和右半部分最左边的元素（由左指针指向的元素），划分结束。</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>partition</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> left <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, j <span style=color:#f92672>=</span> right;
    type v <span style=color:#f92672>=</span> a[right];  <span style=color:#75715e>// a[right]为划分元素
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(;;){
        <span style=color:#66d9ef>for</span>(;less(a[<span style=color:#f92672>++</span>i], v););
        <span style=color:#66d9ef>for</span>(;less(v, a[<span style=color:#f92672>--</span>j]);) <span style=color:#66d9ef>if</span>(j <span style=color:#f92672>==</span> left) <span style=color:#66d9ef>break</span>;  <span style=color:#75715e>// 避免划分元素为序列中的最小元素的情况发生
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(j <span style=color:#f92672>&lt;=</span> i) <span style=color:#66d9ef>break</span>;
        exchange(a[i], a[j]);
    }
    exchange(a[i], a[right]);  <span style=color:#75715e>//交换a[right]和a[i]
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> i;  
}
</code></pre></div><p>如果数组中只有一个元素，不需要进行任何运算。否则，调用 <strong><code>partition()</code></strong> 函数处理这个数组，它将 <strong><code>a[i]</code></strong> 放到最终位置 <strong><code>(left &lt; i &lt;= right)</code></strong> 并且重排其它元素，让递归调用能够正确完成整个排序过程。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>quickSort</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>if</span>(right <span style=color:#f92672>&lt;=</span> left) <span style=color:#66d9ef>return</span>;
    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> partition(a, left, right);
    quickSort(a, left, i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
    quickSort(a, i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, right);
}
</code></pre></div><h3 id=改进三元素中值划分>改进（三元素中值划分）</h3><p>三元素中值划分使用一个更有可能在中间位置出现的元素作为划分元素。它从序列中选出三个元素的样本，然后用这三个元素的中值作为划分元素。分别从数组中的左、中、右选取一个元素。接着排序这三个元素，然后用 <strong><code>a[right - left]</code></strong> 交换中间那一个，再对 <strong><code>a[left + 1],...,a[right - 2]</code></strong> 运行划分算法。</p><h3 id=应对大量重复键的情况---三路划分>应对大量重复键的情况&mdash;三路划分</h3><blockquote><p>当排序序列中的重复键较多的时候，快速排序的低下性能让人难以接受。
可以把序列分为三部分，分别是：小于划分元素的部分、等于划分元素的部分、大于划分元素的部分。
修改标准划分方案如下：将在左边部分碰到的和划分元素相等的键放到序列的左端，将右边部分碰到的和划分元素相等的键放到序列右端。
然后，当指针交叉而且相等键的位置已知的时候，将所有与划分元素相等的键交换到位
<img src=/images/algorithms_in_c/%E4%B8%89%E8%B7%AF%E5%88%92%E5%88%86.png alt=三路划分></p></blockquote><h4 id=一点说明>一点说明</h4><p>程序将数组划分为三部分：小于划分元素的部分（ <strong><code>a[left],..., a[j]</code></strong> ）, 等于划分元素的部分（ <strong><code>a[j + 1],..., a[i - 1]</code></strong> ）,大于划分元素的部分( <strong><code>a[i],...,a[right]</code></strong> )。示意图如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>tri_quickSort</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>if</span>(right <span style=color:#f92672>&lt;=</span> left) <span style=color:#66d9ef>return</span>;
    type v <span style=color:#f92672>=</span> a[right];  <span style=color:#75715e>// 划分元素
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> left, j <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, p <span style=color:#f92672>=</span> left, q <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>for</span>(;;){
        <span style=color:#66d9ef>for</span>(;less(a[i], v);i<span style=color:#f92672>++</span>);
        <span style=color:#66d9ef>for</span>(;less(v, a[j]);j<span style=color:#f92672>--</span>) <span style=color:#66d9ef>if</span>(j <span style=color:#f92672>==</span> left) <span style=color:#66d9ef>break</span>;  <span style=color:#75715e>// 避免划分元素为序列中的最小元素的情况发生
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(j <span style=color:#f92672>&lt;=</span> i) <span style=color:#66d9ef>break</span>;
        exchange(a[i], a[j]);
        <span style=color:#66d9ef>if</span>(equal(a[i], v)){p<span style=color:#f92672>++</span>;exchange(a[i], a[p]);}
        <span style=color:#66d9ef>if</span>(equal(a[j], v)){q<span style=color:#f92672>--</span>;exchange(a[j], a[q]);}
    }
    exchange(a[i], a[right]);
    i<span style=color:#f92672>--</span>;j<span style=color:#f92672>++</span>;
    <span style=color:#66d9ef>int</span> k;
    <span style=color:#66d9ef>for</span>(k <span style=color:#f92672>=</span> left;k <span style=color:#f92672>&lt;</span> p;k<span style=color:#f92672>++</span>,i<span style=color:#f92672>--</span>) exchange(a[k], a[i]); 
    <span style=color:#66d9ef>for</span>(k <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;k <span style=color:#f92672>&gt;</span> q;k<span style=color:#f92672>--</span>, j<span style=color:#f92672>++</span>) exchange(a[k], a[j]);
    tri_quickSort(a, left, i);
    tri_quickSort(a, j, right);
}
</code></pre></div><h2 id=奇偶排序>奇偶排序</h2><h3 id=步骤-4>步骤</h3><ol><li>选取所有为奇数列（下标为1,3,5&mldr;)的元素与其右侧元素比较，将小的放在前面</li><li>选取所有为偶数列（下标为2,4,6&mldr;)的元素与其右侧元素比较，将小的放在前面</li><li>重复1和2直到所有序列有序为止。</li></ol><h3 id=实现>实现</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>oddEvenSort</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>int</span> i;
    <span style=color:#66d9ef>bool</span> oddSorted <span style=color:#f92672>=</span> false, evenSorted <span style=color:#f92672>=</span> false;
    <span style=color:#66d9ef>while</span>(<span style=color:#f92672>!</span>oddSorted <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>evenSorted){
        oddSorted <span style=color:#f92672>=</span> true;
        evenSorted <span style=color:#f92672>=</span> true;
        <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> left;i <span style=color:#f92672>&lt;</span> right;i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span>){
            <span style=color:#66d9ef>if</span>(less(a[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>], a[i])){
                exchange(a[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>], a[i]);
                evenSorted <span style=color:#f92672>=</span> false;
            }
        }
        <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> right;i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span>){
            <span style=color:#66d9ef>if</span>(less(a[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>], a[i])){
                exchange(a[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>], a[i]);
                oddSorted <span style=color:#f92672>=</span> false;
            }
        }
    }
}
</code></pre></div><h2 id=归并排序>归并排序</h2><h3 id=归并>归并</h3><p>数组 <strong><code>a</code></strong> 的前半部分（ <strong><code>a[left],...,a[m]</code></strong> ）有序，后半部分（ <strong><code>a[m + 1],...,a[right]</code></strong> ）有序。归并这两部分，使整个数组有序。一般需要一个辅助数组 <strong><code>aux</code></strong> ,先把结果存到 <strong><code>aux</code></strong> 中，然后把排序结果从 <strong><code>aux</code></strong> 写回到 <strong><code>a</code></strong> 中。
一种常用的归并方法：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>merge0</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
    type <span style=color:#f92672>*</span>aux <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> type[len];
    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> left, j <span style=color:#f92672>=</span> m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>while</span>(i <span style=color:#f92672>&lt;=</span> m <span style=color:#f92672>&amp;&amp;</span> j <span style=color:#f92672>&lt;=</span> right) aux[k<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> less(a[i], a[j]) <span style=color:#f92672>?</span> a[i<span style=color:#f92672>++</span>] <span style=color:#f92672>:</span> a[j<span style=color:#f92672>++</span>];
    <span style=color:#66d9ef>while</span>(i <span style=color:#f92672>&lt;=</span> m) aux[k<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> a[i<span style=color:#f92672>++</span>];
    <span style=color:#66d9ef>while</span>(j <span style=color:#f92672>&lt;=</span> right) aux[k<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> a[j<span style=color:#f92672>++</span>];
    <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> left, k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;i <span style=color:#f92672>&lt;=</span> right;i<span style=color:#f92672>++</span>, k<span style=color:#f92672>++</span>) a[i] <span style=color:#f92672>=</span> aux[k];
    <span style=color:#66d9ef>delete</span> []aux;
}
</code></pre></div><p>另一种归并方法：
将前半部分复制到 <strong><code>aux</code></strong> 中，然后将后半部分（ <strong><code>a[m + 1],...,a[right]</code></strong> ）逆序复制到 <strong><code>aux</code></strong> 中,使两个部分最大元素背靠背位于 <strong><code>aux</code></strong> 中间，形成双调序列。这样，两个部分中的最大元素分别成为一个标记。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>merge1</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> m, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
    type <span style=color:#f92672>*</span>aux <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> type[len];
    <span style=color:#66d9ef>int</span> i, j , k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> left;i <span style=color:#f92672>&lt;=</span> m;i<span style=color:#f92672>++</span>) aux[k<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> a[i];  <span style=color:#75715e>// 复制前半部分到aux
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(j <span style=color:#f92672>=</span> right;j <span style=color:#f92672>&gt;=</span> m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;j<span style=color:#f92672>--</span>) aux[k<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> a[j];  <span style=color:#75715e>// 逆序复制后半部分到aux
</span><span style=color:#75715e></span>    i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>=</span> len <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>for</span>(k <span style=color:#f92672>=</span> left;k <span style=color:#f92672>&lt;=</span> right;k<span style=color:#f92672>++</span>){
        <span style=color:#66d9ef>if</span>(less(aux[i], aux[j])) a[k] <span style=color:#f92672>=</span> aux[i<span style=color:#f92672>++</span>];  <span style=color:#75715e>// 归并，最大元素为各自的标记
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>else</span> a[k] <span style=color:#f92672>=</span> aux[j<span style=color:#f92672>--</span>];
    }
    <span style=color:#66d9ef>delete</span> []aux;
}
</code></pre></div><h3 id=排序>排序</h3><p>将数组分为两部分： <strong><code>a[left],..., a[m]</code></strong> 和 <strong><code>a[m + 1], ..., a[right]</code></strong> 。然后对这两个数组进行独立排序（通过递归调用），然后将这两个有序序列归并到最终的序列。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mergeSort</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>int</span> m <span style=color:#f92672>=</span> (left <span style=color:#f92672>+</span> right) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
    <span style=color:#66d9ef>if</span>(right <span style=color:#f92672>&lt;=</span> left) <span style=color:#66d9ef>return</span>;
    mergeSort(a, left, m);
    mergeSort(a, m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, right);
    merge1(a, left, m, right);  <span style=color:#75715e>// 归并
</span><span style=color:#75715e></span>}
</code></pre></div><h3 id=巴切奇偶归并排序>巴切奇偶归并排序</h3><p>首先要讲两个函数：
完全混洗(shuffle):将数组 <strong><code>a[left],...,a[right]</code></strong> 分为两半，前一半进入结果中的偶数编号位置，后一半进入结果中的奇数编号位置。
逆完全混洗(unshuffle):偶数编号位置的元素进入结果的前一半，奇数编号位置的元素进入结果的后一半。
这两个函数仅对带有偶数个元素的子数组使用。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shuffle</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>int</span> i, j, m <span style=color:#f92672>=</span> (left <span style=color:#f92672>+</span> right) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, len <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
    type <span style=color:#f92672>*</span>aux <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> type[len];
    <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> left, j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;i <span style=color:#f92672>&lt;=</span> m;i<span style=color:#f92672>++</span>, j <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span>){
        aux[j] <span style=color:#f92672>=</span> a[i];
        aux[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> a[m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> i <span style=color:#f92672>-</span> left];
    }
    <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> left, j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;i <span style=color:#f92672>&lt;=</span> right;i<span style=color:#f92672>++</span>, j<span style=color:#f92672>++</span>) a[i] <span style=color:#f92672>=</span> aux[j];
    <span style=color:#66d9ef>delete</span> []aux;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>unshuffle</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>int</span> i, j, m <span style=color:#f92672>=</span> (left <span style=color:#f92672>+</span> right) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, len <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>int</span> ma <span style=color:#f92672>=</span> len <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
    type <span style=color:#f92672>*</span>aux <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> type[len];
    <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> left, j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;i <span style=color:#f92672>&lt;=</span> right;i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span>, j<span style=color:#f92672>++</span>){
        aux[j] <span style=color:#f92672>=</span> a[i];
        aux[ma <span style=color:#f92672>+</span> j] <span style=color:#f92672>=</span> a[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
    }
    <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> left, j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;i <span style=color:#f92672>&lt;=</span> right;i<span style=color:#f92672>++</span>, j<span style=color:#f92672>++</span>) a[i] <span style=color:#f92672>=</span> aux[j];
    <span style=color:#66d9ef>delete</span> []aux;
}
</code></pre></div><h4 id=巴切的奇偶归并网络>巴切的奇偶归并网络</h4><p>这个网络输入两个已排好序的序列，对这两个序列进行归并排序。首先对这两个序列进行逆混洗，然后分别归并前后部分，接着再混洗，最后进行一次(1,2)、(3,4)&mldr;这些相邻元素的比较交换得到排序结果。这里的代码只适合元素个数为 <strong><code>2^n</code></strong> 的序列。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mergeTD</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>int</span> i, m <span style=color:#f92672>=</span> (left <span style=color:#f92672>+</span> right) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
    quickSort(a, left, m); quickSort(a, m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, right);
    <span style=color:#66d9ef>if</span>(left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> right)
        <span style=color:#66d9ef>if</span>(less(a[right], a[left])) exchange(a[left], a[right]);
    <span style=color:#66d9ef>if</span>(left <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&gt;</span> right) <span style=color:#66d9ef>return</span>;  <span style=color:#75715e>// 不多于两个元素
</span><span style=color:#75715e></span>    unshuffle(a, left, right);  <span style=color:#75715e>// 逆混洗
</span><span style=color:#75715e></span>    mergeTD(a, left, m);
    mergeTD(a, m <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, right);
    shuffle(a, left, right);  <span style=color:#75715e>// 混洗
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;i <span style=color:#f92672>&lt;</span> right;i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span>)  <span style=color:#75715e>//比较交换
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(less(a[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>], a[i])) exchange(a[i], a[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]);
}
</code></pre></div><h2 id=堆排序>堆排序</h2><h3 id=堆>堆</h3><p>大顶堆——堆中不存在大于根键的结点。与之对应的由小顶堆。这里使用大顶堆。
如果用数组来保存堆，如果下标从 <strong><code>0</code></strong> 开始，很容易知道位置 <strong><code>i</code></strong> 处结点的父亲位于 <strong><code>(i - 1) / 2</code></strong> , 反之位置 <strong><code>i</code></strong> 处结点的孩子位于 <strong><code>(2i + 1)</code></strong> 和**<code>(2i + 2)</code>** 处。
堆中的第 **<code>i</code>** 个元素大于等于第 **<code>(2i + 1)</code>** 个元素和 **<code>(2i + 2)</code>** 个元素。
有关堆的很多算法都是首先对堆做一个简单的修改，这可能违反堆的条件，然后遍历堆，同时修正堆，确保整个堆满足堆的条件。
修正堆的情况有两种，一种是在堆底部添加新节点，然后需要向上遍历调整堆；另一种是用一个新节点替换掉根节点，然后需要向下遍历调整堆。
如果是由于节点的键变得大于它的父亲而违反了堆的性质，则可以通过交换该节点和它的父亲的位置。交换后，节点大于它的两个孩子（
一个是原来的父亲，一个是原来父亲的另一个孩子），但它仍有可能大于现在的父亲，因此需要继续调整，直到遇到一个真正比它大的父节点或者到达根的位置才结束。
如果是由于节点的键变得小于它的一个或者两个孩子而违反了堆的性质。则可以通过交换此节点和它的大孩子来进行修改。这可能导致孩子
的违规，然后就按照这种方式继续调整，直到到达不小于它的所有孩子的节点或者叶子节点才结束。</p><h3 id=自底向上堆化>自底向上堆化</h3><p>向上遍历堆，只要 <strong><code>a[k/2]</code></strong> &lt; <strong><code>a[k]</code></strong> 就交换 <strong><code>k</code></strong> 处和 <strong><code>k/2</code></strong> 处的节点的位置。继续此过程，或者直到到达根节点为止</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>fixUp</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>int</span> s <span style=color:#f92672>=</span> right;
    <span style=color:#66d9ef>int</span> f <span style=color:#f92672>=</span> s <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>while</span>(f <span style=color:#f92672>&gt;=</span> left){
        <span style=color:#66d9ef>if</span>(a[f] <span style=color:#f92672>&lt;</span> a[s]) exchange(a[f], a[s]);
        s <span style=color:#f92672>=</span> f;
        f <span style=color:#f92672>=</span> s <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
    }
}
</code></pre></div><h3 id=自顶向下堆化>自顶向下堆化</h3><p>向下遍历堆， 交换位置 <strong><code>k</code></strong> 处的节点和它孩子中较大的那个节点（如果有需要的话），当位置 <strong><code>k</code></strong> 处的节点不小于它的孩子或者到达了底端就停止。
需要注意的是：如果 <strong><code>N</code></strong> 为偶数，且 <strong><code>k = N/2</code></strong> 时， 它只有一个孩子节点。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>fixDown</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>int</span> f <span style=color:#f92672>=</span> left;
    <span style=color:#66d9ef>int</span> s <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> f <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>//左孩子
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span>(s <span style=color:#f92672>&lt;=</span> right){  <span style=color:#75715e>// 没有到达底端
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(s <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;=</span> right <span style=color:#f92672>&amp;&amp;</span> less(a[s], a[s <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>])) s<span style=color:#f92672>++</span>; <span style=color:#75715e>// 找大孩子
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>less(a[f], a[s])) <span style=color:#66d9ef>break</span>;  <span style=color:#75715e>// 已经满足堆的条件，跳出
</span><span style=color:#75715e></span>        exchange(a[s], a[f]);   <span style=color:#75715e>// 交换
</span><span style=color:#75715e></span>        f <span style=color:#f92672>=</span> s;  <span style=color:#75715e>// 继续
</span><span style=color:#75715e></span>        s <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> f <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
    }
}
</code></pre></div><h3 id=排序方法>排序方法</h3><p>移出堆顶元素，然后调整堆。重复直到堆中只有一个元素。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>heapSort</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> N <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// 初始化i为最后一个父节点，从最后一个父节点开始调整，因为所有的叶子节点都是堆了
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(;i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>;i<span style=color:#f92672>--</span>) fixDown(a, i, N); <span style=color:#75715e>// 建大顶堆
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> right;i <span style=color:#f92672>&gt;=</span> left;){
        exchange(a[left], a[i]);  <span style=color:#75715e>// 把根节点交换到最后
</span><span style=color:#75715e></span>        fixDown(a, left, <span style=color:#f92672>--</span>i);  <span style=color:#75715e>// 调整
</span><span style=color:#75715e></span>    }
}
</code></pre></div><h2 id=基数排序>基数排序</h2><blockquote><p>引入：当我们在电话簿中查找某个人的电话时，我们通常只输入前几个字母，然后就能得到电话号码所在的页。为了在排序算法中取得相似效率，可以将比较键的抽象转化为另一种抽象。将这些键分解为一系列定长片段或字节。然后每次处理其中的一个片段，这种排序方法叫做基数排序。基数排序算法把键当作以R为基数的数值系统表示的数，R可取不同的值，分别处理这些数中的单个数字。
基数排序有两种：一种时从左到右按顺序检查键中的位，称为最高位基数排序。另一种采用从右到左的顺序，称为最低为基数排序。</p></blockquote><p>以16进制为例，可以通过右移运算取得int(这里int为32 位)型数组 <strong><code>a[i]</code></strong> 的各个字节的数字:最低位(a[i] &#187; 0) & 0xff 、次低位(a[i] &#187; 8) & 0xff 以及(a[i] &#187; 16) & 0xff 和(a[i] &#187; 24) & 0xff。我们需要256(0xff - 0x00 + 1 = 256)个桶。稍微修改键索引计数的程序就得到了基数排序的程序。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>radix</span>(<span style=color:#66d9ef>int</span> b, type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    <span style=color:#66d9ef>int</span> i, j, M <span style=color:#f92672>=</span> <span style=color:#ae81ff>256</span>;
    <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, cnt[M];
    type <span style=color:#f92672>*</span>aux <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> type[N];
    <span style=color:#66d9ef>for</span>(j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;j <span style=color:#f92672>&lt;</span> M;j<span style=color:#f92672>++</span>) cnt[j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 初始化计数为0
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> left;i <span style=color:#f92672>&lt;=</span> right;i<span style=color:#f92672>++</span>) cnt[((a[i] <span style=color:#f92672>&gt;&gt;</span> b <span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xff</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]<span style=color:#f92672>++</span>;  <span style=color:#75715e>// 统计出现频率
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(j <span style=color:#f92672>=</span> left;j <span style=color:#f92672>&lt;</span> M;j<span style=color:#f92672>++</span>) cnt[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+=</span> cnt[j]; <span style=color:#75715e>//得到小于等于计数器对应计数值键的数量,将频率转换为索引
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> left;i <span style=color:#f92672>&lt;=</span> right;i<span style=color:#f92672>++</span>) aux[cnt[(a[i] <span style=color:#f92672>&gt;&gt;</span> b <span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xff</span>]<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> a[i]; <span style=color:#75715e>//将键分不到辅助数组中
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> left;i <span style=color:#f92672>&lt;=</span> right;i<span style=color:#f92672>++</span>) a[i] <span style=color:#f92672>=</span> aux[i]; <span style=color:#75715e>// 回写
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>delete</span> []aux;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>radixSort</span>(type a[], <span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right){
    radix(<span style=color:#ae81ff>0</span>, a, left, right);
    radix(<span style=color:#ae81ff>1</span>, a, left, right);
    radix(<span style=color:#ae81ff>2</span>, a, left, right);
    radix(<span style=color:#ae81ff>3</span>, a, left, right);
}
</code></pre></div></div><footer class=entry-footer><div class="container sep-before"><div class=categories><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5A2 2 0 014 3H9l2 3h9a2 2 0 012 2z"/></svg><span class=screen-reader-text>分类: </span><a class=category href=/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a></div><div class=tags><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2H12l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=screen-reader-text>标签: </span><a class=tag href=/tags/c%E7%AE%97%E6%B3%95/>C算法</a></div></div></footer></article><nav class=entry-nav><div class=container><div class="prev-entry sep-before"><a href=/reading_notes/algorithms_in_c/josepus-problem/><span aria-hidden=true><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="20" y1="12" x2="4" y2="12"/><polyline points="10 18 4 12 10 6"/></svg>Previous</span>
<span class=screen-reader-text>上一篇: </span>约瑟夫问题</a></div><div class="next-entry sep-before"><a href=/reading_notes/algorithms_in_c/binary-tree/><span class=screen-reader-text>下一篇: </span>树<span aria-hidden=true>下一个<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="4" y1="12" x2="20" y2="12"/><polyline points="14 6 20 12 14 18"/></svg></span></a></div></div></nav></main><footer id=footer class=footer><div class="container sep-before"><section class="widget widget-social_menu sep-after"><nav aria-label=社交菜单><ul><li><a href=https://github.com/zhannicholas target=_blank rel="noopener me"><span class=screen-reader-text>Open Github account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li><a href=https://t.me/zhannicholas target=_blank rel="noopener me"><span class=screen-reader-text>Open Telegram account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><title>Telegram icon</title><path d="M23.91 3.79 20.3 20.84c-.25 1.21-.98 1.5-2 .94l-5.5-4.07-2.66 2.57c-.3.3-.55.56-1.1.56-.72.0-.6-.27-.84-.95L6.3 13.7.85 12c-1.18-.35-1.19-1.16.26-1.75l21.26-8.2c.97-.43 1.9.24 1.53 1.73z"/></svg></a></li><li><a href=mailto:zhan_nicholas@outlook.com target=_blank rel="noopener me"><span class=screen-reader-text>Contact via Email</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></li><li><a href=https://linkedin.com/in/%e4%bc%9f%e4%bc%9f-%e8%a9%b9-27871a104 target=_blank rel="noopener me"><span class=screen-reader-text>Open Linkedin account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li></ul></nav></section><div class=copyright><p>&copy; 2018-2021 Nicholas Zhan</p></div></div></footer></div></div><script>window.__assets_js_src="/assets/js/"</script><script src=/assets/js/main.c3bcf2df.js></script><script src=/js/custom.js></script></body></html>