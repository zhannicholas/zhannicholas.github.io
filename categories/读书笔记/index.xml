<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>读书笔记 on Nicholas Zhan</title><link>https://zhannicholas.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link><description>Recent content in 读书笔记 on Nicholas Zhan</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 24 Nov 2021 20:52:36 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>Java Performance: foundamentals</title><link>https://zhannicholas.github.io/notebook/reading_notes/java_performance/java_performance_fundamentals/</link><pubDate>Wed, 24 Nov 2021 20:52:36 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/java_performance/java_performance_fundamentals/</guid><description>Notes from Java Performance, 2nd Edition by Scott Oaks. To be a good Java Performance engineer, we need some specific knowledge. This knowledge falls into two broad categories: The performance of the Java Virtual Machine (JVM) itself: the way that the JVM is configured affects many aspects of a program’s performance. To understand how the features of the Java platform affect performance.</description></item><item><title>内存虚拟化</title><link>https://zhannicholas.github.io/notebook/reading_notes/ostep/virtualization-memory/</link><pubDate>Fri, 19 Mar 2021 22:36:40 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/ostep/virtualization-memory/</guid><description>地址空间 操作系统为用户提供了一个易于使用的物理内存抽象，这个抽象叫做 地址空间（address space）。在系统中，地址空间是运行的程序看到</description></item><item><title>CPU 虚拟化</title><link>https://zhannicholas.github.io/notebook/reading_notes/ostep/virtualization-cpu/</link><pubDate>Mon, 15 Mar 2021 21:28:39 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/ostep/virtualization-cpu/</guid><description>进程 进程即运行中的程序。程序本身是没有生命周期的，它只是存在磁盘上的一些指令（也可能是一些静态数据）。事实表明，人们通常希望同时运行多个程序</description></item><item><title>Introduction to Operating Systems</title><link>https://zhannicholas.github.io/notebook/reading_notes/ostep/introduction_to_operating_systems/</link><pubDate>Sun, 14 Mar 2021 23:03:01 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/ostep/introduction_to_operating_systems/</guid><description>程序运行时会发生什么？ 一个正在运行的程序会做一件非常简单的事情：执行指令。CPU 从内存中取出（fetch）一条指令，对其进行译码（decod</description></item><item><title>超级搜索术</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%B6%85%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%9C%AF/</link><pubDate>Mon, 08 Mar 2021 23:09:31 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%B6%85%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%9C%AF/</guid><description>人生中 99% 的问题早已有答案，你只要搜索就好。只要你去搜索，就能一直站在巨人的肩膀上去寻求新突破，做出微创新。 ——朱丹 前言 朱丹老师的《超级搜索术</description></item><item><title>Building Abstractions with Functions</title><link>https://zhannicholas.github.io/notebook/reading_notes/sicp_in_python/building_abstractions_with_functions/</link><pubDate>Sun, 13 Dec 2020 20:16:09 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/sicp_in_python/building_abstractions_with_functions/</guid><description>1.1 Introduction The nature of computers is described in Stanford&amp;rsquo;s introductory course as: The fundamental equation of computers is: computer = powerful + stupid. Computers are very powerful, looking at volumes of data very quickly. Computers can perform billions of operations per second, where each operation is pretty simple. Computers are also shockingly stupid and fragile. The operations that they can do are extremely rigid, simple, and mechanical. The computer</description></item><item><title>自旋锁</title><link>https://zhannicholas.github.io/notebook/reading_notes/the_art_of_multiprocessor_programming/spinlock/</link><pubDate>Sun, 13 Dec 2020 20:13:13 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/the_art_of_multiprocessor_programming/spinlock/</guid><description>任何互斥协议都会面临一个问题：当无法获得锁时，该怎么做？有两种方案：一种是继续进行尝试，这种锁称为 自旋锁（spin lock），反复检测锁的这</description></item><item><title>Amdahl定律</title><link>https://zhannicholas.github.io/notebook/reading_notes/the_art_of_multiprocessor_programming/amdahls_law/</link><pubDate>Sun, 13 Dec 2020 20:11:57 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/the_art_of_multiprocessor_programming/amdahls_law/</guid><description>加速比 : 对于某一项工作，加速比指的是一个处理器完成该工作所用的时间与采用n个处理器并行完成该工作所用时间的比值。 Amdahl定律给出了n个处</description></item><item><title>Security</title><link>https://zhannicholas.github.io/notebook/reading_notes/modern_operating_systems/security/</link><pubDate>Sun, 13 Dec 2020 19:59:39 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/modern_operating_systems/security/</guid><description>安全环境 威胁 信息系统的安全性目标通常可以分解为三个部分: 机密性(confidentiality)：是机密的数据处于保密状态。系统应该保证数据</description></item><item><title>多处理机系统</title><link>https://zhannicholas.github.io/notebook/reading_notes/modern_operating_systems/multiple_processor_systems/</link><pubDate>Sun, 13 Dec 2020 19:56:36 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/modern_operating_systems/multiple_processor_systems/</guid><description>从计算机诞生之日起，人们就无休止地追求着更强大地计算能力。过去地解决方案是使时钟走得更快，但是现在时钟速度已经很难再进一步提升了。计算机虽然</description></item><item><title>Design concepts for engineers</title><link>https://zhannicholas.github.io/notebook/reading_notes/design_concepts_for_engineers/</link><pubDate>Sun, 13 Dec 2020 19:52:15 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/design_concepts_for_engineers/</guid><description>Taken from Design Concepts for Engineers (Fifth Edition) 2020.11.22 第1章 工程是什么 作为一名有抱负的工程师，你有很多需要学习的东西。你必须掌握工程的基础知识：数学、物理、化学和生物。你必须学</description></item><item><title>《设计模式的艺术》读书笔记之十三：代理模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%89%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 27 Oct 2018 21:41:48 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%89%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid><description>代理模式（Proxy Pattern）:给某一个对象提供一个代理，并由代理对象控制对原对象的引用。 代理模式中引入了一个新的代理对象，代理对象可</description></item><item><title>《设计模式的艺术》读书笔记之十二：享元模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%BA%8C%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link><pubDate>Wed, 17 Oct 2018 12:24:25 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%BA%8C%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid><description>享元模式（Flyweight Pattern）：运行共享技术有效的支持大量 细粒度 对象的复用，又称轻量级模式。 享元模式以共享的方式高效的支持大量</description></item><item><title>《设计模式的艺术》读书笔记之十一：外观模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 15 Oct 2018 10:39:37 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid><description>外观模式（Facade Pattern）：外部与一个子系统的通信通过一个统一的外观角色进行，为子系统中的一组接口提供一个统一的入口。外观模式又</description></item><item><title>《设计模式的艺术》读书笔记之十：装饰模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 15 Oct 2018 05:23:56 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</guid><description>装饰模式（Decotator Pattern）：动态的给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更加灵活。 装饰模</description></item><item><title>《设计模式的艺术》读书笔记之九：组合模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B9%9D%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 13 Oct 2018 11:16:37 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B9%9D%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid><description>组合模式（Composite Pattern）：组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构。组合模式对单个对象（叶子对象）</description></item><item><title>《设计模式的艺术》读书笔记之八：桥接模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AB%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link><pubDate>Tue, 09 Oct 2018 08:48:04 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AB%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid><description>桥接模式（Bridge Pattern）：将类的功能层次结构（抽象部分）和实现层次结构（实现部分）分离，使二者能够 独立 的变化，并在二者之间搭建</description></item><item><title>《设计模式的艺术》读书笔记之七：适配器模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%83%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 08 Oct 2018 14:53:10 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%83%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>适配器模式（Adapter Pattern）：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，又称包装器（Wrappe</description></item><item><title>《设计模式的艺术》读书笔记之六：建造者模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 07 Oct 2018 09:04:12 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>建造者模式（Builder Pattern）：将一个复杂的对象的构建与它的表示分离，使得同样的创建过程可以创建不同的表示。建造者模式又称为生成</description></item><item><title>《设计模式的艺术》读书笔记之五：原型模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 06 Oct 2018 11:35:30 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>原型模式（Prototype Pattern）：使用原型实例指定创建对象，并通过克隆这些原型得到新的对象。 原型模式的工作原理就是：将一个原型对</description></item><item><title>《设计模式的艺术》读书笔记之四：抽象工厂模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%9B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 05 Oct 2018 13:17:22 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%9B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列相关或者相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称Ki</description></item><item><title>《设计模式的艺术》读书笔记三：工厂方法模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link><pubDate>Wed, 03 Oct 2018 08:40:29 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid><description>工厂方法模式（Factory Method Pattern）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化，这让一个类的实例化延迟到了其子类。工</description></item><item><title>《设计模式的艺术》读书笔记二：简单工厂模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Tue, 02 Oct 2018 11:04:22 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>简单工厂模式（Simple Factory Pattern）：定义一个工厂类，工厂类根据参数返回不同的实例，被创建的实例通常具有共同的父类。由于创建实例的方</description></item><item><title>《设计模式的艺术》读书笔记一：单例模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Oct 2018 13:28:15 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid><description>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类就是单例类。 从单例模式</description></item><item><title>产生均匀随机排列的两种方法</title><link>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/two-ways-to-produce-a-uniform-random-permutation/</link><pubDate>Wed, 11 Jul 2018 12:46:30 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/two-ways-to-produce-a-uniform-random-permutation/</guid><description>许多随机算法通过排列给定的输入数组来使输入随机化。这里的目标是构造数组 A 的一个随机排列。 方法一：排序 为数组的每一个元素 A[i] 分配一个随机的优先级</description></item><item><title>通过偏概率0/1生成器，得到无偏概率0/1生成器</title><link>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/%E9%80%9A%E8%BF%8701%E6%9C%89%E5%81%8F%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%97%A0%E5%81%8F%E6%A6%82%E7%8E%87/</link><pubDate>Wed, 11 Jul 2018 09:51:21 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/%E9%80%9A%E8%BF%8701%E6%9C%89%E5%81%8F%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%97%A0%E5%81%8F%E6%A6%82%E7%8E%87/</guid><description>问题描述 这是《算法导论》的习题5.1-3： 假设你希望以各1/2的概率输出0和1。你可以自由使用一个输出0或1的过程BIASED-RANDOM</description></item><item><title>矩阵乘法</title><link>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/matrix-multiplication/</link><pubDate>Mon, 02 Jul 2018 08:44:56 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/matrix-multiplication/</guid><description>矩阵乘法 矩阵相乘只有在第一个矩阵的列数（column）和第二个矩阵的行数（row）相同时才有定义。若 A 为 m x n 矩阵，B为 n x p 矩阵，则他们的</description></item><item><title>最大子数组问题</title><link>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/maximum-sub-array-problem/</link><pubDate>Fri, 29 Jun 2018 10:44:26 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/maximum-sub-array-problem/</guid><description>问题 有一个数组A，寻找一个 A[] 的子数组 B[] ， 使得B的元素和大于A的任何一个子数组。比如A = [13, -3, 25, 20, -4, -20, -25, 18, 20, -5, 16, -5, -22, 18, -6, 8], 我们要求的 B[] 就是：[1</description></item><item><title>哈希表</title><link>https://zhannicholas.github.io/notebook/reading_notes/algorithms_in_c/hashing-table/</link><pubDate>Sun, 03 Jun 2018 10:49:04 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/algorithms_in_c/hashing-table/</guid><description>键索引搜索方法中，表中的第 i 个位置保存了键为 i 对应的项，以便达到快速访问的目的。它将键作为数组的索引，并且依赖于同一范围内不同整数的键作为表</description></item><item><title>树</title><link>https://zhannicholas.github.io/notebook/reading_notes/algorithms_in_c/binary-tree/</link><pubDate>Sat, 02 Jun 2018 10:07:28 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/algorithms_in_c/binary-tree/</guid><description>树是满足一定要求的顶点和边的非空集合。 二叉树 二叉树的每个节点至多有2个子节点。 一种表示方法： struct Node{type key; Node *lchild, *richild;} typedef Node *link; 这种表示方法只适合从根节点开始</description></item><item><title>各种排序算法</title><link>https://zhannicholas.github.io/notebook/reading_notes/algorithms_in_c/sorting/</link><pubDate>Wed, 30 May 2018 18:55:31 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/algorithms_in_c/sorting/</guid><description>学习《C算法》中排序这一部分时做的一些笔记。主要使用C++实现了书中的大部分排序算法。 开始之前 为了方便增加代码的灵活性，我采取了书中作者的部</description></item><item><title>约瑟夫问题</title><link>https://zhannicholas.github.io/notebook/reading_notes/algorithms_in_c/josepus-problem/</link><pubDate>Sun, 27 May 2018 11:35:18 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/algorithms_in_c/josepus-problem/</guid><description>问题由来 这是一个很经典的问题了，大概就是说： 已知n个人（以编号1，2，3&amp;hellip;n分别表示）围成一个圆圈。 从第一个人开始报数，数到m</description></item><item><title>厄拉多筛法求素数</title><link>https://zhannicholas.github.io/notebook/reading_notes/algorithms_in_c/seive-of-eratosthenes/</link><pubDate>Sat, 26 May 2018 10:43:44 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/algorithms_in_c/seive-of-eratosthenes/</guid><description>筛法原理 给出要筛数值的范围maxn，找出maxn以内所有的素数。先用2去筛，即把2留下，把2的倍数剔除掉；再用下一个素数，也就是3筛，把3留</description></item><item><title>并查集</title><link>https://zhannicholas.github.io/notebook/reading_notes/algorithms_in_c/union-find/</link><pubDate>Sat, 26 May 2018 10:43:44 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/algorithms_in_c/union-find/</guid><description>记录一下最近学习的并查集。 问题引入 假定有一个整数对序列，其中每个整数代表某种类型的一个对象，而且将 p-q 解释为“p与q连通”。关系是可传递的，如</description></item></channel></rss>