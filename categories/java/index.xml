<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Nicholas Zhan</title><link>https://zhannicholas.github.io/categories/java/</link><description>Recent content in Java on Nicholas Zhan</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 27 Apr 2021 20:38:39 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>线程安全性</title><link>https://zhannicholas.github.io/posts/java/concurrency/thread_safety/</link><pubDate>Tue, 27 Apr 2021 20:38:39 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/concurrency/thread_safety/</guid><description>我们在工作中经常听人提起线程安全，但线程安全似乎没有一个明确的定义。Java Concurrency in Practice 这本 Java 并发宝典是这样解释线程安全的： 当多个线程访问某个类时</description></item><item><title>Java 对象的一生</title><link>https://zhannicholas.github.io/posts/java/jvm/java_object_lifecycle/</link><pubDate>Wed, 21 Apr 2021 23:30:52 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jvm/java_object_lifecycle/</guid><description>The Truth About Garbage Collection 这篇文章写得挺好的，本文的很多内容也是基于这篇文章而来。 Java 是一门面向对象的编程语言，在程序的运行过程中，不断有新的对象被创建出来，</description></item><item><title>Java 中的引用与对象可达性</title><link>https://zhannicholas.github.io/posts/java/java_lang/references_and_reachability_in_java/</link><pubDate>Tue, 20 Apr 2021 21:40:00 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/java_lang/references_and_reachability_in_java/</guid><description>JDK 1.2 之后，Java 将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Refere</description></item><item><title>JDBC</title><link>https://zhannicholas.github.io/posts/java/jdbc/jdbc/</link><pubDate>Sun, 18 Apr 2021 23:00:39 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jdbc/jdbc/</guid><description>JDBC（Java DataBase Connectivity）是 Java 程序与关系型数据库交互的统一 API，它由两部分 API 组成： 面向 Java 开发者的 Java API，这一部分 API 独</description></item><item><title>HotSpot VM中的内存管理(J2SE 5.0)</title><link>https://zhannicholas.github.io/posts/java/jvm/memory_management_in_javase5/</link><pubDate>Sun, 13 Dec 2020 18:44:54 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jvm/memory_management_in_javase5/</guid><description>这篇笔记的主要内容来自Memory Management in the Java HotSpot VM。其主要讲的是J2SE 5.0中HotSpot VM的内存管理，文章中描述了J2SE5.0中的垃</description></item><item><title>HotSpot引擎架构</title><link>https://zhannicholas.github.io/posts/java/jvm/hotspot_engine_architecture/</link><pubDate>Sun, 13 Dec 2020 18:43:36 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jvm/hotspot_engine_architecture/</guid><description>这篇笔记主要来自于The Java HotSpot Performance Engine Architecture，感觉主要是在讲 JDK8中 HotSpot VM 的整体架构。 Java HotSpot VM 原来是 Sun 公司为 Java 平台实现的高性能虚拟</description></item><item><title>垃圾回收调优指南(Java SE 8)</title><link>https://zhannicholas.github.io/posts/java/jvm/garbage_collection_tuning_guide_in_javase8/</link><pubDate>Sun, 13 Dec 2020 18:40:26 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jvm/garbage_collection_tuning_guide_in_javase8/</guid><description>这篇笔记地主要内容来自Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide。文章中介绍了一些调优目标以及 JDK 8中 Hotspot VM 提供的一些垃圾收集器，并提出了很多调优建议</description></item><item><title>线程池</title><link>https://zhannicholas.github.io/posts/java/concurrency/thread_pool/</link><pubDate>Sun, 13 Dec 2020 18:35:11 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/concurrency/thread_pool/</guid><description>线程池是管理一组同构工作线程的资源池，内部主要分为四部分： 线程池管理器：负责线程池的创建、销毁、添加任务等管理工作。 工作队列（Work Que</description></item><item><title>线程</title><link>https://zhannicholas.github.io/posts/java/concurrency/thread/</link><pubDate>Sun, 13 Dec 2020 18:32:20 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/concurrency/thread/</guid><description>进程（process）是资源分配的基本单元，而线程（thread）是程序执行的基本单元。一个进程可以包含多个线程，多个线程之间共享进程的资源</description></item><item><title>同步</title><link>https://zhannicholas.github.io/posts/java/concurrency/synchronization/</link><pubDate>Sun, 13 Dec 2020 18:31:16 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/concurrency/synchronization/</guid><description>Java语言提供了多种线程间通信机制（同步、while轮询、等待/通知、管道等等），其中最基础的通信方式就是 同步（synchronizati</description></item><item><title>锁</title><link>https://zhannicholas.github.io/posts/java/concurrency/locks/</link><pubDate>Sun, 13 Dec 2020 18:29:44 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/concurrency/locks/</guid><description>文章中涉及的源代码摘自 OpenJdk 11。 乐观锁与悲观锁 乐观锁与悲观锁是一种广义上的概念，体现了我们看待线程同步的不同角度。 乐观锁 乐观锁采用的思想是：冲</description></item><item><title>Java 代理</title><link>https://zhannicholas.github.io/posts/java/java_lang/proxy/</link><pubDate>Sun, 13 Dec 2020 18:25:38 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/java_lang/proxy/</guid><description>Wikipedia 中是这样描述 Proxy 的： A proxy, in its most general form, is a class functioning as an interface to something else. The proxy could interface to anything: a network connection, a large object in memory, a file, or some other resource that is expensive or impossible to duplicate. In short, a proxy is a wrapper or agent object that is being called by the</description></item><item><title>反射</title><link>https://zhannicholas.github.io/posts/java/java_lang/reflection/</link><pubDate>Sun, 13 Dec 2020 18:22:56 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/java_lang/reflection/</guid><description>反射(Reflection) 是Java语言的一大特性，它允许Java程序在运行过程中获取自身的相关信息，还能改变程序的内部属性。我们可以使用</description></item><item><title>Cloning Objects</title><link>https://zhannicholas.github.io/posts/java/java_lang/cloning_objects/</link><pubDate>Sun, 13 Dec 2020 18:19:11 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/java_lang/cloning_objects/</guid><description>通过克隆（Clone），我们可以快速构建出一个已有对象的副本。 浅克隆 VS 深克隆 浅克隆（Shadow Clone） 或 浅复制（Shallow Copy</description></item><item><title>Nested Classes</title><link>https://zhannicholas.github.io/posts/java/java_lang/nested_classes/</link><pubDate>Sun, 13 Dec 2020 18:18:04 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/java_lang/nested_classes/</guid><description>Java允许我们在一个类中定义另一个类，后者被称为嵌套类（nested class）。嵌套类可以分为两种： 静态内部类（static nested class</description></item><item><title>What is Servlet</title><link>https://zhannicholas.github.io/posts/java/jakartaee/what_is_servlet/</link><pubDate>Sun, 13 Dec 2020 18:07:45 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jakartaee/what_is_servlet/</guid><description>A servlet is a Java™ technology-based Web component, managed by a container, that generates dynamic content. 和其它基于Java的组件一样，Servlet也由Java类组成，这些Java类(.class文件)会</description></item><item><title>The Servlet Interface</title><link>https://zhannicholas.github.io/posts/java/jakartaee/the_servlet_interface/</link><pubDate>Sun, 13 Dec 2020 18:04:42 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jakartaee/the_servlet_interface/</guid><description>**Servlet接口是Java Servlet API的核心抽象，所有的Servlet都直接或间接地实现它。GenericServlet**和 **Http</description></item><item><title>About Jakarta EE</title><link>https://zhannicholas.github.io/posts/java/jakartaee/about/</link><pubDate>Sun, 13 Dec 2020 18:03:23 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jakartaee/about/</guid><description>Java EE(Java Platform, Enterprise Edition)是构建在Java SE之上的一套企业级标准，早期被称为J2EE(Java 2 Platform Enterprise Edition)，现在则被称为Jakar</description></item><item><title>Java Web复习笔记</title><link>https://zhannicholas.github.io/posts/grocery/java-web%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><pubDate>Sun, 19 Aug 2018 23:02:41 +0800</pubDate><guid>https://zhannicholas.github.io/posts/grocery/java-web%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid><description>Java WEB复习笔记 这是为了准备秋招面试而对Java Web开发进行的复习。 首先，对于一个Java Web应用，它由一组Servlet、HTML页、</description></item></channel></rss>