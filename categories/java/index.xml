<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on 's Digital Garden</title><link>https://zhannicholas.github.io/categories/java/</link><description>Recent content in Java on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 01 Sep 2021 09:46:58 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 中的原子类</title><link>https://zhannicholas.github.io/posts/java/concurrency/java_atomic_variables/</link><pubDate>Wed, 01 Sep 2021 09:46:58 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/concurrency/java_atomic_variables/</guid><description>一谈到原子类（或原子变量），我们可能就会想知道它和我们编程中常说的原子性（Atomicy）之间是否有关系。若一组操作具备“要么全部成功，要么全部失败，不能一部分成功一部分失败”的性质，那么这组操作就是原子操作，这组操作具备原子性。
在 Java 中，原子操作可以通过锁和循环 CAS 的方式实现。其中 CAS 操作是利用处理器提供的 COMPXCHG 指令实现的。自旋 CAS 实现的基本思路是循环进行 CAS 操作直到成功为止。但 CAS 存在三个问题：
ABA问题。可以使用版本号来解决。 循环时间长开销大。这一般出现在自旋CAS长时间不成功的情况下。 只能保证一个共享变量的原子操作。对于多个共享变量的原子操作，一般采用锁来解决，也可以将多个共享变量封装进一个对象，然后使用AtomicReference类来解决。 JVM 内部实现了很多锁机制，有意思的是除了偏向锁，JVM 实现锁的方式都用了循环 CAS，即当一个线程进入同步代码块时使用循环 CAS 获取锁，离开同步代码块时使用循环 CAS 释放锁。CAS 最直接的体现就是 java.util.concurrent.atomic 包下定义的各种无锁原子类，这些原子类都支持单个变量上的原子操作。举个例子，i++ 在并发环境中并不是线程安全的，要保证线程安全，我们需要给 i++ 加锁。实际上，我们也可以直接使用原子类提供的 getAndIncrement 方法完成同样的操作。由于原子类底层采用的 CAS 实现，在并发竞争不是特别激烈的情况下，效率要高于同步互斥锁。
根据操作类型的不同，可以大致将 java.util.concurrent.atomic 下的原子类分成六种：
类型 具体类 基本类型原子类（AtomicXxx） AtomicInteger, AtomicLong, AtomicBoolean 引用类型原子类（AtomicXxxReference） AtomicReference, AtomicStampedReference, AtomicMarkableReference 数组类型原子类（AtomicXxxArray） AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray 字段更新原子类（AtomicXxxFieldUpdater） AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater 加法器（Adder） LongAdder, DoubleAdder 累加器（Accumulator） LongAccumulator, DoubleAccumulator 下面分别最这六大类型的原子类进行介绍。
基本类型原子类 基本类型原子类包括三种：AtomicInteger、AtomicLong 和 AtomicBoolean。其中 AtomicInteger 和 AtomicLong 是对 int、long 的封装，而 AtomicBoolean 内部封装的变量的类型并不是 boolean，而是 int，它用 0 和 1 分别表示 false 和 true。三种类型都提供了对内部封装变量的原子性访问和更新操作，我们可以在并发环境中放心使用。</description></item><item><title>Java 中的并发队列</title><link>https://zhannicholas.github.io/posts/java/concurrency/java_concurrent_queue/</link><pubDate>Tue, 31 Aug 2021 21:11:09 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/concurrency/java_concurrent_queue/</guid><description>并发队列（或线程安全的队列）是在我们在进行多线程并发编程时经常使用的一种数据结构。并发队列不仅具备基本队列的所有特性，还是线程安全的。由于并发队列在实现时已经考虑了各种线程安全问题，所以我们可以在并发环境中直接使用，而不用担心出现线程安全问题，有利于降低开发难度和工作量。
Java 中的并发队列可以分为阻塞队列和非阻塞队列两大类。
阻塞队列 除了队列的基本功能外，阻塞队列最大的特点在于 阻塞：在读取元素时，若队列为空，则阻塞读取操作直到队列非空；在写入元素时，若队列已满，则阻塞写入操作直到队列中出现可用空间。
阻塞队列的典型代表是 BlockingQueue 接口的各个实现类，主要有 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、DelayQueue、PriorityBlockingQueue 和 LinkedTransferQueue。
根据阻塞队列容量的大小，又可以将其分为有界队列和无界队列。有界队列的典型代表是 ArrayBlockingQueue，一旦队列满了就无法入队新的元素了，因为它不会扩容。无界队列的典型代表是 LinkedBlockingQueue，其容量最大为 Integer.MAX_VALUE，即 2^31 - 1，这么大的容量几乎不可能被填满，故可以近似看成无限容量。
在阻塞队列中有很多相似的方法，比较容易混淆。因此，有必要对它们进行分类整理，根据方法是否抛出异常、是否返回特殊值、是否阻塞、是否具有超时时间，JDK 已经分类好了：
Throws exception Special value Blocks Times out Insert add(e) offer(e) put(e) offer(e, time, unit) Remove remove() poll() take() poll(time, unit) Examine element() peek() not applicable not applicable 根据操作类型的不同，特殊值（Special Value）略有差异：布尔类型的特殊值为 false，对象类型的特殊值为 null。
非阻塞队列 非阻塞队列家族则没有阻塞队列家族这么庞大，典型代表是 ConcurrentLinkedQueue，其内部通过 CAS 保证线程安全，不会阻塞线程，适合并发不是特别剧烈的场景。</description></item><item><title>Java 中的 hashCode() 与 equals()</title><link>https://zhannicholas.github.io/posts/java/lang/java-hashcode-equals-contracts/</link><pubDate>Fri, 27 Aug 2021 22:22:46 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/lang/java-hashcode-equals-contracts/</guid><description>有一道经典的 Java 面试题叫：重写了 equals()，为什么还要重写 hashCode()？
不幸的是，笔者最近也被问到这个问题的变种了。当时面试官的提问点有点奇葩，问我这两个方法在被调用时谁先谁后的问题。笔者当时想，这面试官是不是八股文看多了，连这两方法调用先后都问出来了吗？严格上来说，equals() 和 hashCode() 在绝大多数情况下都是单独调用的，只有在像 HashMap 这样的数据结构的内部实现中，才会存在方法调用的先后关系。笔者当时也没完全搞清楚面试官到底想问什么，所以就象征性的回答了 hashCode() 先调用。今天，笔者突然想到这个问题，感觉当时面试官想问的是 HashMap 内部实现时对这两个方法的依赖情况。
在 Java 中，一切皆对象。并且所有的对象都直接或间接地继承自 java.lang.Object。Object 类定义了一系列 Java 对象所共有的方法，hashCode() 和 equals() 就在其中。
hashCode() {hashCode()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()) 方法用于返回对象的哈希值。Object 类定义了 hashCode() 的契约，这里我直接列出：
The general contract of hashCode is:
Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified.</description></item><item><title>线程安全</title><link>https://zhannicholas.github.io/posts/java/concurrency/thread_safety/</link><pubDate>Tue, 27 Apr 2021 20:38:39 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/concurrency/thread_safety/</guid><description>我们在工作中经常听人提起线程安全，但要是被问到什么是线程安全，我们可能就会挠挠脑袋了。因为线程安全并没有一个明确的定义。Java Concurrency in Practice 这本 Java 并发宝典是这样解释线程安全的：
当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。线程安全性对多个线程之间的操作提出了要求：多个线程之间的操作无论采用何种执行时序或交替方式，都要保证不变性条件不被破坏。
若一个类既不包含任何域，也不包含任何对其它类中域的引用，则称这个类是无状态的。无状态的对象一定是线程安全的。
本文的绝大部分内容也来自这本书。
线程安全问题 如果线程不安全，会出现哪些问题呢？常见的问题有三类：
运行结果错误 对象逃逸 活跃性问题 运行结果错误 最常见线程安全问题可能就是 运行结果错误 了。比如：
public class UnsafeCounter { private static volatile int count = 0; public static void main(String[] args) throws InterruptedException { Runnable r = () -&amp;gt; { for (int i = 0; i &amp;lt; 1000; i++) { count++; } }; Thread t1 = new Thread(r); t1.start(); Thread t2 = new Thread(r); t2.start(); // 等待两个线程运行结束 t1.</description></item><item><title>Java 对象的一生</title><link>https://zhannicholas.github.io/posts/java/jvm/java_object_lifecycle/</link><pubDate>Wed, 21 Apr 2021 23:30:52 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jvm/java_object_lifecycle/</guid><description>The Truth About Garbage Collection 这篇文章写得挺好的，本文的很多内容也是基于这篇文章而来。
Java 是一门面向对象的编程语言，在程序的运行过程中，不断有新的对象被创建出来，也不断有对象被回收。JVM 中的对象从创建到回收，通常会经历以下大多数状态：
Created In use (strongly reachable) Invisible Unreachable Collected Finalized Deallocated Created 对象的创建通常会经历以下几个步骤：
为对象分配空间 开始构造对象 调用父类的构造函数 初始化实例与实例变量 执行构造函数的剩余部分 这些操作的具体代价取决于 JVM 的实现，以及构造类的过程是如何实现的。对象被创建后，如果它被赋给某给变量（有变量引用了这个对象），它就会直接进入 In Use 状态。
其实以上五个步骤可以分为两个大的步骤——实例化（Instantiation）和初始化（Initialization）。为了便于理解，我举一个例子。先定义一个类 Bird，它有一个 name 属性：
public class Bird { private final String name; public Bird(String name) {this.name = name;} } 当我们想创建一个 Bird 对象时，我们会怎么做？最简单最直接的方法当然是使用 new 关键字啦。比如：
Bird eagle = new Bird(&amp;#34;eagle&amp;#34;); 这行代码包含三个部分：
声明（Declaration）：Bird eagle 声明了一个类型为 Bird 的变量，变量名为 eagle。 实例化（Instantiation）：Java 使用 new 关键字创建新对象。new 先为新对象分配内存，然后返回那块内存的引用，这个过程就是对象的实例化。 初始化（Initialization）：new 会调用构造器 Bird(&amp;quot;eagle&amp;quot;)，构造器会初始化前面创建的新对象。 In Use 若对象被至少一个强引用持有，它就处于使用中（In Use）状态。JDK 1.</description></item><item><title>Java 中的引用与对象可达性</title><link>https://zhannicholas.github.io/posts/java/lang/references_and_reachability_in_java/</link><pubDate>Tue, 20 Apr 2021 21:40:00 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/lang/references_and_reachability_in_java/</guid><description>JDK 1.2 之后，Java 将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）四种，这四种引用的强度依次减弱，它们与 Java 的对象回收有着很大的关系。
A reference object encapsulates a reference to some other object so that the reference itself may be examined and manipulated like any other object. Three types of reference objects are provided, each weaker than the last: soft, weak, and phantom. Each type corresponds to a different level of reachability.
这段话已经描述得很清楚了：Java 中有三种引用对象（reference object），它们封装了一些其它的对象，从而让我们可以像操作其它对象一样操作引用本身，不同引用对象的可达性不同。
除开与 Finalization 有关的类，下图展示了 java.lang.ref 包中的类结构：
Reference 对象用于维持对其它对象的引用，但 GC 仍然可以回收这些被引用的其它对象。当 GC 决定回收某个引用对象关联的对象时，它会将对应的引用对象放入与之关联的引用队列（ReferenceQueue）中，这样我们就可以得到对象被回收的通知了。</description></item><item><title>JDBC</title><link>https://zhannicholas.github.io/posts/java/jdbc/jdbc/</link><pubDate>Sun, 18 Apr 2021 23:00:39 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jdbc/jdbc/</guid><description>JDBC（Java DataBase Connectivity）是 Java 程序与关系型数据库交互的统一 API，它由两部分 API 组成：
面向 Java 开发者的 Java API，这一部分 API 独立于各个数据库产品的接口规范，是标准又统一的 Java　API。 面向数据库驱动程序开发者的 API，由数据库厂商实现，用于连接具体的数据库产品。 使用 JDBC 操作数据库的核心步骤 在实际开发 Java 程序时，我们可以通过 JDBC 连接到数据库，完成各种数据库操作。以下就是执行 SELECT 语句时发生的 JDBC 操作：
注册数据库驱动类，给出数据库连接信息（数据库地址、用户名、密码等） 创建 Connection 连接到数据库（调用 DriverManager.getConnection() 方法） 创建 Statement 对象（调用 Connection 的 createStatement() 或 prepareStatement() 方法） 通过 Statement 对象执行 SQL，得到 ResultSet 对象（查询结果集） 从 ResultSet 中读取数据 关闭 ResultSet、Statement 及 Connection 对象 数据库连接池 为什么要使用数据库连接池？数据库连接是整个服务中比较珍贵的资源之一，因为建立数据库连接涉及鉴权、握手等一系列网络操作。使用池化技术缓存数据库连接带来的好处还有很多，例如：
实现连接重用，从而提高系统的响应速度 控制数据库连接数量上限，防止连接过多造成数据库假死 统一连接管理，避免连接泄漏 连接池的连接数量上限一定要根据实际情况仔细选取。如果设置得过大，可能导致数据库因连接过多而假死或崩溃，从而影响服务的可用性。如果设置得过小，则可能无法让数据库达到最佳性能，造成资源浪费。
ORM 框架 ORM 框架的核心功能是：根据配置（一般是配置文件或者 Java 注解）实现对象模型（Java 程序）与关系模型（数据库）之间的映射。</description></item><item><title>HotSpot VM中的内存管理(J2SE 5.0)</title><link>https://zhannicholas.github.io/posts/java/jvm/memory_management_in_javase5/</link><pubDate>Sun, 13 Dec 2020 18:44:54 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jvm/memory_management_in_javase5/</guid><description>这篇笔记的主要内容来自Memory Management in the Java HotSpot VM 。其主要讲的是J2SE 5.0中HotSpot VM的内存管理，文章中描述了J2SE5.0中的垃圾收集器，并在如何选择和配置垃圾收集器、设置被管理内存的区域大小等方面提出了一些建议。
内存管理系统需要考虑以下三个方面：
如何分配内存。 如何识别存活对象。 如何回收死亡对象占据的空间，以便将来使用。 显式内存释放 vs 自动内存管理 动态内存分配 几乎所有的现代编程语言都采用动态内存分配(dynamic momory allocation)，即允许进程在运行时分配或释放那些无法在编译期间确定大小的对象，并且对象的存活时间可以超过创建它们的子程序的存活时间。动态分配的对象并不位于于栈(分配对象的程序的 活动记录（activation record） 或 栈帧（stack frame） )上，也没有被静态储存（对象的名字被绑定到编译或链接期间所确定的存储位置），而是位于堆（heap）中。在堆中分配对象有一些好处，它允许程序员：
动态选择新对象的大小，从而避免程序运行中出现因硬编码而出现的一些错误。 定义和使用像 list、tree、map 这样的递归数据结构。 将新创建的对象返回给父程序。例如工厂方法。 将函数作为另一个函数的返回结果。例如一些函数式编程语言中的 closure 和 suspension。 堆中分配的对象是通过 引用(reference) 来访问的。通常，引用是一个指向对象的指针，即对象在内存中的地址。然而，引用也可能间接地指向对象，例如引用指向 句柄(handle)，句柄再指向对象。句柄的优点是：在对象被移动时，只需要更新句柄中到对象的指针，而不需要更新程序中所有其它对该对象(或句柄)的引用。
显式内存释放 在一些编程语言里，程序员需要手动管理内存。手动管理内存一件非常复杂的工作，并可能出现很多错误，这些错误可能导致程序异常甚至崩溃。因此，绝大部分开发时间都被用在了调试并尝试解决这些问题上。手动回收可能会出现以下两个问题：
悬挂指针(dangling pointer)。当一个对象还被其它对象引用时，若该对象占用的内存被回收，那些指向它的引用就会称为悬挂指针。悬挂指针一旦出现，程序的行为就会变得不可预测。因为，当尝试通过悬挂指针访问原对象时，被引用的内存空间可能早已分配给其它对象。 内存泄漏(memory leak)。例如，为了释放一个单链表所占用的内存空间，我们需要回收链表中的所有节点，若只回收了头节点，其它节点就无法再被访问，它们占据的内存空间也就无法被回收。内存泄漏会不断的消耗可用内存，直至内存枯竭。 自动内存管理 自动化内存管理解决了显式内存管理中的很多问题。垃圾收集器(Garbage Collector, GC) 防止可以防止悬挂指针的出现，因为只有当一个对象不被任何其它对象引用时，这个对象才能被回收。原则上讲，GC会回收所有不可达对象，但有两点需要注意：
追踪式回收(tracing collection) 引入了“垃圾”这一定义明确的概念，但“垃圾”并不一定包括所有不再被使用的对象。 出于效率原因，某些对象可能不会被回收。 GC还解决了内存泄漏的问题，因为它会自动释放所有不再被引用的对象。
什么是垃圾收集 简而言之，垃圾收集器负责：
为新生对象分配内存。 保证不回收被引用的对象。 回收那些不再可达对象的所占据内存空间。 垃圾收集是指发现垃圾并回收的这一过程。那么何时会发生垃圾收集呢，这要看使用何种垃圾收集器(或垃圾收集算法)了。通常情况下，当堆或堆的一部分已满，或已分配的空间超过了某个阈值时，就会进行垃圾收集。
垃圾收集器的特点 一个理想的垃圾收集器应该具备以下特点：
既 安全（safe），又 完善（comprehensive）。也就是说，存活对象不能被错误的回收，并且一个垃圾不应该在经过几轮回收之后依然存在。 高效（efficient），它不会长时间暂停应用程序。 减少甚至消除内存碎片。整理（compaction） 就是一种消除碎片的方式。 可伸缩（scalable）。对于多处理器系统上的多线程应用来说，内存的分配与回收都不应该成为性能瓶颈。 设计选择 当设计或选择垃圾回收算法时，需要考虑很多点：</description></item><item><title>HotSpot引擎架构</title><link>https://zhannicholas.github.io/posts/java/jvm/hotspot_engine_architecture/</link><pubDate>Sun, 13 Dec 2020 18:43:36 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jvm/hotspot_engine_architecture/</guid><description>这篇笔记主要来自于The Java HotSpot Performance Engine Architecture ，感觉主要是在讲 JDK8中 HotSpot VM 的整体架构。
Java HotSpot VM 原来是 Sun 公司为 Java 平台实现的高性能虚拟机，是 Java SE 的基础组成部分。为了使 Java 应用达到达到最佳的性能，HotSpot 采用了很多高级技术，包括先进的内存模式、垃圾收集器和自适应优化器。
HotSpot VM架构 内存模型（Memory Model） 对象的访问定位 Java 程序通过栈上的引用（reference）操作堆上的具体对象。在早期 JVM 中，比如 Classic VM，对象的访问定位是通过 间接句柄（indirect handle） 实现的。由于引用中存放的是句柄的地址，所以在对象被移动时，只需要改变句柄中到对象实例数据的指针即可。这一点虽然可以简化垃圾回收过程中对象的重定位过程，但却成为了性能瓶颈，因为在 Java 中通过句柄访问实例变量需要进行 两次 间接访问。
在 HotSopt VM 中，对象的访问定位是通过 直接指针（direct pointers） 来实现的，只需要 一次 访问就可以获取到实例变量。当对象在内存回收过程中被移动时，垃圾收集器需要负责找到并更新所有到该对象的引用。
两字（Two-Word）的对象头 HotSpot VM 中的对象头大小为两个机器字，而 Classic VM 中的对象头为三个字。通常，Java 对象都很小，所以对象头的大小对空间消耗的影响还是很大的。对象头的第一个字（mark word）包含了 hashCode 和 GC 的状态等信息，而第二个字（kclass pointer）是一个指向对象所属类（class）的指针。只有数组对象的对象头中有第三个部分——这一部分记录了数组的大小。
以对象表示的反射数据 类、方法和其它内部反射数据都直接被表示成堆上的对象。这既简化了 VM 内部的对象模型，也允许类被为其它对象设计的垃圾回收器回收。</description></item><item><title>垃圾回收调优指南(Java SE 8)</title><link>https://zhannicholas.github.io/posts/java/jvm/garbage_collection_tuning_guide_in_javase8/</link><pubDate>Sun, 13 Dec 2020 18:40:26 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jvm/garbage_collection_tuning_guide_in_javase8/</guid><description>这篇笔记地主要内容来自Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide 。文章中介绍了一些调优目标以及 JDK 8中 Hotspot VM 提供的一些垃圾收集器，并提出了很多调优建议。
GC（Garbage Collector） 是一个内存管理工具，它通过以下操作实现了自动内存管理：
将新生对象分配到 年轻代（Young Generation），并将足够老的对象提升到 年老代（Old Generation）。 通过并发（或并行）标记阶段找出年老代中的存活对象。当整个 Java 堆的空间使用率超过阈值时，HotSpot VM 就会触发标记阶段。 通过并行复制整理存活对象，以释放堆空间，恢复可用内存。 Ergonomics Ergonomics is the process by which the Java Virtual Machine (JVM) and garbage collection tuning, such as behavior-based tuning, improve application performance.
JVM 会根据所运行平台选择默认的 GC、堆大小和运行时编译器等。此外，基于行为的调优会动态地调整堆大小以满足不同应用的要求。
基于行为的调优 Java SE 为 并行收集器 提供了两个参数以实现不同的应用行为：最大暂停时间（maximum pause time goal） 和 吞吐量（application throughput goal）。这两个参数在其它收集器中是不可用的。在某些时候，预期行为可能不会出现，因为应用需要一个至少能存放下所有存活对象的堆空间。对堆空间的最小要求可能会妨碍达成预期目标。</description></item></channel></rss>