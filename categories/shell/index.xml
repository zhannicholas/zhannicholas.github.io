<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Shell on 's Digital Garden</title><link>https://zhannicholas.github.io/categories/shell/</link><description>Recent content in Shell on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 27 Oct 2021 21:10:27 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/categories/shell/index.xml" rel="self" type="application/rss+xml"/><item><title>Shell 脚本：正则表达式</title><link>https://zhannicholas.github.io/posts/linux/shell_scripting_regular_expressions/</link><pubDate>Wed, 27 Oct 2021 21:10:27 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/shell_scripting_regular_expressions/</guid><description>正则表达式（regular expression, RE）在 Shell 中的应用非常广泛，我们常用的 find、grep、sed、awk 等命令都涉及到正则表达式……
在 Shell 中，表达式就是一个字符串。字符串由字符组成，其中有些字符除了字面含义之外还有特殊含义，这些具有特殊含义的字符就是元字符（metacharacter）。
正则表达式主要用于搜索文本和操作字符串，它包含以下内容：
字符集（character set）。字符集内所有的字符都只具有字面含义，不包括元字符 锚点（anchor）。锚点标识着正则表达式要匹配的文本中的位置，比如 ^ 和 $ 修饰符（modifier）。修饰符的作用是扩展或者缩小正则表达式要匹配的文本的范围，包括星号（*）、方括号（[）和反斜杠（/） 标准正则表达式中的特殊字符 *：匹配前一个字符出现任意次数，包括 0 次 .：匹配除换行符（\n）之外的任何单字符 ^：匹配字符串的开始位置 $：匹配字符串的结束位置 [...]：封装正则表达式中用到的一组字符 \：对特殊字符进行转义，转移后的特殊字符只具备字面含义 \&amp;lt;...\&amp;gt;：标记单词边界 扩展正则表达式中的特殊字符 扩展正则表达式给标准正则表达式中加入了新的元字符，主要用在 egrep、awk 和 Perl 中。
?：匹配前一个字符出现零次或一次 +：匹配前面的子表达式出现一次或多次 \{\}：限定前面的子表达式出现的次数 ()：封装一组正则表达式 |：从一组选择中选择一个，即或的含义 Globbing Bash 本身并不能识别正则表达式，解释正则表达式的是一些像 sed 和 awk 这样的命令和工具。Shell 展开中有一种类型叫文件名展开（filename expansion），但展开的事情并不是 Bash 自己完成的，而是由一个叫做 globbing 的进程完成的。但是 globbing 本身并不能使用标准的正则表达式，它只能识别一些特殊字符（比如 *、?、[]）。这些特殊字符一般称为通配符（wildcards），也叫 globbing 或 pattern matching。需要注意的是：* 并不会匹配以 . 开头的文件名。
参考资料 Bash Guide for Beginners . Advanced Bash-Scripting Guide .</description></item><item><title>Shell 脚本：shell 展开</title><link>https://zhannicholas.github.io/posts/linux/shell_scripting_shell_expansion/</link><pubDate>Sat, 23 Oct 2021 17:15:13 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/shell_scripting_shell_expansion/</guid><description>Bash 和其它 shell 做的工作远不止执行命令那么简单。以下提到的各种展开（expansion）操作发生在 Bash 执行命令之前。准确来说，是在重定向之前，重定向操作完成之后才会真正执行命令。
若命令中存在重定向操作，则 Shell 会在执行命令之前进行处理。管道（|）就是一个很好的例子，Shell 会透明地将上一条命令的 stdout 重定向到下一条命令的 stdin。而与这个重定向操作有关的两条命令根本不知道自己在和谁通信。
在 shell 将读取的命令分割成符号（token）之后，这些符号（或单词）会被展开或解析。Shell 会按照顺序执行八种类型的展开：
Brace expansion Tilde expansion Shell parameter and variable expansion Command substitution Arithmetic expansion Process substitution Word splitting File name expansion 大括号展开 大括号展开的形式为：一个可选的前导符（PREAMBLE）、一组位于一对大括号之间的由逗号分隔的字符串和一个可选的跋（POSTSCRIPT）。例如：
~$ echo sp{el,il,al}l spell spill spall 波浪号展开 如果一个单词以没有被引起来的波浪号（~）开始，则在第一个没有被引起来的斜杠（若没有斜杠，则一直到最后一个字符）之前的字符将被视作波浪号前缀（tidle-prefix）。如果波浪号前缀中没有字符被引起来，那么波浪号前缀中的这些字符就会被当作一个可能的登录用户名。如果这个登录用户名是 null 字符串，则波浪号被替换为 shell 变量 HOME。如果 HOME 变量没有被设置，则替换为执行这个 shell 的用户的主目录。 如果波浪号前缀是”~+“，那么它会被替换为变量 PWD 的值。如果波浪号前缀是”~-“，那么它会被替换为变量 OLDPWD 的值。
参数或变量展开 美元符号（$）用于参数展开、命令替换或算术展开。被展开的参数名或符号可能被包裹在大括号中。 最基本的参数展开的形式是${PARAMETER}。如果我们想在某个变量不存在时创建这个变量，则可以使用${VAR:=value}。
命令替换 命令替换（command substitution）允许我们用命令的输出来替换命令本身，它有两种形式：
$(command) `command` 其中前者工作得更好，是用来取代后者的。</description></item><item><title>Shell 脚本：条件分支与循环</title><link>https://zhannicholas.github.io/posts/linux/shell_scripting_conditional_statements_and_loops/</link><pubDate>Thu, 21 Oct 2021 23:05:45 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/shell_scripting_conditional_statements_and_loops/</guid><description>和其它编程语言类似，bash 也给我们提供了条件语句（conditional statements）。
条件分支 if 在 shell 中，if/then 的语法为：if TEST-COMMANDS; then CONSEQUENT-CONMMANDS; fi。
TEST-COMMANDS 列表执行后，如果它的返回状态是 0，就执行 CONSEQUENT-COMMANDS 列表，其中最后一条命令的退出状态就是整个 if 表达式的返回状态。
在 UNIX/Linux 中，通常用 0 表示成功，非零表示失败。
if/then/else If/then/else 的语法为：if TEST-COMMANDS; then CONSEQUENT-CONMMANDS; else ALTERNATE-CONSEQUENT-COMMANDS; fi
if/then/elif/else if 表达式的完整的语法为：if TEST-COMMANDS; then CONSEQUENT-CONMMANDS; elif MORE-TEST-COMMANDS; then MORE-CONSEQUENT-COMMANDS; else ALTERNATE-CONSEQUENT-COMMANDS; fi
test test 是一个 bash 内置的命令，用于检查文件的类型和进行值的比较。特殊字符 [ 是 test 的同义词。
[] 与 [[]] 的区别在于：[[]]（extended test command）比 [] 更强，它会阻止 shell 进行变量名的分词操作、阻止路径名展开。[ 和 [[ 的类型也不同：
~$ type [ [ is a shell builtin ~$ type [[ [[ is a shell keyword 还有更加有趣的：</description></item><item><title>Shell 脚本</title><link>https://zhannicholas.github.io/posts/linux/shell_scripting_introduction/</link><pubDate>Wed, 20 Oct 2021 20:45:55 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/shell_scripting_introduction/</guid><description>接下来将会有一系列与 Shell 脚本相关的笔记文章。在之前的工作中，作为一个 Java Boy，我几乎不需要自己编写 Shell 脚本，所以大学学过的 Shell 脚本编程基本忘完（实际上我并没有系统的学过它😂），工作中碰到相关东西时也是 Google 一下就搞定了。但是，现在的工作要求我能够编写 Shell 脚本实现一些自动化操作，所以我决定系统地学习一下 Shell 脚本编程的相关知识。主要参考的学习资料是 The Linux Documentation Project 网站上推荐的两本在线书籍：Bash Guide for Beginners 和 Advanced Bash-Scripting Guide 。前者适合入门，后者适合精进，感谢作者的无私分享。
Shell Shell 既是一个命令解释器（command interpreter），又是一门编程语言。Shell 脚本（shell scripts）是用 shell 编程语言编写的程序，它可以将系统调用、各种工具和已编译的二进制文件粘合在一起，形成新的应用。
Shell 脚本是解释执行的，shell 从脚本中逐行读取命令，然后在系统中昂搜索这些命令并执行。
Shell 有很多种，比如 sh（Bourne Shell）、bash（Bourne Again shell）、csh（C shell）、tcsh（TENEX C shell）、ksh（Korn shell）、tmux 等
查看系统内已经有的 shell：cat /etc/shells。 查看当前用户默认的 shell：cat /etc/passwd | grep $USER | awk 'BEGIN { FS=&amp;quot;:&amp;quot; } { print $7 }。</description></item></channel></rss>