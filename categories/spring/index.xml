<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Spring on 's Digital Garden</title><link>https://zhannicholas.github.io/categories/spring/</link><description>Recent content in Spring on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 27 Aug 2021 20:36:10 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/categories/spring/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring Boot 中的配置体系</title><link>https://zhannicholas.github.io/posts/java/spring/configurations-in-spring-boot/</link><pubDate>Fri, 27 Aug 2021 20:36:10 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/spring/configurations-in-spring-boot/</guid><description>开发的同学可能都遇到过一个 Spring Boot 应用要在多个环境上部署，而每个环境的配置都不同的情况。比如，开发环境用一套配置，测试环境用另一套配置，生产环境又是一套新配置。如果我们把配置放在同一个地方，然后每次都根据不同的环境进行修改，可能要不了多久，我们的头就大了。因为，我们可能一不小心把开发环境的配置放到测试环境中去了……
为了方便我们在不同环境中运行应用程序，Spring Boot 允许我们将配置信息外部化 。Spring Boot 支持多种外部化的配置源，包括 Java 的 properties 文件、YAML 文件、环境变量和命令行参数。
配置源 既然配置可以来自很多不同的地方，那么就有可能出现同一个配置项在多个配置源中出现的情况。所以 Spring Boot 有一个配置值覆盖规则，优先级高的配置会覆盖优先级低的，优先级从低到高依次为：
默认属性（即通过 SpringApplication.setDefaultProperties 设置的属性） @Configuration 类上的 @PropertySource 注解 配置数据（比如 application.properties）。配置数据文件的优先级如下，当.properties 文件与 .yml 文件同时出现时，前者的优先级会高于后者： Jar 包内的 application.properties 和 application.yml Jar 包内特定 Profile 的 application-{profile}.properties 和 application-{profile}.yml Jar 包外的 application.properties 和 application.yml Jar 包外特定 Profile 的 application-{profile}.properties 和 application-{profile}.yml 由 RandomValuePropertySource 配置的 random.* 属性值 操作系统环境变量 Java 系统属性（System.getProperties()） 来自 java:comp/env 的 JNDI 属性 ServletContext 的初始化参数 ServletConfig 的初始化参数 SPRING_APPLICATION_JSON（环境变量或系统属性中的单行 JSON） 中的属性值 命令行参数 测试上的 properties 属性。在 @SpringBootTest 和其它测试相关注解上有用 测试上的 @TestPropertySource 注解 当 devtools 激活时，$HOME/.</description></item><item><title>Spring Ioc</title><link>https://zhannicholas.github.io/posts/java/spring/spring-ioc/</link><pubDate>Sat, 21 Aug 2021 13:49:54 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/spring/spring-ioc/</guid><description>Ioc（Inverse of Control），又叫 DI（Dependence Injection）。它是这样一个过程：对象声明自己的依赖，然后容器在创建 Bean 的时候注入这些依赖。如果不使用 IoC，我们在创建对象之前就需要先把对象的依赖创建出来，这个正向的过程会导致对象与对象之间的强耦合。如果反过来，对象不自己创建依赖，而是由 Spring 的 Ioc 容器自动装配，这就是控制反转。逆向的过程使得程序的结构变得更加灵活，没有强耦合，还有利于对象的复用。
Ioc 容器 在 Spring 中，org.springframework.context.ApplicationContext 接口就是 IoC 容器的抽象表示，它负责 Bean 的实例化、配置以及组装。那么，IoC 容器是如何知道要管理哪些 Bean 呢？答案是配置元数据（Configuration Metadata）。配置元数据可以是 XML、注解，还可以是 Java 代码。
配置元数据 Spring 的 Ioc 容器会读取配置元数据，然后根据配置元数据去实例化、配置和组装应用程序中的 Bean。在 Spring 的早期版本中，配置信息使用的是 XML。Spring 2.5 开始支持基于注解的配置，我们常用的 @Required 和 @Autowired 就是基于注解的配置。 Spring 3.0 开始支持基于 Java 代码的配置。现在，我们甚至可以同时使用 XML 和 注解去配置 Bean。
实际上，在 IoC 容器内部，这些配置元数据会被解析成 BeanDefinition 对象，BeanDefinition 封装的就是 Bean 的定义和描述信息，比如类名、构造器参数、属性值、作用域、生命周期等，容器会根据 BeanDefinition 中封装的信息来创建 Bean。
使用 BeanFactoryPostProcessor 对配置元数据进行个性化配置 在 Spring 中，BeanFactory 提供了一种管理任何类型对象的高级机制，我们经常遇到的 ApplicationContext 则是它的一个子接口。若要用一句话来描述二者的差异，那就是：BeanFactory 提供配置框架和基本功能，ApplicationContext 则是添加了更多的企业级功能。</description></item></channel></rss>