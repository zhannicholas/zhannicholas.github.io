<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C算法 on Nicholas Zhan</title><link>https://zhannicholas.github.io/categories/c%E7%AE%97%E6%B3%95/</link><description>Recent content in C算法 on Nicholas Zhan</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 03 Jun 2018 10:49:04 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/categories/c%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>哈希表</title><link>https://zhannicholas.github.io/posts/reading_notes/algorithms_in_c/hashing-table/</link><pubDate>Sun, 03 Jun 2018 10:49:04 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/algorithms_in_c/hashing-table/</guid><description>键索引搜索方法中，表中的第 i 个位置保存了键为 i 对应的项，以便达到快速访问的目的。它将键作为数组的索引，并且依赖于同一范围内不同整数的键作为表</description></item><item><title>树</title><link>https://zhannicholas.github.io/posts/reading_notes/algorithms_in_c/binary-tree/</link><pubDate>Sat, 02 Jun 2018 10:07:28 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/algorithms_in_c/binary-tree/</guid><description>树是满足一定要求的顶点和边的非空集合。 二叉树 二叉树的每个节点至多有2个子节点。 一种表示方法： struct Node{type key; Node *lchild, *richild;} typedef Node *link; 这种表示方法只适合从根节点开始</description></item><item><title>各种排序算法</title><link>https://zhannicholas.github.io/posts/reading_notes/algorithms_in_c/sorting/</link><pubDate>Wed, 30 May 2018 18:55:31 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/algorithms_in_c/sorting/</guid><description>学习《C算法》中排序这一部分时做的一些笔记。主要使用C++实现了书中的大部分排序算法。 开始之前 为了方便增加代码的灵活性，我采取了书中作者的部</description></item><item><title>约瑟夫问题</title><link>https://zhannicholas.github.io/posts/reading_notes/algorithms_in_c/josepus-problem/</link><pubDate>Sun, 27 May 2018 11:35:18 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/algorithms_in_c/josepus-problem/</guid><description>问题由来 这是一个很经典的问题了，大概就是说： 已知n个人（以编号1，2，3&amp;hellip;n分别表示）围成一个圆圈。 从第一个人开始报数，数到m</description></item><item><title>厄拉多筛法求素数</title><link>https://zhannicholas.github.io/posts/reading_notes/algorithms_in_c/seive-of-eratosthenes/</link><pubDate>Sat, 26 May 2018 10:43:44 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/algorithms_in_c/seive-of-eratosthenes/</guid><description>筛法原理 给出要筛数值的范围maxn，找出maxn以内所有的素数。先用2去筛，即把2留下，把2的倍数剔除掉；再用下一个素数，也就是3筛，把3留</description></item><item><title>并查集</title><link>https://zhannicholas.github.io/posts/reading_notes/algorithms_in_c/union-find/</link><pubDate>Sat, 26 May 2018 10:43:44 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/algorithms_in_c/union-find/</guid><description>记录一下最近学习的并查集。 问题引入 假定有一个整数对序列，其中每个整数代表某种类型的一个对象，而且将 p-q 解释为“p与q连通”。关系是可传递的，如</description></item></channel></rss>