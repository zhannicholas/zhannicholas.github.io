<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>分布式计算 on 's Digital Garden</title><link>https://zhannicholas.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/</link><description>Recent content in 分布式计算 on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 17 Aug 2021 22:13:51 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/index.xml" rel="self" type="application/rss+xml"/><item><title>分布式事务</title><link>https://zhannicholas.github.io/posts/distributed_computing/distributed_transactions/</link><pubDate>Tue, 17 Aug 2021 22:13:51 +0800</pubDate><guid>https://zhannicholas.github.io/posts/distributed_computing/distributed_transactions/</guid><description>我们常说事务是一组操作，这组操作要么全部成功，要么全部不成功。当事务失败时，事务内所作的所有变更都会被回滚。在单机环境中，若多个线程同时对数据进行操作，事务就是对数据的完整性的保障。类似地，在分布式环境中处理数据变更的时候，需要通过分布式事务来保证数据的正确完整，防止数据变更请求在部分节点上的执行失败而导致的数据不一致问题。
为了实现分布式事务，人们开发出了很多经典的分布式一致性算法，例如 2PC、3PC、TCC 等。
2PC 2PC 是两阶段提交（Two-phase Commit）的简称，它是一种实现分布式事务的算法。顾名思义，2PC 中事务的提交过程分两个阶段来完成：准备（Prepare）阶段和提交（Commit）阶段。
准备阶段：协调者向所有参与者发送事务内容，询问其是否可以提交事务，然后等待所有参与者的答复。参与者执行事务（但不提交），若执行成功，则给协调者反馈 YES，若执行失败，则给协调者反馈 NO。
提交阶段：当协调者收到所有参与者的反馈信息后，会对信息进行统计。只有当所有的参与者都反馈 YES 时，协调者才会给所有的参与者发送提交事务的命令。否则，协调者会给所有的参与者发送 abort 请求，回滚事务。
虽然 2PC 可以有效保证分布式环境中的事务，但算法本身也存在不少缺陷：
性能问题。在算法的执行过程中，所有的参与者都处于阻塞状态。只有在协调者通知参与者提交或回滚，参与者在本地执行完相应的操作之后，资源才会被释放。 协调者单点问题。若协调者发生故障，参与者收不到提交或回滚的通知，就会一直处于锁定状态。 消息丢失导致的数据不一致问题。在提交阶段，若系统出现分区，部分参与者没有收到提交消息，各节点的数据就会变得不一致。 3PC 由于 2PC 存在各种问题，人们对它进行了改进，衍生出了新的协议。三阶段提交（Three-Phase Commit, 3PC）就是 2PC 的改进版本，它将事务的提交过程分为了 CanCommit、PreCommit 和 DoCommit 三个阶段。
CanCommit：协调者向所有参与者发送包含事务内容的 CanCommit 请求，询问其是否可以提交事务，然后等待所有参与者的答复。参与者收到请求后，判断自己能够执行事务。若参与者认为自己可以提交，则反馈 YES ，否则反馈 NO。
PreCommit：协调者接收所有参与者的反馈消息，根据反馈消息决定是否中断事务。当所有参与者都反馈 YES 时，协调者向所有参与者发出 PreCommit 请求，参与者收到请求后执行事务（但不提交），执行成功后向协调者反馈 Ack 表示已经准备好提交事务，否则反馈 NO。若有参与者在 CanCommit 阶段返回 NO 或协调者在超时之前未收到任何反馈，协调者就会向所有的参与者发出 abort 请求，请求中断事务。
DoCommit：如果 PreCommit 阶段中的所有参与者都反馈 Ack，协调者就会给所有的参与者发送 DoCommit 请求，参与者收到之后会进行真正的事务提交。反之，如果 PreCommit 阶段有一个参与者反馈 NO 或者协调者在超时之前没有收到反馈，则会向所有的参与者发送 abort 请求，中断事务。
需要注意的是：只要进入到了 DoCommit 阶段，无论协调者出现故障，还是协调者与参与者之间的通信出现问题，都会导致参与者无法收到协调者发出的 DoCommit 请求或 abort 请求。这是，参与者会在等待超时之后，主动提交事务。</description></item><item><title>CAP 定理与 BASE 理论</title><link>https://zhannicholas.github.io/posts/distributed_computing/cap_theorem_and_base/</link><pubDate>Tue, 17 Aug 2021 00:54:37 +0800</pubDate><guid>https://zhannicholas.github.io/posts/distributed_computing/cap_theorem_and_base/</guid><description>CAP 定理 计算机科学家 Eric Brewer 指出：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）这三项中的两项。这就是 CAP 定理，也叫 Brewer 定理。CAP 定理是分布式系统发展的理论基石，对分布式系统的发展有着广泛而深远的影响。
一致性 是指所有节点在同一时刻的数据都是相同的，所有节点都拥有最新版本的数据。也就是说，在同一时刻，不管访问系统中的哪个节点，所得到的数据不仅是一样的，而且是最新的。
可用性 是指系统总能对客户端的请求给予响应。系统并不保证响应包含的数据一定是最新的，数据可能是老旧的甚至错误的，但响应是一定会有的。从客户端来看，它发出去的请求总是有响应的，不会出现整个系统无法连接、超时或无响应的情况。
分区容错性 是指当系统中的部分节点出现消息丢失或分区故障时，系统仍然能够继续对外提供服务。在分布式环境中，每个服务节点都是不可靠的。当某些节点发生故障，或节点与节点之间的通信出现异常时，系统就出现了分区问题。从系统本身来看，当分区问题出现时，它仍然要对外提供稳定服务。而对于客户端而言，系统的分区问题对它来说是透明的，客户端并不会感受到系统的分区问题。
CAP 定理的证明 根据 CAP 定理，分布式系统中的一致性、可用性和分区容错性不可兼得，最多只能满足其中两点。下面用只有两个服务器的情况来简单证明一下。假定我们有一个分布式系统，它由 node1 和 node2 两个节点组成。在最开始的时候，两个节点之间的数据 X 的值相同，都是 $v_0$。此时，不管用户是访问 node1 还是 node2，所得 X 的值都是 $v_0$。
在正常的情况下，node1 和 node2 此时都在正常工作，相互之间通信良好。某一时刻，用户向 node1 执行了更新操作，node1 中数据 X 的值被修改成了 $v_1$。此时，node1 会发送一个消息 M 给 node2，告知 node2 将 X 的值修改为 $v_1$。node2 在收到消息 M 之后， X 的值也会被修改成 $v_1$。此后，用户不管是请求 node1 还是 node2，所得 X 的值都是 $v_1$。
如果网络出现了分区，node1 与 node2 之间无法正常进行通信，消息 M 无法抵达 node2，那么 node1 和 node2 的数据就会出现不一致。</description></item></channel></rss>