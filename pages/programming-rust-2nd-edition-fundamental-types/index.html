<!doctype html><html lang=zh-cn><head><meta http-equiv=content-type content="text/html" charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon type=image/png sizes=96x96 href=https://zhannicholas.github.io/favicon/favicon-96x96.png><link rel=icon type=image/png sizes=32x32 href=https://zhannicholas.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://zhannicholas.github.io/favicon/favicon-16x16.png><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title itemprop=name>Programming Rust, 2nd Edition - Fundamental Types | NZ's Digital Garden</title><meta name=description content><meta property="og:title" content="Programming Rust, 2nd Edition - Fundamental Types | NZ's Digital Garden"><meta name=twitter:title content="Programming Rust, 2nd Edition - Fundamental Types | NZ's Digital Garden"><meta itemprop=name content="Programming Rust, 2nd Edition - Fundamental Types | NZ's Digital Garden"><meta name=application-name content="Programming Rust, 2nd Edition - Fundamental Types | NZ's Digital Garden"><meta property="og:site_name" content><meta property="og:type" content="website"><meta property="og:title" content="NZ's Digital Garden"><meta property="og:description" content><meta property="og:site_name" content="NZ's Digital Garden"><meta property="og:url" content="https://zhannicholas.github.io/pages/programming-rust-2nd-edition-fundamental-types/"><meta property="og:locale" content="en"><meta property="og:image" content="/"><meta property="og:image:secure_url" content="https://zhannicholas.github.io"><meta property="og:type" content="website"><script>localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=stylesheet href="/css/style.min.172198f1bbeb66428b798f521ac03583837aeb0e305f2508bd37d77cb221a6fb.css" integrity="sha256-FyGY8bvrZkKLeY9SGsA1g4N66w4wXyUIvTfXfLIhpvs="></head><body class="bg-zinc-100 dark:bg-gray-800"><div class="top-0 z-50 w-full text-gray-200 bg-gray-900 border-2 border-gray-900 md:sticky border-b-stone-200/10"><div x-data="{ open: false }" class="flex flex-col max-w-full px-4 mx-auto md:items-center md:justify-between md:flex-row md:px-6 lg:px-8"><div class="flex flex-row items-center justify-between p-4"><a href=https://zhannicholas.github.io/ class="flex text-gray-100 transition duration-1000 ease-in-out group"><div class="mt-1 text-xl font-black tracking-tight text-gray-100 uppercase transition-colors group-hover:text-gray-400/60">NZ's Digital Garden</div></a><button class="rounded-lg md:hidden focus:outline-none focus:shadow-outline" @click="open = !open" role=navigation aria-expanded=false aria-label=Main aria-controls=menuItems><svg fill="currentcolor" viewBox="0 0 20 20" class="w-6 h-6"><path x-show="!open" fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4A1 1 0 013 5zm0 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm6 5a1 1 0 011-1h6a1 1 0 110 2h-6a1 1 0 01-1-1z" clip-rule="evenodd"/><path x-show="open" fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414.0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/></svg></button></div><nav :class="{'flex': open, 'hidden': !open}" class="flex-col flex-grow hidden pb-4 md:pb-0 md:flex md:justify-end md:flex-row"><div @click.away="open = false" class=relative x-data="{ open: false }"><button @click="open = !open" class="flex flex-row items-center w-full px-4 py-2 mt-2 text-sm font-semibold text-left bg-transparent rounded-lg md:w-auto md:inline md:mt-0 md:ml-4 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-600 focus:outline-none focus:shadow-outline">
<span>The Garden</span><svg fill="currentcolor" viewBox="0 0 20 20" :class="{'rotate-180': open, 'rotate-0': !open}" class="inline w-4 h-4 mt-1 ml-1 transition-transform duration-200 transform md:-mt-1"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414.0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414.0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/></svg></button><div x-show=open x-transition:enter="transition ease-out duration-100" x-transition:enter-start="transform opacity-0 scale-95" x-transition:enter-end="transform opacity-100 scale-100" x-transition:leave="transition ease-in duration-75" x-transition:leave-start="transform opacity-100 scale-100" x-transition:leave-end="transform opacity-0 scale-95" class="absolute right-0 z-30 w-full mt-2 origin-top-right rounded-md shadow-lg md:w-48"><div class="px-2 py-2 text-indigo-900 bg-white rounded-md shadow"><a class="block px-4 py-2 mt-2 text-sm font-semibold bg-transparent rounded-lg md:mt-0 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-600 focus:outline-none focus:shadow-outline" href=https://zhannicholas.github.io/posts>Posts</a>
<a class="block px-4 py-2 mt-2 text-sm font-semibold bg-transparent rounded-lg md:mt-0 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-600 focus:outline-none focus:shadow-outline" href=https://zhannicholas.github.io/pages>Notes</a>
<a class="block px-4 py-2 mt-2 text-sm font-semibold bg-transparent rounded-lg md:mt-0 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-700 focus:outline-none focus:shadow-outline" href=https://zhannicholas.github.io/library>Library</a></div></div></div><a class="px-4 py-2 mt-2 text-sm font-semibold rounded-lg md:mt-0 md:ml-4 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-700 focus:outline-none focus:shadow-outline" href=https://zhannicholas.github.io/now>Now</a>
<a class="px-4 py-2 mt-2 text-sm font-semibold bg-transparent rounded-lg md:mt-0 md:ml-4 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-700 focus:outline-none focus:shadow-outline" href=https://zhannicholas.github.io/about>About</a>
<button id=theme-toggle type=button class="p-2 text-sm text-gray-500 rounded-lg md: dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:focus:ring-gray-700 md:ml-2 max-w-5 xs:hidden"><svg id="theme-toggle-dark-icon" class="hidden w-5 h-5" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001.0 1010.586 10.586z"/></svg><svg id="theme-toggle-light-icon" class="hidden w-5 h-5" fill="currentcolor" viewBox="0 0 20 20" aria-label="Dark or Light Mode" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1A1 1 0 119 4V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707A1 1 0 1113.536 5.05l.707-.707a1 1 0 011.414.0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707A1 1 0 004.343 5.757l.707.707zm1.414 8.486-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"/></svg></button></nav></div></div><div class=content><article><header class="max-w-2xl mx-auto mb-4 bg-indigo-600"><span class=py-96><h1 class="px-6 pt-6 pb-16 mx-auto dark:prose-invert text-5xl font-black text-center text-white capitalize">Programming Rust, 2nd Edition - Fundamental Types</h1></span></header><div class="max-w-4xl mx-auto mt-8 mb-2"><div class=px-6></div></div><div class="fixed z-20 top-[3.8125rem] bottom-0 right-[max(0px,calc(50%-45rem))] w-[18rem] py-10 overflow-y-auto hidden xl:block"><nav><div class="flex items-center"><h2 class="pl-2 my-0 text-xl font-medium text-zinc-800 uppercase break-words">Table of Contents</h2></div><div class="absolute top-auto bottom-auto right-auto p-0 -left-4" role=menu><div class="relative z-50 max-w-sm m-4 overflow-hidden shadow-lg"><ul class="relative p-4 overflow-x-hidden overflow-y-auto overscroll-y-auto overscroll-x-auto"><li><a class="px-2 text-left text-zinc-700 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#example-of-types-in-rust>Example of types in Rust</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#fixed-width-numeric-types>Fixed-Width Numeric Types</a><ul><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#integer-types>Integer Types</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#checked-wrapping-saturating-and-overflowing-arithmetic>Checked, Wrapping, Saturating, and Overflowing Arithmetic</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#floating-point-types>Floating-Point Types</a></li></ul></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#the-bool-type>The bool Type</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#characters>Characters</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#tuples>Tuples</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#pointer-types>Pointer Types</a><ul><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#references>References</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#boxes>Boxes</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#unsafe-pointers-raw-pointers>Unsafe Pointers (Raw Pointers)</a></li></ul></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#arrays-vectors-and-slices>Arrays, Vectors, and Slices</a><ul><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#arrays>Arrays</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#vectors>Vectors</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#slices>Slices</a></li></ul></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#string-types>String Types</a><ul><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#string-literals>String Literals</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#byte-strings>Byte Strings</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#string-in-memory>String in Memory</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#string>String</a></li></ul></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#type-aliases>Type Aliases</a></li></ul></div></div></nav></div><div class="max-w-2xl px-6 pt-6 pb-16 mx-auto prose dark:prose-invert dark:text-white"><h2 id=example-of-types-in-rust>Example of types in Rust</h2><ul><li><table><thead><tr><th>Type</th><th>Description</th><th>Values</th></tr></thead><tbody><tr><td><code>i8</code> ,  <code>i16</code> ,  <code>i32</code> ,  <code>i64</code> ,  <code>i128</code> , <code>u8</code> ,  <code>u16</code> ,  <code>u32</code> ,  <code>u64</code> ,  <code>u128</code></td><td>Signed and unsigned integers, of given bit width</td><td><code>42</code> , <code>-5i8</code> ,  <code>0x400u16</code> ,  <code>0o100i16</code> , <code>20_922_789_888_000u64</code> , <code>b'*'</code>  ( <code>u8</code>  byte literal)</td></tr><tr><td><code>isize</code> ,  <code>usize</code></td><td>Signed and unsigned integers, the same size as an address on the machine (32 or 64 bits)</td><td><code>137</code> , <code>-0b0101_0010isize</code> , <code>0xffff_fc00usize</code></td></tr><tr><td><code>f32</code> ,  <code>f64</code></td><td>IEEE floating-point numbers, single and double precision</td><td><code>1.61803</code> ,  <code>3.14f32</code> ,  <code>6.0221e23f64</code></td></tr><tr><td><code>bool</code></td><td>Boolean</td><td><code>true</code> ,  <code>false</code></td></tr><tr><td><code>char</code></td><td>Unicode character, 32 bits wide</td><td><code>'*'</code> ,  <code>'\n'</code> ,  <code>'字'</code> ,  <code>'\x7f'</code> ,  <code>'\u{CA0}'</code></td></tr><tr><td><code>(char, u8, i32)</code></td><td>Tuple: mixed types allowed</td><td><code>('%', 0x7f, -1)</code></td></tr><tr><td><code>()</code></td><td>“Unit” (empty tuple)</td><td><code>()</code></td></tr><tr><td><code>struct S { x: f32, y: f32 }</code></td><td>Named-field struct</td><td><code>S { x: 120.0, y: 209.0 }</code></td></tr><tr><td><code>struct T (i32, char);</code></td><td>Tuple-like struct</td><td><code>T(120, 'X')</code></td></tr><tr><td><code>struct E;</code></td><td>Unit-like struct; has no fields</td><td><code>E</code></td></tr><tr><td><code>enum Attend { OnTime, Late(u32) }</code></td><td>Enumeration, algebraic data type</td><td><code>Attend::Late(5)</code> ,  <code>Attend::OnTime</code></td></tr><tr><td><code>Box&lt;Attend></code></td><td>Box: owning pointer to value in heap</td><td><code>Box::new(Late(15))</code></td></tr><tr><td><code>&amp;i32</code> ,  <code>&amp;mut i32</code></td><td>Shared and mutable references: non-owning pointers that must not outlive their referent</td><td><code>&amp;s.y</code> ,  <code>&amp;mut v</code></td></tr><tr><td><code>String</code></td><td>UTF-8 string, dynamically sized</td><td><code>"ラーメン: ramen".to_string()</code></td></tr><tr><td><code>&amp;str</code></td><td>Reference to  <code>str</code> : non-owning pointer to UTF-8 text</td><td><code>"そば: soba"</code> ,  <code>&amp;s[0..12]</code></td></tr><tr><td><code>[f64; 4]</code> ,  <code>[u8; 256]</code></td><td>Array, fixed length; elements all of same type</td><td><code>[1.0, 0.0, 0.0, 1.0]</code> <code>[b' '; 256]</code></td></tr><tr><td><code>Vec&lt;f64></code></td><td>Vector, varying length; elements all of same type</td><td><code>vec![0.367, 2.718, 7.389]</code></td></tr><tr><td><code>&[u8]</code> , <code>&amp;mut [u8]</code></td><td>Reference to slice: reference to a portion of an array or vector, comprising pointer and length</td><td><code>&amp;v[10..20]</code> ,  <code>&amp;mut a[..]</code></td></tr><tr><td><code>Option&lt;&amp;str></code></td><td>Optional value: either  <code>None</code>  (absent) or  <code>Some(v)</code>  (present, with value  <code>v</code> )</td><td><code>Some("Dr.")</code> ,  <code>None</code></td></tr><tr><td><code>Result&lt;u64, Error></code></td><td>Result of operation that may fail: either a success value  <code>Ok(v)</code> , or an error  <code>Err(e)</code></td><td><code>Ok(4096)</code> ,  <code>Err(Error::last_os_error())</code></td></tr><tr><td><code>&amp;dyn Any</code> ,  <code>&amp;mut dyn Read</code></td><td>Trait object: reference to any value that implements a given set of methods</td><td><code>value as &amp;dyn Any</code> , <code>&amp;mut file as &amp;mut dyn Read</code></td></tr><tr><td><code>fn(&amp;str) -> bool</code></td><td>Pointer to function</td><td><code>str::is_empty</code></td></tr><tr><td>(Closure types have no written form)</td><td>Closure</td><td><code>|a, b| { a<em>a + b</em>b }</code></td></tr></tbody></table></li><li></li></ul><h2 id=fixed-width-numeric-types>Fixed-Width Numeric Types</h2><ul><li><p>The names of Rust’s numeric types follow a regular pattern, spelling out their width in bits, and the representation they use.</p><ul><li><p>| Size (bits) | Unsigned integer | Signed integer | Floating-point |
| &mdash;- | &mdash;- | &mdash;- |
| 8 | <code>u8</code> | <code>i8</code> |   |
| 16 | <code>u16</code> | <code>i16</code> |   |
| 32 | <code>u32</code> | <code>i32</code> | <code>f32</code> |
| 64 | <code>u64</code> | <code>i64</code> | <code>f64</code> |
| 128 | <code>u128</code> | <code>i128</code> |   |
| Machine word | <code>usize</code> | <code>isize</code> |</p></li><li><p>Here, a <em>machine word</em> is a value the size of an address on the machine the code runs on, 32 or 64 bits.</p></li></ul></li><li><p>Unlike C and C++, Rust performs almost no numeric conversions implicitly.</p><ul><li><div class=caution>implicit integer conversions have a well-established record of causing bugs and security holes, especially when the integers in question represent the size of something in memory, and an unanticipated overflow occurs.</div></li></ul></li><li><h3 id=integer-types>Integer Types</h3><ul><li><p>Rust’s unsigned integer types use their full range to represent positive values and zero.</p><ul><li><table><thead><tr><th>Type</th><th>Range</th><th></th></tr></thead><tbody><tr><td><code>u8</code></td><td>0 to 2^8–1 (0 to 255)</td><td></td></tr><tr><td><code>u16</code></td><td>0 to 2^16−1 (0 to 65,535)</td><td></td></tr><tr><td><code>u32</code></td><td>0 to 2^32−1 (0 to 4,294,967,295)</td><td></td></tr><tr><td><code>u64</code></td><td>0 to 2^64−1 (0 to 18,446,744,073,709,551,615, or 18 quintillion)</td><td></td></tr><tr><td><code>u128</code></td><td>0 to 2^128−1 (0 to around 3.4✕10^38)</td><td></td></tr><tr><td><code>usize</code></td><td>0 to either 2^32−1 or 2^64−1</td><td></td></tr></tbody></table></li></ul></li><li><p>Rust’s signed integer types use the two’s complement representation, using the same bit patterns as the corresponding unsigned type to cover a range of positive and negative values</p><ul><li><table><thead><tr><th>Type</th><th>Range</th><th></th></tr></thead><tbody><tr><td><code>i8</code></td><td>−2^7 to 2^7−1 (−128 to 127)</td><td></td></tr><tr><td><code>i16</code></td><td>−2^15 to 2^15−1 (−32,768 to 32,767)</td><td></td></tr><tr><td><code>i32</code></td><td>−2^31 to 2^31−1 (−2,147,483,648 to 2,147,483,647)</td><td></td></tr><tr><td><code>i64</code></td><td>−2^63 to 2^63−1 (−9,223,372,036,854,775,808 to 9,223,372,036,854,775,807)</td><td></td></tr><tr><td><code>i128</code></td><td>−2^127 to 2^127−1 (roughly -1.7✕10^38 to +1.7✕10^38)</td><td></td></tr><tr><td><code>isize</code></td><td>Either −2^31 to 2^31−1, or −2^63 to 2^63−1</td><td></td></tr></tbody></table></li></ul></li><li><p>Integer literals in Rust can take a suffix indicating their type: <code>42u8</code> is a <code>u8</code> value, and <code>1729isize</code> is an <code>isize</code>.</p><ul><li><div class=tip>If an integer literal lacks a type suffix, Rust puts off determining its type until it finds the value being used in a way that pins it down: stored in a variable of a particular type, passed to a function that expects a particular type, compared with another value of a particular type, or something like that. In the end, if multiple types could work, Rust defaults to <code>i32</code> if that is among the possibilities. Otherwise, Rust reports the ambiguity as an error.</div></li></ul></li><li><p>The prefixes  <code>0x</code> ,  <code>0o</code> , and  <code>0b</code>  designate hexadecimal, octal, and binary literals.</p></li><li><p>To make long numbers more legible, you can insert underscores among the digits.</p><ul><li><p>For example, you can write the largest  <code>u32</code>  value as  <code>4_294_967_295</code> .</p></li><li><div class=tip>The exact placement of the underscores is not significant, so you can break hexadecimal or binary numbers into groups of four digits rather than three, as in  <code>0xffff_ffff</code> , or set off the type suffix from the digits, as in  <code>127_u8</code> .</div></li></ul></li><li><p>You can convert from one integer type to another using the as operator. For example:
<code>assert_eq!( 255_u8 as i8, -1_i8);</code></p></li><li><p>Note that method calls have a higher precedence than unary prefix operators, so be careful when applying methods to negated values.</p><ul><li>For example, <code>-4_i32.abs()</code> would apply the <code>abs</code> method to the positive value <code>4</code>, producing positive <code>4</code>, and then negate that, producing <code>-4</code>.</li></ul></li></ul></li><li><h3 id=checked-wrapping-saturating-and-overflowing-arithmetic>Checked, Wrapping, Saturating, and Overflowing Arithmetic</h3><ul><li><p>When an integer arithmetic operation overflows, Rust panics, in a <em>debug</em> build. In a <em>release</em> build, the operation <strong>wraps around</strong>: it produces the value equivalent to the mathematically correct result modulo the range of the value.</p></li><li><p>These integer arithmetic methods fall in four general categories:</p><ul><li><em>Checked</em> operations return an  <code>Option</code>  of the result:  <code>Some(v)</code>  if the mathematically correct result can be represented as a value of that type, or  <code>None</code>  if it cannot. For example:</li></ul></li></ul></li></ul><p>`rust
// The sum of 10 and 20 can be represented as a u8.
assert_eq!(10_u8.checked_add(20), Some(30));</p><p>// Unfortunately, the sum of 100 and 200 cannot.
assert_eq!(100_u8.checked_add(200), None);</p><p>// Do the addition; panic if it overflows.
let sum = x.checked_add(y).unwrap();</p><p>// Oddly, signed division can overflow too, in one particular case.
// A signed n-bit type can represent -2ⁿ⁻¹, but not 2ⁿ⁻¹.
assert_eq!((-128_i8).checked_div(-1), None);
`</p><pre><code>  + *Wrapping* operations return the value equivalent to the mathematically correct result modulo the range of the value:
</code></pre><p><code>rust // The first product can be represented as a u16; // the second cannot, so we get 250000 modulo 2¹⁶. assert_eq!(100_u16.wrapping_mul(200), 20000); assert_eq!(500_u16.wrapping_mul(500), 53392); // Operations on signed types may wrap to negative values. assert_eq!(500_i16.wrapping_mul(500), -12144);// In bitwise shift operations, the shift distance // is wrapped to fall within the size of the value. // So a shift of 17 bits in a 16-bit type is a shift // of 1. assert_eq!(5_i16.wrapping_shl(17), 10);</code></p><pre><code>  + *Saturating* operations return the representable value that is closest to the mathematically correct result. In other words, the result is “clamped” to the maximum and minimum values the type can represent:
</code></pre><p><code>rust assert_eq!(32760_i16.saturating_add(10), 32767); assert_eq!((-32760_i16).saturating_sub(10), -32768);</code></p><pre><code>  + *Overflowing* operations return a tuple (result, overflowed), where result is what the wrapping version of the function would return, and overflowed is a bool indicating whether an overflow occurred:
</code></pre><p><code>rust assert_eq!(255_u8.overflowing_sub(2), (253, false)); assert_eq!(255_u8.overflowing_add(2), (1, true));</code></p><pre><code>+ The operation names that follow the `checked_`, `wrapping_`, `saturating_`, or `overflowing_` prefix are shown in table below:


  + | Operation | Name suffix | Example |
</code></pre><p>| &mdash;- | &mdash;- | &mdash;- |
| Addition | <code>add</code> | <code>100_i8.checked_add(27) == Some(127)</code> |
| Subtraction | <code>sub</code> | <code>10_u8.checked_sub(11) == None</code> |
| Multiplication | <code>mul</code> | <code>128_u8.saturating_mul(3) == 255</code> |
| Division | <code>div</code> | <code>64_u16.wrapping_div(8) == 8</code> |
| Remainder | <code>rem</code> | <code>(-32768_i16).wrapping_rem(-1) == 0</code> |
| Negation | <code>neg</code> | <code>(-128_i8).checked_neg() == None</code> |
| Absolute value | <code>abs</code> | <code>(-32768_i16).wrapping_abs() == -32768</code> |
| Exponentiation | <code>pow</code> | <code>3_u8.checked_pow(4) == Some(81)</code> |
| Bitwise left shift | <code>shl</code> | <code>10_u32.wrapping_shl(34) == 40</code> |
| Bitwise right shift | <code>shr</code> | <code>40_u64.wrapping_shr(66) == 10</code> |</p><ul><li><h3 id=floating-point-types>Floating-Point Types</h3><ul><li><p>Rust provides IEEE single- and double-precision floating-point types.</p><ul><li><table><thead><tr><th>Type</th><th>Precision</th><th>Range</th></tr></thead><tbody><tr><td><code>f32</code></td><td>IEEE single precision (at least 6 decimal digits)</td><td>Roughly –3.4 × 10^38 to +3.4 × 10^38</td></tr><tr><td><code>f64</code></td><td>IEEE double precision (at least 15 decimal digits)</td><td>Roughly –1.8 × 10^308 to +1.8 × 10^308</td></tr></tbody></table></li></ul></li><li><p>Every part of a floating-point number after the integer part is optional, but at least one of the fractional part, exponent, or type suffix must be present, to distinguish it from an integer literal. The fractional part may consist of a lone decimal point, so <code>5.</code> is a valid floating-point constant.</p></li></ul></li></ul><p><img src=https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492052586/files/assets/pr2e_0301.png alt></p><pre><code>+ <div class=tip>
    If a floating-point literal lacks a type suffix, Rust checks the context to see how the values are used, much as it does for integer literals. If it ultimately finds that either floating-point type could fit, it chooses <code>f64</code> by default.
</div>

+ <div class=note>
    For the purposes of type inference, Rust treats integer literals and floating-point literals as distinct classes: it will never infer a floating-point type for an integer literal, or vice versa.
</div>

+ The types `f32` and `f64` have associated constants for the IEEE-required special values like `INFINITY`, `NEG_INFINITY` (negative infinity), `NAN` (the not-a-number value), and `MIN` and `MAX` (the largest and smallest finite values).
</code></pre><h2 id=the-bool-type>The bool Type</h2><ul><li><p>Rust’s Boolean type, <code>bool</code>, has the usual two values for such types, <code>true</code> and <code>false</code>.</p></li><li><p>Although a  <code>bool</code>  needs only a single bit to represent it, Rust uses an entire byte for a  <code>bool</code>  value in memory, so you can create a pointer to it.</p></li></ul><h2 id=characters>Characters</h2><ul><li><p>Rust’s character type  <code>char</code>  represents a single Unicode character, as a 32-bit value.</p></li><li><div class=note>Rust uses the char type for single characters in isolation, but uses the UTF-8 encoding for strings and streams of text. So, a String represents its text as a sequence of UTF-8 bytes, not as an array of characters.</div></li><li><p>Character literals are characters enclosed in single quotes, like  <code>'8'</code>  or  <code>'!'</code> .</p></li><li><p>As with byte literals, backslash escapes are required for a few characters:</p><ul><li><table><thead><tr><th>Character</th><th>Rust character literal</th><th>Byte literal</th><th>Numeric equivalent</th><th></th></tr></thead><tbody><tr><td>Single quote,  <code>'</code></td><td><code>'\''</code></td><td><code>b'\''</code></td><td><code>39u8</code></td><td></td></tr><tr><td>Backslash,  <code>\</code></td><td><code>'\\'</code></td><td><code>b'\\'</code></td><td><code>92u8</code></td><td></td></tr><tr><td>Newline</td><td><code>'\n'</code></td><td><code>b'\n'</code></td><td><code>10u8</code></td><td></td></tr><tr><td>Carriage return</td><td><code>'\r'</code></td><td><code>b'\r'</code></td><td><code>13u8</code></td><td></td></tr><tr><td>Tab</td><td><code>'\t'</code></td><td><code>b'\t'</code></td><td>`9u8</td><td></td></tr></tbody></table></li></ul></li><li><p>For characters that are hard to write or read, you can write their code in hexadecimal instead.</p><ul><li><p>If the character’s code point is in the range U+0000 to U+007F (that is, if it is drawn from the ASCII character set), then you can write the character as  <code>'\xHH'</code> , where  <code>HH</code>  is a two-digit hexadecimal number.</p><ul><li><p>For example, you can write a byte literal for the ASCII “escape” control character as  <code>b'\x1b'</code> , since the ASCII code for “escape” is <code>27</code>, or <code>1B</code> in hexadecimal.</p></li><li><p>Since byte literals are just another notation for <code>u8</code> values, consider whether a simple numeric literal might be more legible: it probably makes sense to use <code>b'\x1b'</code> instead of simply <code>27</code> only when you want to emphasize that the value represents an ASCII code.</p></li></ul></li><li><p>You can write any Unicode character as  <code>'\u{HHHHHH}'</code> , where  <code>HHHHHH</code>  is a hexadecimal number up to six digits long, with underscores allowed for grouping as usual.</p><ul><li>For example, the character literal  <code>'\u{CA0}'</code>  represents the character “ಠ”</li></ul></li></ul></li><li><p>A  <code>char</code>  always holds a Unicode code point in the range 0x0000 to 0xD7FF, or 0xE000 to 0x10FFFF.</p></li><li><p>Rust never implicitly converts between  <code>char</code>  and any other type. You can use the  <code>as</code>  conversion operator to convert a  <code>char</code>  to an integer type.</p></li></ul><h2 id=tuples>Tuples</h2><ul><li><p>A <em>tuple</em> is a pair, or triple, quadruple, quintuple, etc. (hence, <em>n-tuple</em>, or <em>tuple</em>), of values of assorted types. You can write a tuple as a sequence of elements, separated by commas and surrounded by parentheses.</p></li><li><p>Tuple is similar to array, but the biggest difference is: Each element of a tuple can have a different type, whereas an array’s elements must be all the same type.</p></li><li><div class=tip>Rust code often uses tuple types to return multiple values from a function.</div></li><li><p>The other commonly used tuple type is the zero-tuple  <code>()</code> . This is traditionally called the <em>unit type</em> because it has only one value, also written  <code>()</code> . Rust uses the unit type where there’s no meaningful value to carry, but context requires some sort of type nonetheless.</p></li><li><p>For consistency’s sake, there are even tuples that contain a single value. The literal  <code>("lonely hearts",)</code>  is a tuple containing a single string; its type is  <code>(&amp;str,)</code> . Here, the comma after the value is necessary to distinguish the singleton tuple from a simple parenthetic expression.</p></li></ul><h2 id=pointer-types>Pointer Types</h2><ul><li><p>Rust has several types that represent memory addresses: <em>references</em>, <em>boxes</em> and <em>unsafe pointers</em>.</p></li><li><div class=tip>Rust is designed to help keep allocations to a minimum, thus <strong>values nest by default</strong>. For example, The value <code>((0, 0), (1440, 900))</code> is stored as four adjacent integers.
This is great for memory efficiency, but as a consequence, when a Rust program needs values to point to other values, it must use pointer types explicitly.</div></li><li><h3 id=references>References</h3><ul><li><p>References are Rust&rsquo;s basic pointer type. At run time, a reference to an  <code>i32</code>  is a single machine word holding the address of the  <code>i32</code> , which may be on the stack or in the heap.</p></li><li><p>The expression  <code>&amp;x</code>  produces a reference to  <code>x</code> ; in Rust terminology, we say that it *borrows a reference to  <code>x</code> *. Given a reference  <code>r</code> , the expression  <code>*r</code>  refers to the value  <code>r</code>  points to.</p></li><li><div class=caution>Like a C pointer, a reference does not automatically free any resources when it goes out of scope.</div></li><li><div class=tip>Unlike C pointers, however, Rust references are never null: there is simply no way to produce a null reference in safe Rust. And unlike C, Rust tracks the ownership and lifetimes of values, so mistakes like dangling pointers, double frees, and pointer invalidation are ruled out at compile time.</div></li><li><p>Rust references come in two flavors:</p><ul><li><p><code>&amp;T</code></p><ul><li>An <strong>immutable</strong>, <strong>shared</strong> reference. You can have many shared references to a given value at a time, but they are read-only: modifying the value they point to is forbidden, as with  <code>const T*</code>  in C.</li></ul></li><li><p><code>&amp;mut T</code></p><ul><li>A <strong>mutable</strong>, <strong>exclusive</strong> reference. You can read and modify the value it points to, as with a  <code>T*</code>  in C. But for as long as the reference exists, you may not have any other references of any kind to that value.</li></ul></li></ul></li><li><div class=tip>The &ldquo;<strong>single writer or multiple reader</strong>&rdquo; rule:
either you can read and write the value, or it can be shared by any number of readers, but never both at the same time.</div></li></ul></li><li><h3 id=boxes>Boxes</h3><ul><li>The simplest way to allocate a value in the heap is to use  <code>Box::new</code> :</li></ul></li></ul><p><code>rust let t = (12, "eggs"); let b = Box::new(t); // allocate a tuple in the heap</code></p><pre><code>+ The call to  `Box::new`  allocates enough memory to contain the tuple on the heap. When  `b`  goes out of scope, the memory is freed immediately, unless  `b`  has been *moved*—by returning it.
</code></pre><ul><li><h3 id=unsafe-pointers-raw-pointers>Unsafe Pointers (Raw Pointers)</h3><ul><li><p>Rust also has the raw pointer types  <code>*mut T</code>  and  <code>*const T</code> . Raw pointers really are just like pointers in C++. Using a raw pointer is unsafe, because Rust makes no effort to track what it points to.</p></li><li><div class=caution>Raw pointers might be null, or they might point to memory that has been freed or that now contains a value of a different type.</div></li></ul></li></ul><h2 id=arrays-vectors-and-slices>Arrays, Vectors, and Slices</h2><ul><li><p>Rust has three types for representing a sequence of values in memory:</p><ul><li><p>The type  <code>[T; N]</code>  represents an array of  <code>N</code>  values, each of type  <code>T</code> . An array’s size is a constant determined at compile time and is part of the type; you can’t append new elements or shrink an array.</p></li><li><p>The type  <code>Vec&lt;T></code> , called a <em>vector of  <code>T</code> s</em>, is a dynamically allocated, growable sequence of values of type  <code>T</code> . A vector’s elements live on the heap, so you can resize vectors at will: push new elements onto them, append other vectors to them, delete elements, and so on.</p></li><li><p>The types  <code>&[T]</code>  and  <code>&amp;mut [T]</code> , called a <em>shared slice of  <code>T</code> s</em> and <em>mutable slice of  <code>T</code> s</em>, are references to a series of elements that are a part of some other value, like an array or vector. You can think of a slice as a pointer to its first element, together with a count of the number of elements you can access starting at that point. A mutable slice  <code>&amp;mut [T]</code>  lets you read and modify elements, but can’t be shared; a shared slice  <code>&[T]</code>  lets you share access among several readers, but doesn’t let you modify elements.</p></li></ul></li><li><h3 id=arrays>Arrays</h3><ul><li><p>For the common case of a long array filled with some value, you can write  <code>[</code> , where <em>V</em> is the value each element should have, and <em>N</em> is the length. For example, <code>[0u8; 1024]</code> can be a one-kilo byte buffer, filled with zeros.</p></li><li><p>Rust has no notation for an uninitialized array. (In general, Rust ensures that code can never access any sort of uninitialized value.)</p></li><li><p>An array’s length is part of its type and fixed at compile time. If  <code>n</code>  is a variable, you can’t write  <code>[true; n]</code>  to get an array of  <code>n</code>  elements. When you need an array whose length varies at run time (and you usually do), use a vector instead.</p></li></ul></li><li><h3 id=vectors>Vectors</h3><ul><li><p>A vector  <code>Vec&lt;T></code>  is a resizable array of elements of type  <code>T</code> , allocated on the heap.</p></li><li><p>A  <code>Vec&lt;T></code>  consists of three values:</p><ul><li><p>a pointer to the heap-allocated buffer for the elements, which is created and owned by the  <code>Vec&lt;T></code> ;</p></li><li><p>the number of elements that buffer has the capacity to store;</p></li><li><p>and the number it actually contains now (in other words, its length).</p></li></ul></li><li><p>When the buffer has reached its capacity, adding another element to the vector entails allocating a larger buffer, copying the present contents into it, updating the vector’s pointer and capacity to describe the new buffer, and finally freeing the old one.</p></li><li><p>You can insert and remove elements wherever you like in a vector, although these operations shift all the elements after the affected position forward or backward, so they may be slow if the vector is long.</p></li></ul></li><li><h3 id=slices>Slices</h3><ul><li><p>A <a href=https://doc.rust-lang.org/std/primitive.slice.html target=_blank>slice</a>
, written  <code>[T]</code>  without specifying the length, is a region of an array or vector. Since a slice can be any length, slices can’t be stored directly in variables or passed as function arguments. Slices are always passed by reference.</p></li><li><p>A reference to a slice is a <em>fat pointer</em>: a two-word value comprising a pointer to the slice’s first element, and the number of elements in the slice.</p></li><li><p>Whereas an ordinary reference is a non-owning pointer to a single value, a reference to a slice is a non-owning pointer to a range of consecutive values in memory. This makes slice references a good choice when you want to write a function that operates on either an array or a vector.</p><ul><li>Suppose you run the following code:</li></ul></li></ul></li></ul><p>`rust
let v: Vec<f64> = vec![0.0, 0.707, 1.0, 0.707];
let a: [f64; 4] = [0.0, -0.707, -1.0, -0.707];</p><ul><li><p>let sv: &[f64] = &amp;v;
let sa: &[f64] = &amp;a;
`</p><pre><code>+ In the last two lines, Rust automatically converts the  `&amp;Vec&lt;f64&gt;`  reference and the  `&amp;[f64; 4]`  reference to slice references that point directly to the data. By the end, memory looks like:
</code></pre></li></ul><p><img src=https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492052586/files/assets/pr2e_0302.png alt></p><h2 id=string-types>String Types</h2><ul><li><p>Rust strings are sequences of Unicode characters. And Rust guarantees that strings are valid UTF-8.</p></li><li><h3 id=string-literals>String Literals</h3><ul><li><p>String literals are enclosed in double quotes. They use the same backslash escape sequences as  <code>char</code>  literals. For example: <code>let hello = "\"Hello", world.]n";</code>.</p></li><li><p>A string may span multiple lines:</p></li></ul></li></ul><p><code>rust println!("In the room the women come and go, Singing of Mount Abora");</code></p><pre><code>  + The newline character in that string literal is included in the string and therefore in the output. So are the spaces at the beginning of the second line.

+ If one line of a string ends with a backslash, then the newline character and the leading whitespace on the next line are dropped:
</code></pre><p><code>rust println!("It was a bright, cold day in April, and \ there were four of us—\ more or less.");</code></p><pre><code>  + This prints a single line of text.

+ Rust offers *raw strings*. A raw string is tagged with the lowercase letter  `r` . All backslashes and whitespace characters inside a raw string are included verbatim in the string. **No escape sequences are recognized**: `let path = r&quot;C:\Program Files\xxx&quot;;`.

+ You can’t include a double-quote character in a raw string simply by putting a backslash in front of it—remember, we said *no* escape sequences are recognized. However, there is a cure for that too. The start and end of a raw string can be marked with pound signs:
</code></pre><p><code>rust println!(r###" This raw string started with 'r###"'. Therefore it does not end until we reach a quote mark ('"') followed immediately by three pound signs ('###'): "###);</code></p><pre><code>  + You can add as few or as many pound signs as needed to make it clear where the raw string ends.
</code></pre><ul><li><h3 id=byte-strings>Byte Strings</h3><ul><li>A string literal with the  <code>b</code>  prefix is a <em>byte string</em>. Such a string is a slice of  <code>u8</code>  values—that is, bytes—rather than Unicode text.</li></ul></li></ul><p><code>rust let method = b"GET"; assert_eq!(method, &[b'G', b'E', b'T']);</code></p><pre><code>+ Byte strings can use all the syntax of string literal. Raw byte strings start with  `br&quot;` .

+ Byte strings can’t contain arbitrary Unicode characters. They must make do with ASCII and  `\xHH`  escape sequences.
</code></pre><ul><li><h3 id=string-in-memory>String in Memory</h3><ul><li><p>Although Rust strings are sequences of Unicode characters, but they are not stored in memory as arrays of  <code>char</code> s. Instead, they are stored using UTF-8, a variable-width encoding. Each ASCII character in a string is stored in one byte. Other characters take up multiple bytes.</p></li><li><p>A  <code>String</code>  has a resizable buffer holding UTF-8 text. The buffer is allocated on the heap, so it can resize its buffer as needed or requested.</p><ul><li><div class=tip>You can think of a String as a Vec<u8> that is guaranteed to hold well-formed UTF-8; in fact, this is how String is implemented.</div></li></ul></li><li><p>A  <code>&amp;str</code>  (pronounced “stir” or “string slice”) is a reference to a run of UTF-8 text owned by someone else: it “borrows” the text. <code>&amp;str</code>  is very much like  <code>&[T]</code> : a fat pointer to some data.</p><ul><li>Like other slice references, a  <code>&amp;str</code>  is a fat pointer, containing both the address of the actual data and its length. You can think of a  <code>&amp;str</code>  as being nothing more than a  <code>&[u8]</code>  that is guaranteed to hold well-formed UTF-8.</li></ul></li><li><p>The  <a href=https://doc.rust-lang.org/std/primitive.str.html target=_blank>&lt;code>str&lt;/code></a>
 type, also called a ‘string slice’, is the most primitive string type. It is usually seen in its borrowed form,  <code>&amp;str</code> . It is also the type of string literals,  <code>&'static str</code> .</p></li><li><p><code>String</code>, <code>&amp;str</code> and <code>str</code> in memory:</p></li></ul></li></ul><p><img src=https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492052586/files/assets/pr2e_0303.png alt></p><pre><code>+ A string literal is a  `&amp;str`  that refers to preallocated text, typically stored in read-only memory along with the program’s machine code.

+ A  `String`  or  `&amp;str` ’s  `.len()`  method returns its length. The length is measured in bytes, not characters.
</code></pre><ul><li><h3 id=string>String</h3><ul><li><p><code>String</code>  is analogous to  <code>Vec&lt;T></code>. Like a  <code>Vec</code> , each  <code>String</code>  has its own heap-allocated buffer that isn’t shared with any other  <code>String</code> . When a  <code>String</code>  variable goes out of scope, the buffer is automatically freed, unless the  <code>String</code>  was moved.</p></li><li><p>Strings support the <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>></code>, <code>>=</code> operators.</p></li><li><div class=caution><ul><li>Keep in mind that, given the nature of Unicode, simple  <code>char</code> -by- <code>char</code>  comparison does <em>not</em> always give the expected answers.</li></ul></div></li></ul></li></ul><h2 id=type-aliases>Type Aliases</h2><ul><li>The  <code>type</code>  keyword can be used like  <code>typedef</code>  in C++ to declare a new name for an existing type:</li></ul><p><code>rust type Bytes = Vec&lt;u8>;</code></p></div><hr><aside><h3 class="text-2xl font-black tracking-tight text-indigo-500 capitalize dark:text-indigo-300 sm:text-2xl">Linked References</h3><div class=backlinks><ul><p class="inline-flex items-center rounded-md bg-gray-300 hover:bg-indigo-200 hover:text-black px-2.5 py-0.5 text-sm font-medium text-gray-900 capitalize"><a style=color:var(--link) href=https://zhannicholas.github.io/pages/programming-rust-2nd-edition>Programming Rust, 2nd Edition</a></p></ul></div></aside><br><aside class=related><h3 class="text-2xl font-black tracking-tight text-indigo-500 capitalize dark:text-indigo-300 sm:text-2xl">Related Content</h3><ul><p class="inline-flex items-center rounded-md bg-gray-300 hover:bg-indigo-200 hover:text-black px-2.5 py-0.5 text-sm font-medium text-gray-900 capitalize"><a style=color:var(--link) href=https://zhannicholas.github.io/pages/programming-rust-2nd-edition-crates-and-modules>Programming Rust, 2nd Edition - Crates and Modules</a></p><p class="inline-flex items-center rounded-md bg-gray-300 hover:bg-indigo-200 hover:text-black px-2.5 py-0.5 text-sm font-medium text-gray-900 capitalize"><a style=color:var(--link) href=https://zhannicholas.github.io/pages/programming-rust-2nd-edition-enums-and-patterns>Programming Rust, 2nd Edition - Enums and Patterns</a></p><p class="inline-flex items-center rounded-md bg-gray-300 hover:bg-indigo-200 hover:text-black px-2.5 py-0.5 text-sm font-medium text-gray-900 capitalize"><a style=color:var(--link) href=https://zhannicholas.github.io/pages/programming-rust-2nd-edition-error-handling>Programming Rust, 2nd Edition - Error Handling</a></p></ul></aside></article></div><div x-cloak x-data="{ atTop: false }"><button id=scrollToTop name="scroll to top button" aria-label="scroll to top button" class="fixed z-50 w-10 h-10 font-bold text-center text-white transition-all duration-1000 ease-in-out transform bg-violet-600 rounded-full cursor-pointer animate-bounce bottom-24 right-8 focus:outline-none" :class="{ 'opacity-0 translate-y-24': !atTop, 'opacity-1 translate-y-2' :  atTop}" @click="window.scrollTo({ top: 0, behavior: 'smooth'})" @scroll.window="atTop = (window.pageYOffset > 200)"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentcolor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 11l3-3m0 0 3 3m-3-3v8m0-13a9 9 0 110 18 9 9 0 010-18z"/></svg></button></div><script src=https://zhannicholas.github.io/js/alpine.js defer></script>
<script src=https://zhannicholas.github.io/js/darkmode.js defer></script><footer class=bg-gray-900><div class="max-w-md px-4 py-12 mx-auto overflow-hidden sm:max-w-3xl sm:px-6 lg:max-w-7xl lg:px-8"><nav class="flex flex-wrap justify-center -mx-5 -my-2" aria-label=Footer><div class="px-5 py-2"><a href=https://zhannicholas.github.io/about class="text-base text-gray-400 hover:text-gray-300">About</a></div><div class="px-5 py-2"><a href=https://zhannicholas.github.io/posts class="text-base text-gray-400 hover:text-gray-300">Posts</a></div><div class="px-5 py-2"><a href=https://zhannicholas.github.io/pages class="text-base text-gray-400 hover:text-gray-300">Notes</a></div><div class="px-5 py-2"><a href=https://zhannicholas.github.io/library class="text-base text-gray-400 hover:text-gray-300">Library</a></div><div class="px-5 py-2"><a href=https://zhannicholas.github.io/contact/ class="text-base text-gray-400 hover:text-gray-300">Contact</a></div></nav><div class="flex justify-center mt-2 space-x-6"><a href=https://github.com/zhannicholas class="text-gray-400 hover:text-gray-300"><span class=sr-only>GitHub</span><svg class="w-6 h-6" fill="currentcolor" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483.0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951.0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65.0.0.84-.27 2.75 1.026A9.564 9.564.0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688.0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855.0 1.338-.012 2.419-.012 2.747.0.268.18.58.688.482A10.019 10.019.0 0022 12.017C22 6.484 17.522 2 12 2z" clip-rule="evenodd"/></svg></a>
<a href=mailto:zhan_nicholas@outlook.com class="text-gray-400 hover:text-gray-300"><span class=sr-only>Email</span><svg class="w-6 h-6" fill="currentcolor" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M21 7.38246601V5H3V7.38199365l9.0000224 4.50046115L21 7.38246601zm0 2.23606798-9.0000224 4.50001121L3 9.61810635V19H21V9.61853399zM3 3H21c1.1045695.0 2 .8954305 2 2V19c0 1.1045695-.8954305 2-2 2H3c-1.1045695.0-2-.8954305-2-2V5c0-1.1045695.8954305-2 2-2z" clip-rule="evenodd"/></svg></a>
<a href=https://t.me/zhannicholas class="text-gray-400 hover:text-gray-300"><span class=sr-only>Telegram</span><svg class="w-6 h-6" fill="currentcolor" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.78754 14.0196C5.83131 14.0344 5.87549 14.0448 5.91963 14.0512 5.96777 14.1644 6.02996 14.3107 6.10252 14.4818c.17707.4176.41566.9825.66194 1.5717C7.2667 17.2552 7.77332 18.4939 7.88521 18.8485 8.02372 19.2868 8.17013 19.5848 8.32996 19.7883 8.4126 19.8935 8.50819 19.9853 8.62003 20.0549 8.67633 20.0899 8.7358 20.1186 8.79788 20.14 8.80062 20.141 8.80335 20.1419 8.80608 20.1428 9.1261 20.2636 9.41786 20.2133 9.60053 20.1518 9.69827 20.1188 9.77735 20.0791 9.8334 20.0469 9.86198 20.0304 9.88612 20.0151 9.90538 20.0021L9.90992 19.9991l2.82618-1.7625 3.2646 2.5028C16.0488 20.7763 16.1014 20.8073 16.157 20.8316 16.5492 21.0027 16.929 21.0624 17.2862 21.0136 17.6429 20.9649 17.926 20.8151 18.1368 20.6464 18.3432 20.4813 18.4832 20.2963 18.5703 20.1589 18.6148 20.0887 18.6482 20.0266 18.6718 19.9791 18.6836 19.9552 18.6931 19.9346 18.7005 19.9181L18.7099 19.8963 18.7135 19.8877 18.715 19.8841 18.7156 19.8824 18.7163 19.8808C18.7334 19.8379 18.7466 19.7935 18.7556 19.7482L21.7358 4.72274C21.7453 4.67469 21.7501 4.62581 21.7501 4.57682 21.7501 4.13681 21.5843 3.71841 21.1945 3.46452 20.8613 3.24752 20.4901 3.23818 20.2556 3.25598 20.0025 3.27519 19.7688 3.33766 19.612 3.38757 19.5304 3.41355 19.4619 3.43861 19.4126 3.45773 19.3878 3.46734 19.3675 3.47559 19.3523 3.48188L19.341 3.48666 2.62725 10.0432 2.62509 10.044C2.61444 10.0479 2.60076 10.053 2.58451 10.0593 2.55215 10.0719 2.50878 10.0896 2.45813 10.1126 2.35935 10.1574 2.22077 10.2273 2.07856 10.3247c-.22719.1556-.74968.5817-.6617 1.285.07019.5611.45457.9057.68876 1.0714C2.23421 12.7721 2.35638 12.8371 2.44535 12.8795 2.48662 12.8991 2.57232 12.9339 2.6095 12.9491L2.61889 12.9529l3.16865 1.0667zM19.9259 4.86786 19.9236 4.86888C19.9152 4.8725 19.9069 4.87596 19.8984 4.87928L3.1644 11.4438C3.15566 11.4472 3.14686 11.4505 3.138 11.4536L3.12869 11.4571C3.11798 11.4613 3.09996 11.4686 3.07734 11.4788 3.06451 11.4846 3.05112 11.491 3.03747 11.4978 3.05622 11.5084 3.07417 11.5175 3.09012 11.5251 3.10543 11.5324 3.11711 11.5374 3.1235 11.54l3.14263 1.058C6.32365 12.6174 6.37727 12.643 6.42649 12.674L16.8033 6.59948 16.813 6.59374C16.8205 6.58927 16.8305 6.58353 16.8424 6.5768 16.866 6.56345 16.8984 6.54568 16.937 6.52603 17.009 6.48938 17.1243 6.43497 17.2541 6.39485 17.3444 6.36692 17.6109 6.28823 17.899 6.38064 18.0768 6.43767 18.2609 6.56028 18.3807 6.76798 18.4401 6.87117 18.4718 6.97483 18.4872 7.06972 18.528 7.2192 18.5215 7.36681 18.4896 7.49424 18.4208 7.76875 18.228 7.98287 18.0525 8.14665 17.9021 8.28706 15.9567 10.1629 14.0376 12.0147 13.0805 12.9381 12.1333 13.8525 11.4252 14.5359l-.465.449 5.8719 4.5018C16.9668 19.5349 17.0464 19.5325 17.0832 19.5274 17.1271 19.5214 17.163 19.5045 17.1997 19.4752 17.2407 19.4424 17.2766 19.398 17.3034 19.3557L17.3045 19.354 20.195 4.78102C20.1521 4.79133 20.1087 4.80361 20.0669 4.81691 20.0196 4.83198 19.9805 4.84634 19.9547 4.85637 19.9418 4.86134 19.9326 4.86511 19.9276 4.86719L19.9259 4.86786zM11.4646 17.2618 10.2931 16.3636 10.0093 18.1693 11.4646 17.2618zM9.21846 14.5814l1.16494-1.1247c.7081-.6835 1.6555-1.5979 2.6127-2.5215l.9725-.9382-6.52007 3.8168L7.48351 13.8963c.1777.4191.41736.9864.664940000000001 1.5788.185129999999999.4429.37872.9093.55504 1.3411l.28304-1.8004C9.01381 14.8422 9.09861 14.692 9.21846 14.5814z" clip-rule="evenodd"/></svg></a></div><p class="mt-2 text-base text-center text-gray-400">2018-2023 &copy; Nicholas Zhan. Licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/>CC BY-NC 4.0</a>.</p><p class="mt-2 text-base text-center text-gray-400">Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://github.com/sawhney17/logseq-schrodinger>logseq-schrodinger</a>.</p></div></footer></body></html>