<!doctype html><html lang=zh-cn dir=auto><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Java WEB复习笔记 这是为了准备秋招面试而对Java Web开发进行的复习。 首先，对于一个Java Web应用，它由一组Servlet、HTML页、">
<meta name=theme-color content="#ffcd00">
<meta property="og:title" content="Java Web复习笔记 • Nicholas Zhan">
<meta property="og:description" content="Java WEB复习笔记 这是为了准备秋招面试而对Java Web开发进行的复习。 首先，对于一个Java Web应用，它由一组Servlet、HTML页、">
<meta property="og:url" content="https://zhannicholas.github.io/posts/grocery/java-web%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">
<meta property="og:site_name" content="Nicholas Zhan">
<meta property="og:type" content="article"><meta property="og:image" content="https://www.gravatar.com/avatar/85f2cc2a45fd9533b91a65214224f9d7?s=256"><meta property="article:section" content="posts"><meta property="article:tag" content="Java"><meta property="article:published_time" content="2018-08-19T23:02:41+08:00"><meta property="article:modified_time" content="2018-08-19T23:02:41+08:00"><meta name=twitter:card content="summary">
<meta name=generator content="Hugo 0.86.0">
<title>Java Web复习笔记 • Nicholas Zhan</title>
<link rel=canonical href=https://zhannicholas.github.io/posts/grocery/java-web%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/>
<link rel=icon href=/favicon.ico>
<link rel=stylesheet href=/assets/css/main.ab98e12b.css><link rel=stylesheet href=/css/custom.css><style>:root{--color-accent:#ffcd00}</style>
</head>
<body class="page type-posts has-sidebar">
<div class=site><div id=sidebar class=sidebar>
<a class=screen-reader-text href=#main-menu>跳到主菜单</a>
<div class=container><section class="widget widget-about sep-after">
<header>
<div class=logo>
<a href=/>
<img src=/images/logo.png>
</a>
</div>
<h2 class="title site-title">
<a href=/>
Nicholas Zhan
</a>
</h2>
<div class=desc>
Java Developer, Runner, Cyclist
</div>
</header>
</section>
<section class="widget widget-sidebar_menu sep-after"><nav id=sidebar-menu class="menu sidebar-menu" aria-label=侧边栏菜单>
<div class=container>
<ul><li class="item has-children">
<a href=/posts/databases/>Database</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span>
</button>
<ul class=sub-menu><li class=item>
<a href=/posts/databases/redis/>Redis</a></li><li class=item>
<a href=/posts/databases/fundamentals/>基础理论</a></li></ul></li><li class="item has-children">
<a href=/posts/java/>Java</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span>
</button>
<ul class=sub-menu><li class=item>
<a href=/posts/java/jakartaee/>Jakarta EE</a></li><li class=item>
<a href=/posts/java/jvm/>JVM</a></li><li class=item>
<a href=/posts/java/concurrency/>并发</a></li></ul></li><li class="item has-children">
<a href=/posts/operating_systems/>操作系统</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span>
</button>
<ul class=sub-menu><li class=item>
<a href=/posts/operating_systems/memory_management/>内存管理</a></li><li class=item>
<a href=/posts/operating_systems/virtualization/>虚拟化</a></li><li class=item>
<a href=/posts/operating_systems/processes_management/>进程管理</a></li></ul></li><li class="item has-children">
<a href=/posts/computer_networks/>计算机网络</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span>
</button>
<ul class=sub-menu><li class=item>
<a href=/posts/computer_networks/http/>HTTP</a></li><li class=item>
<a href=/posts/computer_networks/fundamentals/>基础知识</a></li></ul></li></ul>
</div>
</nav>
</section><section class="widget widget-taxonomy_cloud sep-after">
<header>
<h4 class="title widget-title">标签</h4>
</header>
<div class="container list-container">
<ul class="list taxonomy-cloud"><li>
<a href=/tags/c%E7%AE%97%E6%B3%95/ style=font-size:1.3846153846153846em>C算法</a>
</li><li>
<a href=/tags/gc/ style=font-size:1em>GC</a>
</li><li>
<a href=/tags/git/ style=font-size:1em>Git</a>
</li><li>
<a href=/tags/http/ style=font-size:1.5384615384615385em>HTTP</a>
</li><li>
<a href=/tags/hugo/ style=font-size:1em>Hugo</a>
</li><li>
<a href=/tags/jakartaee/ style=font-size:1.1538461538461537em>JakartaEE</a>
</li><li>
<a href=/tags/java/ style=font-size:1.7692307692307692em>Java</a>
</li><li>
<a href=/tags/jdbc/ style=font-size:1em>JDBC</a>
</li><li>
<a href=/tags/jvm/ style=font-size:1.2307692307692308em>JVM</a>
</li><li>
<a href=/tags/leetcode/ style=font-size:1.1538461538461537em>Leetcode</a>
</li><li>
<a href=/tags/life/ style=font-size:1em>Life</a>
</li><li>
<a href=/tags/linux/ style=font-size:1.0769230769230769em>Linux</a>
</li><li>
<a href=/tags/mybatis/ style=font-size:1em>MyBatis</a>
</li><li>
<a href=/tags/networks/ style=font-size:1.1538461538461537em>Networks</a>
</li><li>
<a href=/tags/os/ style=font-size:1.4615384615384617em>OS</a>
</li><li>
<a href=/tags/ostep/ style=font-size:1.1538461538461537em>OSTEP</a>
</li><li>
<a href=/tags/python/ style=font-size:1em>Python</a>
</li><li>
<a href=/tags/redis/ style=font-size:1.4615384615384617em>Redis</a>
</li><li>
<a href=/tags/sicp/ style=font-size:1em>SICP</a>
</li><li>
<a href=/tags/tomcat/ style=font-size:1em>Tomcat</a>
</li><li>
<a href=/tags/zookeeper/ style=font-size:1em>ZooKeeper</a>
</li><li>
<a href=/tags/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/ style=font-size:1.0769230769230769em>多处理器编程的艺术</a>
</li><li>
<a href=/tags/%E5%B7%A5%E7%A8%8B%E6%80%9D%E7%BB%B4/ style=font-size:1em>工程思维</a>
</li><li>
<a href=/tags/%E5%B9%B6%E5%8F%91/ style=font-size:1.3076923076923077em>并发</a>
</li><li>
<a href=/tags/%E6%90%9C%E7%B4%A2/ style=font-size:1em>搜索</a>
</li><li>
<a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/ style=font-size:1em>数据库</a>
</li><li>
<a href=/tags/%E6%B8%B8%E8%AE%B0/ style=font-size:1em>游记</a>
</li><li>
<a href=/tags/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ style=font-size:1.0769230769230769em>现代操作系统</a>
</li><li>
<a href=/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/ style=font-size:1em>生产者消费者</a>
</li><li>
<a href=/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/ style=font-size:1.2307692307692308em>算法导论</a>
</li><li>
<a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ style=font-size:2em>设计模式</a>
</li></ul>
</div>
</section>
</div>
<div class=sidebar-overlay></div>
</div><div class=main><nav id=main-menu class="menu main-menu" aria-label=主菜单>
<div class=container>
<a class=screen-reader-text href=#content>跳到内容</a>
<button id=sidebar-toggler class=sidebar-toggler aria-controls=sidebar>
<span class=screen-reader-text>Toggle Sidebar</span>
<span class=open><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
</span>
<span class=close><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
</span>
</button>
<ul><li class=item>
<a href=/>主页</a>
</li><li class="item current">
<a aria-current=page href=/posts/>博客</a>
</li><li class=item>
<a href=/notebook/>笔记本</a>
</li><li class=item>
<a href=/itinerary/>游山玩水</a>
</li></ul>
</div>
</nav><div class=header-widgets>
<div class=container>
<style>.widget-breadcrumbs li:after{content:'\2f '}</style>
<section class="widget widget-breadcrumbs sep-after">
<nav id=breadcrumbs>
<ol><li><a href=/>主页</a></li><li><a href=/posts/>博客</a></li><li><span>Java Web复习笔记</span></li></ol>
</nav>
</section></div>
</div>
<header id=header class="header site-header">
<div class="container sep-after">
<div class=header-info><p class="site-title title">Nicholas Zhan</p><p class="desc site-desc">Java Developer, Runner, Cyclist</p>
</div>
</div>
</header>
<main id=content>
<article lang=zh-cn class=entry>
<header class="header entry-header">
<div class="container sep-after">
<div class=header-info>
<h1 class=title>Java Web复习笔记</h1>
</div>
<div class=entry-meta>
<span class=posted-on><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
<span class=screen-reader-text>Posted on </span>
<time class=entry-date datetime=2018-08-19T23:02:41+08:00>2018, Aug 19</time>
</span>
<span class=byline><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M21 21V20c0-2.76-4-5-9-5s-9 2.24-9 5v1"/><path d="M16 6.37A4 4 0 1112.63 3 4 4 0 0116 6.37z"/></svg>
<span class=screen-reader-text> by </span><a href=/authors/zhannicholas>Nicholas Zhan</a></span>
<span class=reading-time><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 15 15"/></svg>
19 mins read
</span>
</div>
</div>
</header>
<details class="container entry-toc">
<summary class=title>
<span>目录</span>
</summary>
<nav id=TableOfContents>
<ul>
<li><a href=#servlet>Servlet</a>
<ul>
<li><a href=#servlet的功能>Servlet的功能</a></li>
<li><a href=#sevlet容器>Sevlet容器</a></li>
<li><a href=#servlet生命周期方法>Servlet生命周期方法</a></li>
<li><a href=#servletconfig接口>ServletConfig接口</a></li>
<li><a href=#servletcontext接口>ServletContext接口</a></li>
<li><a href=#servletrequest接口>ServletRequest接口</a></li>
<li><a href=#servletresponse接口>ServletResponse接口</a></li>
<li><a href=#genericservlet>GenericServlet</a></li>
<li><a href=#httpservlet>HttpServlet</a></li>
</ul>
</li>
<li><a href=#jsp>JSP</a>
<ul>
<li><a href=#jsp运行原理>JSP运行原理</a></li>
<li><a href=#jsp页面的隐含对象>JSP页面的隐含对象</a></li>
<li><a href=#jsp基本语法>JSP基本语法</a></li>
<li><a href=#jsp中对域对象的属性操作>JSP中对域对象的属性操作</a></li>
<li><a href=#jsp指令>JSP指令</a></li>
<li><a href=#jsp标签>JSP标签</a></li>
<li><a href=#请求的转发与重定向>请求的转发与重定向</a></li>
<li><a href=#cookie与session>Cookie与Session</a></li>
</ul>
</li>
<li><a href=#jdbc>JDBC</a>
<ul>
<li><a href=#driver接口>Driver接口</a></li>
<li><a href=#加载与注册jdbc驱动>加载与注册JDBC驱动</a></li>
<li><a href=#建立数据库连接>建立数据库连接</a></li>
<li><a href=#数据库的查询和更新>数据库的查询和更新</a></li>
<li><a href=#resultset>ResultSet</a></li>
<li><a href=#常用数据类型转换表>常用数据类型转换表</a></li>
<li><a href=#使用jdbc驱动程序处理元数据>使用JDBC驱动程序处理元数据</a></li>
<li><a href=#数据库连接池>数据库连接池</a></li>
</ul>
</li>
<li><a href=#mvc设计模式>MVC设计模式</a>
<ul>
<li><a href=#模型>模型</a></li>
<li><a href=#视图>视图</a></li>
<li><a href=#控制器>控制器</a></li>
</ul>
</li>
<li><a href=#filter过滤器>Filter(过滤器)</a>
<ul>
<li><a href=#filter接口>Filter接口</a></li>
<li><a href=#filter的配置>Filter的配置</a></li>
</ul>
</li>
<li><a href=#listener监听器>Listener(监听器)</a>
<ul>
<li><a href=#listener的分类>Listener的分类</a></li>
</ul>
</li>
</ul>
</nav>
</details>
<div class="container entry-content">
<h1 id=java-web复习笔记>Java WEB复习笔记</h1>
<blockquote>
<p>这是为了准备秋招面试而对Java Web开发进行的复习。</p>
</blockquote>
<p>首先，对于一个Java Web应用，它由一组Servlet、HTML页、实用类、以及其它可以被绑定的资源构成。它运行于实现了Servlet规范的Servlet容器中。</p>
<h2 id=servlet>Servlet</h2>
<p>Java Servlet和平台无关，它运行于Servlet容器中。Servlet容器负责Servlet和客户端的通信以及调用Servlet的方法，Servlet和客户端的通信采用的是 <strong>请求/响应</strong> 模式。</p>
<h3 id=servlet的功能>Servlet的功能</h3>
<ol>
<li>创建并返回基于客户端请求的动态HTML页面。</li>
<li>创建可嵌入到现有HTML页面中的HTML片段。</li>
<li>与其它服务器资源进行通信。</li>
</ol>
<h3 id=sevlet容器>Sevlet容器</h3>
<p>Servlet容器可以创建Servlet，并调用Servlet相关生命周期方法。还是运行JSP等的软件环境。</p>
<h3 id=servlet生命周期方法>Servlet生命周期方法</h3>
<ol>
<li>构造器：只调用一次。只有第一次请求Servlet的时候，才调用构造器，创建Servlet实例。即Servlet使 <strong>单实例</strong> 的。</li>
<li><code>init()</code>方法：只调用一次。在Servlet实例创建完毕后立即被调用，用于初始化当前Servlet。</li>
<li><code>service()</code>方法：每次请求都会调用，用于相应请求。</li>
<li><code>destroy()</code>方法：只调用一次。在当前Servlet所在的Web应用被卸载前调用，用于释放当前Servlet所占有的资源。</li>
</ol>
<h3 id=servletconfig接口>ServletConfig接口</h3>
<p>这个接口封装了 <strong>当前</strong> Servlet的配置信息，并可以获取ServletContext对象。</p>
<ul>
<li><code>String getServletName();</code>: 获取Servlet的配置名。</li>
<li><code>ServletContext getServletContext();</code>: 获取对应的ServletConfig对象。</li>
<li><code>String getInitParameter(String var1);</code>: 获取指定参数名的初始化参数。</li>
<li><code>Enumeration&lt;String> getInitParameterNames();</code>: 获取参数名组成的Enumerarion。</li>
</ul>
<h3 id=servletcontext接口>ServletContext接口</h3>
<p>Servlet引擎为每一个Web应用都创建一个对应的ServletContext对象。这个对象由Web应用中 <strong>所有</strong> 的Servlet所共享。它实际代表了当前的Web应用。</p>
<p>ServletContext有很多的功能，比如：</p>
<ol>
<li>
<p>获取当前Web应用的初始化参数</p>
<ul>
<li><code>String getInitParameter(String var1);</code>: 获取指定参数名的初始化参数。</li>
<li><code>Enumeration&lt;String> getInitParameterNames();</code>: 获取参数名组成的Enumerarion。</li>
</ul>
</li>
<li>
<p>获取虚拟路径所映射的本地路径
-<code>String getRealPath(String var1);</code></p>
</li>
<li>
<p>访问资源文件</p>
</li>
<li>
<p>记录日志</p>
</li>
<li>
<p>设置和获取应用属性</p>
</li>
</ol>
<h3 id=servletrequest接口>ServletRequest接口</h3>
<p>ServletRequest接口封装了请求信息，可以从中获取任何请求信息。</p>
<h4 id=getpost请求>GET&POST请求</h4>
<ol>
<li>GET方式
<ul>
<li>将请求信息附加在请求地址后面</li>
<li>传送的数据量有限</li>
<li>传输信息在浏览器地址栏 <strong>可见</strong></li>
<li>常见于输入URL或点击网页上的超链接</li>
</ul>
</li>
<li>POST方式
<ul>
<li>将数据作为HTTP消息的实体内容传送</li>
<li>传送的数据量比GET方式大得多。</li>
<li>传输信息在浏览器地址栏 <strong>不可见</strong></li>
<li>主要用于提交表单数据</li>
</ul>
</li>
</ol>
<h4 id=获取请求参数>获取请求参数</h4>
<ol>
<li><code>String getParameter(String var1);</code>: 根据请求参数的名字返回参数值。</li>
<li><code>Enumeration&lt;String> getParameterNames();</code>：返回参数名对应的Enumaration对象。</li>
<li><code>String[] getParameterValues(String var1);</code>：根据请求参数的名字返回请求参数对应的数组，如获取多选框信息。</li>
<li><code>Map&lt;String, String[]> getParameterMap();</code>：返回请求参数的键值对。</li>
</ol>
<h3 id=servletresponse接口>ServletResponse接口</h3>
<p>ServletResponse接口封装了响应信息，给客户端的响应取决于本接口实现的方法。常用的方法有：</p>
<ul>
<li><code>PrintWriter getWriter() throws IOException;</code>: 返回一个PrintWriter对象。然后我们可以调用该对象的<code>print("something")</code>方法打印信息到浏览器上。</li>
<li><code>void setContentType(String var1);</code>: 设置响应的内容类型。</li>
</ul>
<h3 id=genericservlet>GenericServlet</h3>
<p>GenericServlet同时实现了Servlet接口、ServletConfig接口和 Serializable接口，和各种协议无关。HttpServlet就继承于它。</p>
<h3 id=httpservlet>HttpServlet</h3>
<p>HttpServlet继承自GeniricServlet实现类，用于 HTTP协议。它在<code>service()</code>方法中将使用<code>HttpServletRequest.getMothod()</code>方法来获取请求方式，然后根据不同的请求方式创建不同的具体的处理方式。</p>
<h2 id=jsp>JSP</h2>
<blockquote>
<p>JSP页面由HTML语句和嵌套在其中的Java代码组成。本质还是Servet。JSP页面中的java代码需要嵌套在<code>&lt;%</code>和<code>%></code>中。</p>
</blockquote>
<h3 id=jsp运行原理>JSP运行原理</h3>
<p>当Web容器接收到以<code>.jsp</code>为扩展名的URL请求时，将该请求转交给JSP引擎处理。每个JSP页面在第一次被访问的时候，JSP引擎都会把它翻译为一个Servlet源程序并编译。然后Web容器就可以像调用普通Servlet程序一样来处理这个由JSP页面翻译而来的Servlet程序。</p>
<h3 id=jsp页面的隐含对象>JSP页面的隐含对象</h3>
<p>这些隐含对象不用声明，可以直接使用。一共有9个。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>_jspService</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> javax<span style=color:#f92672>.</span><span style=color:#a6e22e>servlet</span><span style=color:#f92672>.</span><span style=color:#a6e22e>http</span><span style=color:#f92672>.</span><span style=color:#a6e22e>HttpServletRequest</span> request<span style=color:#f92672>,</span> <span style=color:#66d9ef>final</span> javax<span style=color:#f92672>.</span><span style=color:#a6e22e>servlet</span><span style=color:#f92672>.</span><span style=color:#a6e22e>http</span><span style=color:#f92672>.</span><span style=color:#a6e22e>HttpServletResponse</span> response<span style=color:#f92672>)</span>
      <span style=color:#66d9ef>throws</span> java<span style=color:#f92672>.</span><span style=color:#a6e22e>io</span><span style=color:#f92672>.</span><span style=color:#a6e22e>IOException</span><span style=color:#f92672>,</span> javax<span style=color:#f92672>.</span><span style=color:#a6e22e>servlet</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ServletException</span> <span style=color:#f92672>{</span>

    <span style=color:#66d9ef>final</span> javax<span style=color:#f92672>.</span><span style=color:#a6e22e>servlet</span><span style=color:#f92672>.</span><span style=color:#a6e22e>jsp</span><span style=color:#f92672>.</span><span style=color:#a6e22e>PageContext</span> pageContext<span style=color:#f92672>;</span>
    javax<span style=color:#f92672>.</span><span style=color:#a6e22e>servlet</span><span style=color:#f92672>.</span><span style=color:#a6e22e>http</span><span style=color:#f92672>.</span><span style=color:#a6e22e>HttpSession</span> session <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>final</span> javax<span style=color:#f92672>.</span><span style=color:#a6e22e>servlet</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ServletContext</span> application<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>final</span> javax<span style=color:#f92672>.</span><span style=color:#a6e22e>servlet</span><span style=color:#f92672>.</span><span style=color:#a6e22e>ServletConfig</span> config<span style=color:#f92672>;</span>
    javax<span style=color:#f92672>.</span><span style=color:#a6e22e>servlet</span><span style=color:#f92672>.</span><span style=color:#a6e22e>jsp</span><span style=color:#f92672>.</span><span style=color:#a6e22e>JspWriter</span> out <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>final</span> java<span style=color:#f92672>.</span><span style=color:#a6e22e>lang</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Object</span> page <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>;</span>
    javax<span style=color:#f92672>.</span><span style=color:#a6e22e>servlet</span><span style=color:#f92672>.</span><span style=color:#a6e22e>jsp</span><span style=color:#f92672>.</span><span style=color:#a6e22e>JspWriter</span> _jspx_out <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    javax<span style=color:#f92672>.</span><span style=color:#a6e22e>servlet</span><span style=color:#f92672>.</span><span style=color:#a6e22e>jsp</span><span style=color:#f92672>.</span><span style=color:#a6e22e>PageContext</span> _jspx_page_context <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>

    <span style=color:#75715e>// 内嵌Java代码翻译后的位置，这里有第9个隐含对象: exception
</span><span style=color:#75715e></span>
  <span style=color:#f92672>}</span>
</code></pre></div><p>9个隐含对象分别是：</p>
<ol>
<li><code>request</code>: HttpServletRequest的一个对象。</li>
<li><code>response</code>: HttpSevletResponse的一个对象。</li>
<li><code>pageContext</code>: PageContext的一个对象，可以从中获取到其它8个隐含对象以及页面的其它信息。</li>
<li><code>session</code>: HttpSession的一个对象，代表浏览器和服务器的一次会话。</li>
<li><code>application</code>: ServletContext的一个对象，代表当前的Web应用。</li>
<li><code>config</code>: ServletConfig的一个对象。</li>
<li><code>out</code>: JspWriter的一个对象。调用<code>out.println()</code>可直接把字符串打印到浏览器。</li>
<li><code>page</code>： 指向当前JSP对应的Servlet对象的引用，使Object类型，只能使用Object类的方法。</li>
<li><code>exception</code>：异常对象。在JSP页面中声明了<code>isErrorPage=true</code>后才会启用。</li>
</ol>
<h3 id=jsp基本语法>JSP基本语法</h3>
<h4 id=jsp模板元素>JSP模板元素</h4>
<p>JSP中的HTML代码就是JSP模板元素。这是整个网页的骨架。</p>
<h4 id=jsp表达式>JSP表达式</h4>
<p>可以使用JSP表达式直接将一个Java变量或者表达式的计算结果输出到浏览器。待输出的变量或者表达式要在<code>&lt;%=</code>和<code>%></code>之间。</p>
<ul>
<li>计算结果是一个字符串。</li>
<li>变量或表达式后面不能有分号，因为每个表达式都被翻译为一条<code>out.print()</code>语句。</li>
</ul>
<h4 id=jsp脚本片段>JSP脚本片段</h4>
<p>脚本片段就是嵌套在<code>&lt;%</code>和<code>%></code>之间的Java代码。这些脚本片段将被原封不动的被搬进JSP页面翻译成Servlet的<code>_JspService()</code>方法中。</p>
<ul>
<li>多个脚本片段中的代码是可以相互访问的。</li>
<li>单个脚本片段中的Java语句可以不少完整的，但多个脚本片段组合后的结果必须是完整的。</li>
</ul>
<h4 id=jsp声明>JSP声明</h4>
<p>JSP声明将Java代码封装在<code>&lt;%!</code>和<code>%></code>之间。这里面的代码会被插入到Servlet的<code>_jspService()</code>方法外面。
常用来定义相关的静态代码块、成员变量和方法。</p>
<h3 id=jsp中对域对象的属性操作>JSP中对域对象的属性操作</h3>
<p>这里的域对象指的是<code>request</code>, <code>session</code>, <code>application</code>, <code>pageContext</code>这四个对象。它们都拥有下面的几个和属性相关的方法：</p>
<ul>
<li><code>Object getAttribute(String var1);</code>: 获取指定属性值。</li>
<li><code>Enumeration&lt;String> getAttributeNames();</code>: 获取所有属性名组成的Enumeration对象。</li>
<li><code>void setAttribute(String var1, Object var2);</code>: 设置属性。</li>
<li><code>void removeAttribute(String var1)</code>: 移除指定属性。</li>
</ul>
<p>它们的作用范围各不相同，下面从小到大排列：</p>
<ul>
<li><code>pageContext</code>: 仅限于当前页面，范围最小。</li>
<li><code>request</code>: 仅限于同一个请求。</li>
<li><code>session</code>: 仅限于一次会话（默认从浏览器打开到关闭）。</li>
<li><code>application</code>: 仅限于当前Web应用，范围最大。</li>
</ul>
<h3 id=jsp指令>JSP指令</h3>
<p>JSP指令用来告诉JSP引擎如何处理页面中的其余部分。基本的语法格式为：<code>&lt;%@ 指令 属性名="属性值" %></code>。主要有一下三种指令：</p>
<ol>
<li>page指令：用来定义页面的各种属性。</li>
<li>include指令：用来通知JSP引擎在翻译JSP页面的时候将其他文件中的内容包含进当前JSP页面翻译成的Servlet中。使用的是 <strong>相对路径</strong> 。</li>
<li>taglib指令：用来引入所使用的标签库</li>
</ol>
<h3 id=jsp标签>JSP标签</h3>
<ol>
<li><code>&lt;jsp:include></code>标签：用来把应一个资源的输出内容插入到当前JSP页面的输出内容中。使用 <strong>相对路径</strong>。</li>
<li><code>&lt;jsp:forward></code>标签：用于把请求转发个另一个资源。使用 <strong>相对路径</strong>。</li>
<li><code>&lt;jsp:param></code>标签：用来向程序传递参数信息。使用 <strong>相对路径</strong>。</li>
</ol>
<h3 id=请求的转发与重定向>请求的转发与重定向</h3>
<h4 id=请求转发>请求转发</h4>
<p>可以使用<code>RequestDispatcher</code>接口中的<code>forward()</code>方法进行请求转发。这个接口中定义了两个方法：</p>
<ol>
<li><code>include(ServletRequest request, ServletResponse response)</code>方法：转发到请求到当前Web应用中的其他资源。</li>
<li><code>forward(ServletRequest request, ServletResponse response)</code>方法：在响应中包含资源。</li>
</ol>
<p>可以使用<code>RequestDispatcher getRequestDispatcher(String forwardPath);</code>来获取<code>RequestDispatcer</code>。</p>
<h4 id=请求的重定向>请求的重定向</h4>
<p>可以使用<code>sendRedirect()</code>方法来进行请求的重定向。不仅可以重定向到当前应用程序中的其它资源，还可以到同一站点上的其它应用程序中的资源，甚至
可以使用绝对路径到其它站点的资源。</p>
<h4 id=请求转发和重定向的比较>请求转发和重定向的比较</h4>
<p>本质区别：请求转发只向服务器发出 <strong>一次</strong> 请求，而重定向发出了 <strong>两次</strong> 请求。</p>
<table>
<thead>
<tr>
<th style=text-align:left>方法</th>
<th style=text-align:center>请求转发</th>
<th style=text-align:center>请求重定向</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>地址栏变化</td>
<td style=text-align:center>首次发出的请求地址</td>
<td style=text-align:center>重定向后最后响应的那个地址</td>
</tr>
<tr>
<td style=text-align:left>最终Servlet中的request对象</td>
<td style=text-align:center>和中转的那个request是同一个对象</td>
<td style=text-align:center>和中转的那个request不是同一个对象</td>
</tr>
<tr>
<td style=text-align:left>作用范围</td>
<td style=text-align:center>限于当前Web应用</td>
<td style=text-align:center>服务器上任何资源</td>
</tr>
<tr>
<td style=text-align:left>&ldquo;\&rdquo;</td>
<td style=text-align:center>代表当前Web应用的根目录</td>
<td style=text-align:center>代表整个Web站点的根目录</td>
</tr>
</tbody>
</table>
<h3 id=cookie与session>Cookie与Session</h3>
<p>HTTP是一种无状态的协议。<code>Cookie</code>和<code>Session</code>是Servlet中的两种会话跟踪机制。</p>
<h4 id=cookie>Cookie</h4>
<p><code>Cookie</code>采用的是在 <strong>客户端</strong> 保持HTTP状态信息的方案。它是在当浏览器访问WEB服务器上的某个资源的时候，有WEB服务器在HTTP响应消息头中附带传送的一个小的文本文件。<em>一旦浏览器保存了这个Cookie，以后每次访问服务器的时候都会在HTTP消息头中将这个Cookie回传给服务器。</em></p>
<ul>
<li>可以通过<code>response</code>对象的<code>addCookie(Cookie cookie)</code>方法向浏览器写入Cookie。</li>
<li>可以通过<code>request</code>对象的<code>getCookie()</code>方法从客户端获取Cookie。</li>
</ul>
<p>默认情况下的Cookie当关闭浏览器的时候会消失。可以通过<code>setMaxAge()</code>方法设置Cookie的存活时间。</p>
<h4 id=session>Session</h4>
<p><code>Session</code>采用的是在 <strong>服务端</strong> 保持HTTP状态信息的方案，以Cookie（默认实现方式，系统会创造一个名为JSESSIONID的输出cookie，称为session cookie）或者URL重写（禁用Cookie后的解决方案）为基础，使用<code>SessionId</code>唯一标识一个Session。</p>
<ol>
<li>Session的创建
<ul>
<li>当服务端的某个程序调用类似于<code>HttpServletRequest.getSession()</code>的方法的时候，Session对象 <strong>才会被创建</strong> 。</li>
</ul>
</li>
<li>Session的删除
<ul>
<li>程序调用<code>HttpSession.invalidate()</code>方法</li>
<li>超过有效期</li>
<li>服务端进程终止</li>
</ul>
</li>
<li>URL重写
<ul>
<li>使用<code>HttpServletResponse</code>接口定义的的<code>encodeURL()</code>或<code>encodeRedirectURL()</code>方法。</li>
</ul>
</li>
</ol>
<h2 id=jdbc>JDBC</h2>
<p>JDBC为Java程序员提供了一个独立于特定数据库管理系统、通用SQL数据库存取和操作的公共接口，可以使用它来连接提供了JDBC驱动的数据库。</p>
<h3 id=driver接口>Driver接口</h3>
<p><code>Java.sql.Driver</code>接口是所有JDBC驱动程序都需要实现的接口，由不同的厂商提供不同的实现。</p>
<h3 id=加载与注册jdbc驱动>加载与注册JDBC驱动</h3>
<ul>
<li>可以通过调用<code>Class</code>类的静态方法<code>forName()</code>来加载JDBC驱动。</li>
<li><code>DriverManager</code>类负责管理驱动程序，它会调用Driver接口的实现。</li>
</ul>
<h3 id=建立数据库连接>建立数据库连接</h3>
<p>数据库连接用来向数据库服务器发送命令。</p>
<ul>
<li>
<p>可以调用<code>DriverManager</code>类的<code>getConnection()</code>方法建立到数据库的连接。还可以使用<code>Driver</code>接口的<code>connect()</code>方法建立到数据库的连接。其中<code>DriverManager</code>使用起来更加方便，还可以管理多个不同的驱动程序。</p>
</li>
<li>
<p>JDBC URL用来标识一个被注册的驱动程序。驱动程序管理器会通过这个URL选择正确的驱动程序，从而建立到数据库的连接。JDBC URL的标准由三部分组成，各个部分之间用冒号<code>:</code>分隔。</p>
<ul>
<li>协议：JDBC中总是<code>jdbc</code></li>
<li>子协议：用来标识一个数据库驱动程序</li>
<li>子名称：为定位数据库提供足够的信息</li>
</ul>
<p>比如：使用mysql数据库的url连接可以是这样的：<code>jdbc:mysql：//localhost:3306/database</code>。
<code>java.sql</code>中有三个接口分别定义了对数据库的不同访问方式：</p>
</li>
</ul>
<ol>
<li>Statement接口
<ul>
<li><code>Statement</code>接口用来执行静态SQL语句。</li>
<li>可以通过调用<code>Connection</code>对象的<code>createStatement()</code>方法创建<code>Statement</code>对象。剩下的两个接口都是这个接口的子类型。</li>
</ul>
</li>
<li>PreparedStatement
<ul>
<li><code>PreparedStatement</code>接口用来执行预编译的SQL语句。</li>
<li>可以通过调用<code>Connection</code>对象的<code>prepareStatement()</code>方法来获取<code>PreparedStatement</code>对象。</li>
<li><code>PreparedStatement</code>对象多代表的SQL语句中的参数用问号<code>?</code>来表示，并通过对应的<code>setXXX(index, value)</code>来设置这些参数。其中<code>index</code>从<code>1</code>开始。</li>
<li>使用本接口可以防止SQL注入。</li>
</ul>
</li>
<li>CallableStatement
<ul>
<li><code>CallableStatement</code>接口用来执行SQL存储程序。</li>
</ul>
</li>
</ol>
<h3 id=数据库的查询和更新>数据库的查询和更新</h3>
<ol>
<li>数据库更新
<ul>
<li>常用<code>int executeUpdate​(String sql)</code>方法可以进行数据库的插入、修改和删除操作。</li>
</ul>
</li>
<li>数据库查询
<ul>
<li>常用<code>ResultSet executeQuery​(String sql)</code>方法来进行数据库的查询操作。</li>
</ul>
</li>
</ol>
<h3 id=resultset>ResultSet</h3>
<p><code>ResultSet</code>接口以逻辑表格的形式封装了执行数据库操作得到的结果集。<code>ResultSet</code>对象维护了一个指向当前数据行的 <strong>游标</strong> 。初始的时候，游标在表格的第一行 <strong>之前</strong> 。可以通过<code>next()</code>方法移动到下一行，然后调用<code>getXXX(index)</code>或<code>getXXX(columnName)</code>来获取对应列的值。</p>
<h3 id=常用数据类型转换表>常用数据类型转换表</h3>
<table>
<thead>
<tr>
<th style=text-align:left>Java类型</th>
<th style=text-align:left>SQL类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>int</td>
<td style=text-align:left>INTEGER</td>
</tr>
<tr>
<td style=text-align:left>long</td>
<td style=text-align:left>BIGINT</td>
</tr>
<tr>
<td style=text-align:left>short</td>
<td style=text-align:left>SMALLINT</td>
</tr>
<tr>
<td style=text-align:left>String</td>
<td style=text-align:left>CHAR, VARCHAR, LONGVARCHAR</td>
</tr>
<tr>
<td style=text-align:left>boolean</td>
<td style=text-align:left>BIT</td>
</tr>
<tr>
<td style=text-align:left>byte</td>
<td style=text-align:left>TINYINT</td>
</tr>
<tr>
<td style=text-align:left>byte array</td>
<td style=text-align:left>BINARY, VARBINART</td>
</tr>
<tr>
<td style=text-align:left>java.sql.Date</td>
<td style=text-align:left>DATE</td>
</tr>
<tr>
<td style=text-align:left>java.sql.Time</td>
<td style=text-align:left>TIME</td>
</tr>
<tr>
<td style=text-align:left>java.sql.Timestamp</td>
<td style=text-align:left>TIMESTAMP</td>
</tr>
</tbody>
</table>
<h3 id=使用jdbc驱动程序处理元数据>使用JDBC驱动程序处理元数据</h3>
<p>元数据是关于数据的数据。</p>
<h4 id=databasemetadata类>DatabaseMetaData类</h4>
<p><code>DatabaseMetaData</code>类提供了获取和数据库系统有关的各种信息的方法，也就是 <strong>元数据</strong> 。而又可以从<code>Connection</code>对象获得<code>DatabaseMetaData</code>的对象。</p>
<h4 id=resultsetmetadata类>ResultSetMetaData类</h4>
<p><code>ResultSetMetaData</code>类提供了获取<code>ResultSet</code>对象中列的类型和属性信息的方法。</p>
<ul>
<li>可以通过调用<code>ResultSet</code>对象的<code>getMetaData()</code>方法来获取它的对象。</li>
<li>可以使用<code>getColumnCount()</code>方法来获取SQL语句中查询了多少列。</li>
<li>可以使用<code>getColumnLabel(int colunm)</code>方法来获取指定列的别名。其中索引从1开始。</li>
</ul>
<h3 id=数据库连接池>数据库连接池</h3>
<p>数据库连接池的基本思想是为数据库建立一个缓冲池，并预先往缓冲池里放入一定数量的连接。当需要和数据库建立连接时，直接从连接池里取出连接，用完之后再归还给连接池。</p>
<p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。</p>
<h2 id=mvc设计模式>MVC设计模式</h2>
<p>MVC把应用分为模型、视图和控制器三个模块，它们各自处理不同而任务。</p>
<h3 id=模型>模型</h3>
<p>模型应用程序的主体部分，表示业务数据和业务逻辑。一个模型可以为多个视图提供数据。</p>
<h3 id=视图>视图</h3>
<p>视图接收用户输入、向用户展示相关数据。但不进行任何实际的业务处理。</p>
<h3 id=控制器>控制器</h3>
<p>控制器接收用户请求并决定调用哪个模型去处理请求，然后决定调用哪个视图显示模型处理返回的数据。</p>
<h2 id=filter过滤器>Filter(过滤器)</h2>
<blockquote>
<p>Filter是Java Web的一个重要组件，它的基本功能是对Servlet容器调用Servlet的进程进行拦截（拦截请求和响应），从而在Servlet进行响应处理的 <strong>前后</strong> 实现一些特殊的功能。</p>
</blockquote>
<p>Servlet的API中定义了三个供开发人员编写Filter程序的接口：<code>Filter</code>, <code>FilterChain</code>, <code>FilterConfig</code>。Filter程序是一个实现了Filter接口的Java类，它和Servlet非常类似，并且由Servlet容器进行调用和执行。没有相应的Filter实现类可供继承，要开发Filter，需要自己实现接口。</p>
<p>和使用Servlet类似，Filter程序需要在<code>web.xml</code>文件中注册和设置它所能拦截的资源（Jsp, Servlet, image, html），这也可以通过 <strong>注解</strong> 来完成。</p>
<p>对于多个Filter拦截同一个url的情况：</p>
<ul>
<li>
<p>使用注解：多个Filter的执行顺序的由Filter实现类名的字符顺序来决定，这会给维护增加难度。比如：现在有<code>Test1Filter</code>和<code>Test2Filter</code>,它们都对<code>test.jsp</code>进行拦截。初始化的顺序是：<code>Test1Filter</code>先初始化，而后是<code>Test2Filter</code>。拦截执行的顺序是：<code>Test2Filter</code>在前，而<code>Test1Filter</code>在后。</p>
</li>
<li>
<p>使用<code>web.xml</code>：执行按照<code>filer-mapping</code>声明顺序执行，这就更加清晰可见。最好使用后一种方法。</p>
</li>
</ul>
<h3 id=filter接口>Filter接口</h3>
<ol>
<li><code>default void init(FilterConfig filterConfig) throws ServletException</code>
<ul>
<li>Filer对象的初始化方法，在Filter对象被创建时（Filter对象在Servlet容器加载当前Web应用时被创建）执行，只执行 <strong>一次</strong></li>
<li>FilterConfig类似于ServletConfig</li>
</ul>
</li>
<li><code>void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3)</code>
<ul>
<li>逻辑代码，每次拦截都会被调用</li>
<li>FilterChain: 多个Filter构成的一个链。在特定的操作完成后，可以在当前Filter对象的<code>doFilter()</code>方法内部需要调用FilterChain 对象的<code>chain.doFilter(request,response)</code>方法才能把请求交付给Filter链中的下一个Filter或者目标Servlet程序去处理，也可以直接向客户端返回响应信息，或者利用RequestDispatcher的<code>forward()</code>和<code>include()</code>方法，以及HttpServletResponse的<code>sendRedirect()</code>方法将请求转向到其他资源。</li>
</ul>
</li>
<li><code>default void destroy()</code>
<ul>
<li>用来释放当前Filter所占用的资源，在Filter被销毁之前调用，只调用一次。</li>
</ul>
</li>
</ol>
<h3 id=filter的配置>Filter的配置</h3>
<h4 id=filter的注册>Filter的注册</h4>
<p>在<code>web.xml</code>中注册Filter，使用<code>&lt;filter></code>元素，也可以用注解注册。使用<code>web.xml</code>时：</p>
<ul>
<li><code>&lt;filter-name></code>为Filter指定一个名字，不能为空。</li>
<li><code>&lt;filter-class></code>为Filter的完整限定类名。</li>
<li><code>&lt;init-param></code>用来设置初始化参数（使用<code>&lt;param-name></code>指定参数名，<code>&lt;param-value></code>指定参数值）。</li>
</ul>
<p>这一步骤使用注解会方便得多。</p>
<h4 id=filter的映射>Filter的映射</h4>
<p>使用<code>&lt;filter-mapping></code>元素，可以为一个Filter设置所负责拦截的资源，其中有两种方式可以指定：Servlet名称和资源访问的请求路径(url)。</p>
<ul>
<li><code>&lt;filter-name></code>子元素用于设置filter的注册名，该名必须是已经注册了的名字。</li>
<li><code>&lt;url-pattern></code>用来设置拦截的请求路径</li>
<li><code>&lt;servlet-name></code>用来指定拦截的Servlet名称</li>
<li><code>&lt;dispatcher></code>指定所拦截的资源被Servlet容器调用的方式。可以是：<code>REQUEST</code>, <code>INCLUDE</code>, <code>FORWARD</code>和<code>ERROR</code>。默认是<code>REQUEST</code>。
<ul>
<li>REQUEST: 当用户 <strong>直接</strong> 访问页面的时候，这个Filter会被调用。如果目标资源是通过<code>RequestDispatcher</code>的<code>include()</code>或<code>forward()</code>方法访问的话，就不会被调用。</li>
<li>INCLUDE: 只有当目标资源时通过<code>RequestDispatcher</code>的<code>include()</code>方法访问时，Filter才会被调用。</li>
<li>FORWARD: 只有当目标资源时通过<code>RequestDispatcher</code>的<code>forward()</code>方法访问时，Filter才会被调用。</li>
<li>ERROR: 只有当目标资源时通过声明式异常处理机制调用的时候，Filter才会被调用。</li>
</ul>
</li>
</ul>
<h2 id=listener监听器>Listener(监听器)</h2>
<blockquote>
<p>Listener是专门用来对其它对象身上发生的事件或者状态改变进行监听和采取相应处理的对象。</p>
</blockquote>
<p>Servlet监听器是Servlet规范中定义的一种特殊的类，用于监听Web应用程序中的<code>ServletContext</code>, <code>HttpSession</code>和<code>ServletRequest</code>等域对象的创建、销毁以及属性发生改变的事件。</p>
<h3 id=listener的分类>Listener的分类</h3>
<h4 id=监听域对象自身的创建和销毁的listener>监听域对象自身的创建和销毁的Listener</h4>
<ol>
<li>ServletContextListener接口
<ul>
<li>这个接口用于监听ServletContext对象的创建和销毁事件。当ServletContext对象被创建的时候，触发<code>contextInitialized()</code>方法；当ServletContext对象被销毁的时候，触发<code>contextDestroyed()</code>方法。常用来对当前Web应用进行初始化操作。</li>
</ul>
</li>
<li>HttpSessionListener接口
<ul>
<li>这个接口用于监听HttpSession对象的创建和销毁事件。当Session对象被创建的时候，触发<code>sessionCreated()</code>方法；当Session对象被销毁的时候，触发<code>sessionDestroyed()</code>方法。</li>
</ul>
</li>
<li>ServletRequestListener接口
<ul>
<li>这个接口用于监听ServletRequest对象的创建和销毁事件。当ServletRequest对象被创建的时候，触发<code>requestInitialized()</code>方法；当ServletRequest对象被销毁的时候，触发<code>requestDestroyed()</code>方法。</li>
</ul>
</li>
</ol>
<h4 id=监听域对象中属性的增加删除或修改的listener>监听域对象中属性的增加、删除或修改的Listener</h4>
<p>有三个Listener接口，分别是<code>ServletContextAttributeListener</code>, <code>HttpSessionAttributeListener</code>和<code>ServletRequestAttributeLitener</code>。它们中分别定义了监听对应域对象的属性的增加、修改和删除的方法。方法名完全相同，只是接受的参数不同。分别是：<code>attributeAdded()</code>, <code>attributeReplaced()</code>和<code>attributeRemoved()</code>。</p>
<h4 id=监听绑定到httpsession域中某个对象状态的listener>监听绑定到HttpSession域中某个对象状态的Listener</h4>
<p>有两个特殊的Listener接口用来帮助JavaBean对象了解自己在Session域中的状态。分别是：</p>
<ol>
<li>HttpSessionBindingListener接口
<ul>
<li>感知自己被绑定到Session中。Web服务器此时会调用<code>valueBound()</code>方法。</li>
<li>感知自己被从Session中解除绑定。Web服务器此时会调用<code>valueUnbound()</code>方法。</li>
</ul>
</li>
<li>HttpSessionActivationListener接口
<ul>
<li>绑定到HttpSession对象的对象将要随HttpSession对象被钝化之前，Web浏览器此时会调用<code>sessionWillPassivate()</code>方法。</li>
<li>绑定到HttpSession对象的对象将要随HttpSession对象被活化之后，Web浏览器此时会调用<code>sessionDidActive()</code>方法。</li>
</ul>
</li>
</ol>
</div>
<footer class=entry-footer>
<div class="container sep-before"><div class=categories><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5A2 2 0 014 3H9l2 3h9a2 2 0 012 2z"/></svg>
<span class=screen-reader-text>分类: </span><a class=category href=/categories/java/>Java</a></div>
<div class=tags><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2H12l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=screen-reader-text>标签: </span><a class=tag href=/tags/java/>Java</a></div>
</div>
</footer>
</article>
<nav class=entry-nav>
<div class=container><div class="prev-entry sep-before">
<a href=/posts/leetcode/perfect-squares/>
<span aria-hidden=true><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="20" y1="12" x2="4" y2="12"/><polyline points="10 18 4 12 10 6"/></svg>
Previous</span>
<span class=screen-reader-text>上一篇: </span>完全平方数</a>
</div><div class="next-entry sep-before">
<a href=/posts/linux/linux%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8E%88%E4%BA%88root%E6%9D%83%E9%99%90%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/>
<span class=screen-reader-text>下一篇: </span>Linux添加用户并授予root权限的简单方法<span aria-hidden=true>下一个<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="4" y1="12" x2="20" y2="12"/><polyline points="14 6 20 12 14 18"/></svg>
</span>
</a>
</div></div>
</nav>
</main>
<footer id=footer class=footer>
<div class="container sep-before"><section class="widget widget-social_menu sep-after"><nav aria-label=社交菜单>
<ul><li>
<a href=https://github.com/zhannicholas target=_blank rel="noopener me">
<span class=screen-reader-text>Open Github account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a>
</li><li>
<a href=https://t.me/zhannicholas target=_blank rel="noopener me">
<span class=screen-reader-text>Open Telegram account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M23.91 3.79 20.3 20.84c-.25 1.21-.98 1.5-2 .94l-5.5-4.07-2.66 2.57c-.3.3-.55.56-1.1.56-.72.0-.6-.27-.84-.95L6.3 13.7.85 12c-1.18-.35-1.19-1.16.26-1.75l21.26-8.2c.97-.43 1.9.24 1.53 1.73z"/></svg>
</a>
</li><li>
<a href=mailto:zhan_nicholas@outlook.com target=_blank rel="noopener me">
<span class=screen-reader-text>Contact via Email</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
</a>
</li><li>
<a href=https://linkedin.com/in/%e4%bc%9f%e4%bc%9f-%e8%a9%b9-27871a104 target=_blank rel="noopener me">
<span class=screen-reader-text>Open Linkedin account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg>
</a>
</li></ul>
</nav>
</section><div class=copyright>
<p> &copy; 2018-2021 Nicholas Zhan </p>
</div>
</div>
</footer>
</div>
</div><script>window.__assets_js_src="/assets/js/"</script>
<script src=/assets/js/main.c3bcf2df.js></script><script src=/js/custom.js></script>
</body>
</html>