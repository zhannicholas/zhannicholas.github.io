<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on 's Digital Garden</title><link>https://zhannicholas.github.io/posts/java/</link><description>Recent content in Java on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 01 Sep 2021 09:46:58 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/posts/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 中的 hashCode() 与 equals()</title><link>https://zhannicholas.github.io/posts/java/lang/java-hashcode-equals-contracts/</link><pubDate>Fri, 27 Aug 2021 22:22:46 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/lang/java-hashcode-equals-contracts/</guid><description>有一道经典的 Java 面试题叫：重写了 equals()，为什么还要重写 hashCode()？
不幸的是，笔者最近也被问到这个问题的变种了。当时面试官的提问点有点奇葩，问我这两个方法在被调用时谁先谁后的问题。笔者当时想，这面试官是不是八股文看多了，连这两方法调用先后都问出来了吗？严格上来说，equals() 和 hashCode() 在绝大多数情况下都是单独调用的，只有在像 HashMap 这样的数据结构的内部实现中，才会存在方法调用的先后关系。笔者当时也没完全搞清楚面试官到底想问什么，所以就象征性的回答了 hashCode() 先调用。今天，笔者突然想到这个问题，感觉当时面试官想问的是 HashMap 内部实现时对这两个方法的依赖情况。
在 Java 中，一切皆对象。并且所有的对象都直接或间接地继承自 java.lang.Object。Object 类定义了一系列 Java 对象所共有的方法，hashCode() 和 equals() 就在其中。
hashCode() {hashCode()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()) 方法用于返回对象的哈希值。Object 类定义了 hashCode() 的契约，这里我直接列出：
The general contract of hashCode is:
Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified.</description></item><item><title>Spring Boot 中的配置体系</title><link>https://zhannicholas.github.io/posts/java/spring/configurations-in-spring-boot/</link><pubDate>Fri, 27 Aug 2021 20:36:10 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/spring/configurations-in-spring-boot/</guid><description>开发的同学可能都遇到过一个 Spring Boot 应用要在多个环境上部署，而每个环境的配置都不同的情况。比如，开发环境用一套配置，测试环境用另一套配置，生产环境又是一套新配置。如果我们把配置放在同一个地方，然后每次都根据不同的环境进行修改，可能要不了多久，我们的头就大了。因为，我们可能一不小心把开发环境的配置放到测试环境中去了……
为了方便我们在不同环境中运行应用程序，Spring Boot 允许我们将配置信息外部化 。Spring Boot 支持多种外部化的配置源，包括 Java 的 properties 文件、YAML 文件、环境变量和命令行参数。
配置源 既然配置可以来自很多不同的地方，那么就有可能出现同一个配置项在多个配置源中出现的情况。所以 Spring Boot 有一个配置值覆盖规则，优先级高的配置会覆盖优先级低的，优先级从低到高依次为：
默认属性（即通过 SpringApplication.setDefaultProperties 设置的属性） @Configuration 类上的 @PropertySource 注解 配置数据（比如 application.properties）。配置数据文件的优先级如下，当.properties 文件与 .yml 文件同时出现时，前者的优先级会高于后者： Jar 包内的 application.properties 和 application.yml Jar 包内特定 Profile 的 application-{profile}.properties 和 application-{profile}.yml Jar 包外的 application.properties 和 application.yml Jar 包外特定 Profile 的 application-{profile}.properties 和 application-{profile}.yml 由 RandomValuePropertySource 配置的 random.* 属性值 操作系统环境变量 Java 系统属性（System.getProperties()） 来自 java:comp/env 的 JNDI 属性 ServletContext 的初始化参数 ServletConfig 的初始化参数 SPRING_APPLICATION_JSON（环境变量或系统属性中的单行 JSON） 中的属性值 命令行参数 测试上的 properties 属性。在 @SpringBootTest 和其它测试相关注解上有用 测试上的 @TestPropertySource 注解 当 devtools 激活时，$HOME/.</description></item><item><title>Spring Ioc</title><link>https://zhannicholas.github.io/posts/java/spring/spring-ioc/</link><pubDate>Sat, 21 Aug 2021 13:49:54 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/spring/spring-ioc/</guid><description>Ioc（Inverse of Control），又叫 DI（Dependence Injection）。它是这样一个过程：对象声明自己的依赖，然后容器在创建 Bean 的时候注入这些依赖。如果不使用 IoC，我们在创建对象之前就需要先把对象的依赖创建出来，这个正向的过程会导致对象与对象之间的强耦合。如果反过来，对象不自己创建依赖，而是由 Spring 的 Ioc 容器自动装配，这就是控制反转。逆向的过程使得程序的结构变得更加灵活，没有强耦合，还有利于对象的复用。
Ioc 容器 在 Spring 中，org.springframework.context.ApplicationContext 接口就是 IoC 容器的抽象表示，它负责 Bean 的实例化、配置以及组装。那么，IoC 容器是如何知道要管理哪些 Bean 呢？答案是配置元数据（Configuration Metadata）。配置元数据可以是 XML、注解，还可以是 Java 代码。
配置元数据 Spring 的 Ioc 容器会读取配置元数据，然后根据配置元数据去实例化、配置和组装应用程序中的 Bean。在 Spring 的早期版本中，配置信息使用的是 XML。Spring 2.5 开始支持基于注解的配置，我们常用的 @Required 和 @Autowired 就是基于注解的配置。 Spring 3.0 开始支持基于 Java 代码的配置。现在，我们甚至可以同时使用 XML 和 注解去配置 Bean。
实际上，在 IoC 容器内部，这些配置元数据会被解析成 BeanDefinition 对象，BeanDefinition 封装的就是 Bean 的定义和描述信息，比如类名、构造器参数、属性值、作用域、生命周期等，容器会根据 BeanDefinition 中封装的信息来创建 Bean。
使用 BeanFactoryPostProcessor 对配置元数据进行个性化配置 在 Spring 中，BeanFactory 提供了一种管理任何类型对象的高级机制，我们经常遇到的 ApplicationContext 则是它的一个子接口。若要用一句话来描述二者的差异，那就是：BeanFactory 提供配置框架和基本功能，ApplicationContext 则是添加了更多的企业级功能。</description></item><item><title>Java 中的引用与对象可达性</title><link>https://zhannicholas.github.io/posts/java/lang/references_and_reachability_in_java/</link><pubDate>Tue, 20 Apr 2021 21:40:00 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/lang/references_and_reachability_in_java/</guid><description>JDK 1.2 之后，Java 将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）四种，这四种引用的强度依次减弱，它们与 Java 的对象回收有着很大的关系。
A reference object encapsulates a reference to some other object so that the reference itself may be examined and manipulated like any other object. Three types of reference objects are provided, each weaker than the last: soft, weak, and phantom. Each type corresponds to a different level of reachability.
这段话已经描述得很清楚了：Java 中有三种引用对象（reference object），它们封装了一些其它的对象，从而让我们可以像操作其它对象一样操作引用本身，不同引用对象的可达性不同。
除开与 Finalization 有关的类，下图展示了 java.lang.ref 包中的类结构：
Reference 对象用于维持对其它对象的引用，但 GC 仍然可以回收这些被引用的其它对象。当 GC 决定回收某个引用对象关联的对象时，它会将对应的引用对象放入与之关联的引用队列（ReferenceQueue）中，这样我们就可以得到对象被回收的通知了。</description></item><item><title>JDBC</title><link>https://zhannicholas.github.io/posts/java/jdbc/jdbc/</link><pubDate>Sun, 18 Apr 2021 23:00:39 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jdbc/jdbc/</guid><description>JDBC（Java DataBase Connectivity）是 Java 程序与关系型数据库交互的统一 API，它由两部分 API 组成：
面向 Java 开发者的 Java API，这一部分 API 独立于各个数据库产品的接口规范，是标准又统一的 Java　API。 面向数据库驱动程序开发者的 API，由数据库厂商实现，用于连接具体的数据库产品。 使用 JDBC 操作数据库的核心步骤 在实际开发 Java 程序时，我们可以通过 JDBC 连接到数据库，完成各种数据库操作。以下就是执行 SELECT 语句时发生的 JDBC 操作：
注册数据库驱动类，给出数据库连接信息（数据库地址、用户名、密码等） 创建 Connection 连接到数据库（调用 DriverManager.getConnection() 方法） 创建 Statement 对象（调用 Connection 的 createStatement() 或 prepareStatement() 方法） 通过 Statement 对象执行 SQL，得到 ResultSet 对象（查询结果集） 从 ResultSet 中读取数据 关闭 ResultSet、Statement 及 Connection 对象 数据库连接池 为什么要使用数据库连接池？数据库连接是整个服务中比较珍贵的资源之一，因为建立数据库连接涉及鉴权、握手等一系列网络操作。使用池化技术缓存数据库连接带来的好处还有很多，例如：
实现连接重用，从而提高系统的响应速度 控制数据库连接数量上限，防止连接过多造成数据库假死 统一连接管理，避免连接泄漏 连接池的连接数量上限一定要根据实际情况仔细选取。如果设置得过大，可能导致数据库因连接过多而假死或崩溃，从而影响服务的可用性。如果设置得过小，则可能无法让数据库达到最佳性能，造成资源浪费。
ORM 框架 ORM 框架的核心功能是：根据配置（一般是配置文件或者 Java 注解）实现对象模型（Java 程序）与关系模型（数据库）之间的映射。</description></item><item><title>Java 代理</title><link>https://zhannicholas.github.io/posts/java/lang/proxy/</link><pubDate>Sun, 13 Dec 2020 18:25:38 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/lang/proxy/</guid><description>Wikipedia 中是这样描述 Proxy 的：
A proxy, in its most general form, is a class functioning as an interface to something else. The proxy could interface to anything: a network connection, a large object in memory, a file, or some other resource that is expensive or impossible to duplicate. In short, a proxy is a wrapper or agent object that is being called by the client to access the real serving object behind the scenes.</description></item><item><title>Java 反射</title><link>https://zhannicholas.github.io/posts/java/lang/reflection/</link><pubDate>Sun, 13 Dec 2020 18:22:56 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/lang/reflection/</guid><description>反射(Reflection) 是Java语言的一大特性，它允许Java程序在运行过程中获取自身的相关信息，还能改变程序的内部属性。我们可以使用反射获取类、接口、字段、方法的属性，也可以用反射来实例化一个对象、进行方法调用、获取或修改字段的值。
以下是Oracle官方对反射的解释：
Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.
获取Class对象 Java中共有两种类型：引用类型和 基本类型。引用类型包括：类、数组(类和数组都继承自 java.lang.Object)和接口。基本类型包括：boolean、byte、short、char、int、long、float、double。 当Java程序运行时，JVM会为每种类型实例化一个不可变的 **java.lang.Class**类，实例的很多数据都来自对应的 **.class文件。java.lang.Class**是反射API的入口，它不仅提供了获取及修改对象内部信息方法，还提供了世袭化对象的途径。有三种方式可以获取到 **Class**实例的引用：直接获取、使用 **Object**类的getClass()方法和使用 **Class**类的静态forName(String className)方法。
直接获取 对于 **A**类，我们可以直接使用 **A.class**来获取它对应的 **Class**对象，这也适用于基本类型。对于包装类，其内部的静态final变量 **TYPE**与对应基本类型的 **Class**对象是同一个。例如：
Class&amp;lt;Object&amp;gt; objectClass = Object.class; System.out.println(int.class == Integer.TYPE); // true System.out.println(int.class == Integer.class); // false System.out.println(void.class == Void.</description></item><item><title>Cloning Objects</title><link>https://zhannicholas.github.io/posts/java/lang/cloning_objects/</link><pubDate>Sun, 13 Dec 2020 18:19:11 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/lang/cloning_objects/</guid><description>通过克隆（Clone），我们可以快速构建出一个已有对象的副本。
浅克隆 VS 深克隆 浅克隆（Shadow Clone） 或 浅复制（Shallow Copy） 把原对象中成员变量为值类型的属性都复制给克隆对象，把原对象中成员变量为引用类型的引用地址也复制给克隆对象。当原对象中存在引用类型的成员变量时，该变量的地址会被原对象和克隆对象共享。
深克隆（Deep Clone） 或 深复制（Deep Copy） 将原对象中的所有类型的成员变量（无论是值类型还是引用类型）都复制一份给克隆对象。
简单来说，浅克隆和深克隆的区别就在于对引用类型的成员变量的复制：前者复制的是引用对象的地址，而后者复制的是引用对象本身。
Cloneable 接口 在 Java 中，为了实现对象的克隆，我们需要让类实现 Cloneable 接口并重写 Object 类的 clone() 方法。例如：
@Data @AllArgsConstructor public class CloneableName implements Cloneable { private String firstName; private String lastName; @Override public CloneableName clone() throws CloneNotSupportedException { return (CloneableName) super.clone(); } } @Data @AllArgsConstructor public class CloneableUser implements Cloneable { private String id; private CloneableName name; private int age; @Override public CloneableUser clone() throws CloneNotSupportedException { return (CloneableUser) super.</description></item><item><title>Nested Classes</title><link>https://zhannicholas.github.io/posts/java/lang/nested_classes/</link><pubDate>Sun, 13 Dec 2020 18:18:04 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/lang/nested_classes/</guid><description>Java允许我们在一个类中定义另一个类，后者被称为嵌套类（nested class）。嵌套类可以分为两种：
静态内部类（static nested class） 内部类（inner class） 其中内部类又可以分为三种：
非静态成员类（non-static member class） 局部内部类（local class） 匿名内部类（anonymous class） 四种嵌套类的定义如下：
class OuterClass { static class NestedClass{} // 静态嵌套类 class MemberClass{} // 非静态成员类 void m1() { class LocalClass{} // 局部内部类 new Thread(new Runnable() { // 匿名内部类 @Override public void run() { // nothing } }); } } 静态内部类 静态内部类指被声明为static的内部类，它可以单独实例化，其它的内部类需要在外部类实例化之后才能实例化。静态内部类不能和外部类同名，不能访问外部类的实例变量，只能访问外部类的类变量和类方法（包括被private修饰的类变量和类方法）。
非静态成员类 非静态成员类不被static修饰。它可以自由的访问外部类的属性和方法，无论这些属性和方法是静态的还是非静态的。但是成员类是和外部类实例相绑定的，因此不可以定义静态变量和静态方法。只有在外部类实例化之后，这个成员类才能被实例化。
局部内部类 局部内部类是指定义在一个代码块内的类，它的作用范围只限于其所在的代码块。局部内部类和局部变量类似，不能被private、public、protected和static关键字修饰，并且只能访问方法中定义为final的局部变量。局部类的其它限制和成员类基本相同。
匿名内部类 匿名内部类没有类名。不能使用关键字class、extends、implements，没有构造函数。一个匿名类一定是在new的后面，并且它必须继承其它类或实现一个接口。成员类的限制也适用于匿名类。</description></item><item><title>What is Servlet</title><link>https://zhannicholas.github.io/posts/java/jakartaee/what_is_servlet/</link><pubDate>Sun, 13 Dec 2020 18:07:45 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jakartaee/what_is_servlet/</guid><description>A servlet is a Java™ technology-based Web component, managed by a container, that generates dynamic content.
和其它基于Java的组件一样，Servlet也由Java类组成，这些Java类(.class文件)会被编译成字节码，字节码随后会被动态地加载到Web服务器中并运行。Servlet通过Servlet容器实现的request/response模型来与Web客户端进行交互。
request/response模型：可以简单的将这个模型看成是一种客户端与服务端通过交换各自的消息来交互的一个过程。像浏览器这样的客户端发出的消息叫做requests，而服务端响应的消息就叫做responses。
什么是Servlet容器 The servlet container is a part of a Web server or application server that provides the network services over which requests and responses are sent, decodes MIME-based requests, and formats MIME-based responses. A servlet container also contains and manages servlets through their lifecycle.
容器(Container)，又称Servlet引擎(Servlet engine)。它可以是Web服务器内置的，也可以是Web服务器中的插件。对于所有的Servlet容器而言，除了必须支持的HTTP协议以外，还可能支持向HTTPS这种的基于request/response模型的协议。容器必须实现的HTTP协议版本包括HTTP/1.1和HTTP/2，当支持HTTP/2时，容器必须支持h2和h2c两种协议标识符，即所有的Servlet容器必须支持ALPN。
此外，Servlet容器还可能会在Servlet的执行环境中加入安全限制。例如，一些应用服务器可能会限制对**Thread**对象的创建，以避免对容器中的其它组件造成负面影响。
一个例子 下面是一个典型的Servlet事件序列：
客户端(比如浏览器)访问Web服务器并发起一个HTTP请求。 Web服务器接收该HTTP请求并将其转交给Servlet容器。 Servlet容器先根据配置信息决定该要调用哪一个Servlet，然后将表示request和response的对象传递给该Servlet并调用它。 Servlet从request对象中获取到远程用户的身份、请求参数和其它相关数据，然后执行处理逻辑，最后生成响应数据(通过response对象)并发回给客户端。 一旦Servlet完成整个请求处理过程，Servlet容器就会刷新响应，然后将控制权归还给Web服务器。 一个简单的Servlet 下面将编写一个非常简单的Servlet，它将展现编写Servlet的所有基本要求。最终该Servlet会在浏览器中输出一些文本：</description></item></channel></rss>