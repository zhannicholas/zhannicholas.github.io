<!doctype html><html lang=zh-cn><head><meta http-equiv=content-type content="text/html" charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon type=image/png sizes=96x96 href=https://zhannicholas.github.io/favicon/favicon-96x96.png><link rel=icon type=image/png sizes=32x32 href=https://zhannicholas.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://zhannicholas.github.io/favicon/favicon-16x16.png><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title itemprop=name>Rust 基础：变量与数据类型 |</title><meta name=description content><meta property="og:title" content="Rust 基础：变量与数据类型 | "><meta name=twitter:title content="Rust 基础：变量与数据类型 | "><meta itemprop=name content="Rust 基础：变量与数据类型 | "><meta name=application-name content="Rust 基础：变量与数据类型 | "><meta property="og:site_name" content><meta property="og:type" content="website"><meta property="og:title" content><meta property="og:description" content><meta property="og:site_name" content><meta property="og:url" content="https://zhannicholas.github.io/posts/rust/rust_basics_variables_and_data_types/"><meta property="og:locale" content="en"><meta property="og:image" content="/"><meta property="og:image:secure_url" content="https://zhannicholas.github.io"><meta property="og:type" content="website"><script>localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=stylesheet href="/css/style.min.70a967cc78af9ec5b1e1b5c3552172a911554a27d8e5bdf52000296bdd439d2a.css" integrity="sha256-cKlnzHivnsWx4bXDVSFyqRFVSifY5b31IAApa91DnSo="></head><body class="bg-zinc-100 dark:bg-gray-800"><div class="top-0 z-50 w-full text-gray-200 bg-gray-900 border-2 border-gray-900 md:sticky border-b-stone-200/10"><div x-data="{ open: false }" class="flex flex-col max-w-full px-4 mx-auto md:items-center md:justify-between md:flex-row md:px-6 lg:px-8"><div class="flex flex-row items-center justify-between p-4"><a href=https://zhannicholas.github.io/ class="flex text-gray-100 transition duration-1000 ease-in-out group"><img src=https://zhannicholas.github.io/images/site-logo.svg class="transition-opacity h-9 w-9 group-hover:opacity-50 group-focus:opacity-70" alt=" Logo"><div class="mt-1 text-xl font-black tracking-tight text-gray-100 uppercase transition-colors group-hover:text-gray-400/60"></div></a><button class="rounded-lg md:hidden focus:outline-none focus:shadow-outline" @click="open = !open" role=navigation aria-expanded=false aria-label=Main aria-controls=menuItems><svg fill="currentcolor" viewBox="0 0 20 20" class="w-6 h-6"><path x-show="!open" fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4A1 1 0 013 5zm0 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm6 5a1 1 0 011-1h6a1 1 0 110 2h-6a1 1 0 01-1-1z" clip-rule="evenodd"/><path x-show="open" fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414.0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/></svg></button></div><nav :class="{'flex': open, 'hidden': !open}" class="flex-col flex-grow hidden pb-4 md:pb-0 md:flex md:justify-end md:flex-row"><div @click.away="open = false" class=relative x-data="{ open: false }"><button @click="open = !open" class="flex flex-row items-center w-full px-4 py-2 mt-2 text-sm font-semibold text-left bg-transparent rounded-lg md:w-auto md:inline md:mt-0 md:ml-4 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-600 focus:outline-none focus:shadow-outline">
<span>The Garden</span><svg fill="currentcolor" viewBox="0 0 20 20" :class="{'rotate-180': open, 'rotate-0': !open}" class="inline w-4 h-4 mt-1 ml-1 transition-transform duration-200 transform md:-mt-1"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414.0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414.0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/></svg></button><div x-show=open x-transition:enter="transition ease-out duration-100" x-transition:enter-start="transform opacity-0 scale-95" x-transition:enter-end="transform opacity-100 scale-100" x-transition:leave="transition ease-in duration-75" x-transition:leave-start="transform opacity-100 scale-100" x-transition:leave-end="transform opacity-0 scale-95" class="absolute right-0 z-30 w-full mt-2 origin-top-right rounded-md shadow-lg md:w-48"><div class="px-2 py-2 text-indigo-900 bg-white rounded-md shadow"><a class="block px-4 py-2 mt-2 text-sm font-semibold bg-transparent rounded-lg md:mt-0 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-600 focus:outline-none focus:shadow-outline" href=https://zhannicholas.github.io/posts>Posts</a>
<a class="block px-4 py-2 mt-2 text-sm font-semibold bg-transparent rounded-lg md:mt-0 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-600 focus:outline-none focus:shadow-outline" href=https://zhannicholas.github.io/pages>Notes</a>
<a class="block px-4 py-2 mt-2 text-sm font-semibold bg-transparent rounded-lg md:mt-0 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-700 focus:outline-none focus:shadow-outline" href=https://zhannicholas.github.io/library>Library</a></div></div></div><a class="px-4 py-2 mt-2 text-sm font-semibold rounded-lg md:mt-0 md:ml-4 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-700 focus:outline-none focus:shadow-outline" href=https://zhannicholas.github.io/now>Now</a>
<a class="px-4 py-2 mt-2 text-sm font-semibold bg-transparent rounded-lg md:mt-0 md:ml-4 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-700 focus:outline-none focus:shadow-outline" href=https://zhannicholas.github.io/about>About</a>
<button id=theme-toggle type=button class="p-2 text-sm text-gray-500 rounded-lg md: dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:focus:ring-gray-700 md:ml-2 max-w-5 xs:hidden"><svg id="theme-toggle-dark-icon" class="hidden w-5 h-5" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001.0 1010.586 10.586z"/></svg><svg id="theme-toggle-light-icon" class="hidden w-5 h-5" fill="currentcolor" viewBox="0 0 20 20" aria-label="Dark or Light Mode" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1A1 1 0 119 4V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707A1 1 0 1113.536 5.05l.707-.707a1 1 0 011.414.0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707A1 1 0 004.343 5.757l.707.707zm1.414 8.486-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"/></svg></button></nav></div></div><div class=content><article><header class="max-w-2xl mx-auto mb-4 bg-indigo-600"><span class=py-96><h1 class="px-6 pt-6 pb-16 mx-auto dark:prose-invert text-5xl font-black text-center text-white capitalize">Rust 基础：变量与数据类型</h1></span></header><div class="max-w-4xl mx-auto mt-8 mb-2"><div class=px-6></div></div><div class="fixed z-20 top-[3.8125rem] bottom-0 right-[max(0px,calc(50%-45rem))] w-[18rem] py-10 overflow-y-auto hidden xl:block"><nav><div class="flex items-center"><h2 class="pl-2 my-0 text-xl font-medium text-zinc-800 uppercase break-words">Table of Contents</h2></div><div class="absolute top-auto bottom-auto right-auto p-0 -left-4" role=menu><div class="relative z-50 max-w-sm m-4 overflow-hidden shadow-lg"><ul class="relative p-4 overflow-x-hidden overflow-y-auto overscroll-y-auto overscroll-x-auto"><li><a class="px-2 text-left text-zinc-700 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%8f%98%e9%87%8f>变量</a><ul><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%8f%98%e9%87%8f%e4%b8%8e%e5%8f%af%e5%8f%98%e6%80%a7>变量与可变性</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%b8%b8%e9%87%8f>常量</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e9%9a%90%e8%97%8f>隐藏</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%86%bb%e7%bb%93freezing>冻结（Freezing）</a></li></ul></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b>数据类型</a><ul><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e6%a0%87%e9%87%8f%e7%b1%bb%e5%9e%8b>标量类型</a><ul><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e6%95%b4%e5%9e%8b>整型</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e6%b5%ae%e7%82%b9%e5%9e%8b>浮点型</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%b8%83%e5%b0%94%e7%b1%bb%e5%9e%8b>布尔类型</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%ad%97%e7%ac%a6%e7%b1%bb%e5%9e%8b>字符类型</a></li></ul></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%a4%8d%e5%90%88%e7%b1%bb%e5%9e%8b>复合类型</a><ul><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%85%83%e7%bb%84>元组</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e6%95%b0%e7%bb%84>数组</a></li></ul></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b>自定义数据类型</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2>类型转换</a><ul><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b%e4%b9%8b%e9%97%b4%e7%9a%84%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2>基本类型之间的类型转换</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e7%b1%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e4%b9%8b%e9%97%b4%e7%9a%84%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2>自定义类型数据之间的类型转换</a></li></ul></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e7%b1%bb%e5%9e%8b%e5%88%ab%e5%90%8d>类型别名</a></li></ul></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99>参考资料</a></li></ul></div></div></nav></div><div class="max-w-2xl px-6 pt-6 pb-16 mx-auto prose dark:prose-invert dark:text-white"><h2 id=变量>变量</h2><h3 id=变量与可变性>变量与可变性</h3><p>在 Rust 中，变量（variables）有两种：</p><ul><li>不可变变量：一经赋值，就不再允许对变量的值进行修改</li><li>可变变量：可可对变量的值进行多次修改</li></ul><p>在 Rust 中，我们使用 <code>let</code> 关键字声明一个变量，例如：<code>let x = 1</code>。默认情况下，<code>let</code> 声明的变量是 <strong>不可变的</strong>。如果代码里面出现不可变变量被多次赋值的情况，则代码是不会编译通过的。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The value of x is: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x);
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The value of x is: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果使用 <code>cargo run</code> 运行这段代码，则会出现以下错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>&gt; cargo run
</span></span><span style=display:flex><span>   Compiling variables v0.1.0 (F:\Code\Rust\rust-study\variables)
</span></span><span style=display:flex><span>error[<span style=color:#66d9ef>E0384</span>]<span style=color:#960050;background-color:#1e0010>:</span> cannot assign twice to immutable variable `x`
</span></span><span style=display:flex><span> --&gt; src\main.rs<span style=color:#960050;background-color:#1e0010>:</span><span style=color:#ae81ff>4</span><span style=color:#960050;background-color:#1e0010>:</span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span> |     let x = <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>  |         -
</span></span><span style=display:flex><span>  |         |
</span></span><span style=display:flex><span>  |         first assignment to `x`
</span></span><span style=display:flex><span>  |         help<span style=color:#960050;background-color:#1e0010>:</span> consider making this binding mutable<span style=color:#960050;background-color:#1e0010>:</span> `mut x`
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span> |     println!(<span style=color:#e6db74>&#34;The value of x is: {}&#34;</span>, x);
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span> |     x = <span style=color:#ae81ff>6</span>;
</span></span><span style=display:flex><span>  |     ^^^^^ cannot assign twice to immutable variable
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error<span style=color:#960050;background-color:#1e0010>:</span> aborting due to previous error
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>For</span> more information about this error, <span style=color:#66d9ef>try</span> `rustc --explain E0384`.
</span></span><span style=display:flex><span>error<span style=color:#960050;background-color:#1e0010>:</span> could not compile `variables`
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>To learn more, run the command again with --verbose.
</span></span></code></pre></div><p>Cargo 给了我们很多有用的错误信息，其中就一行被标成了红色，十分醒目：<code>cannot assign twice to immutable variable</code>。也就是说，不可以再次给不可变变量赋值。</p><p>解决错误的方法很简单，将第二行替换成 <code>let mut x = 5</code> 即可。我们在变量 <code>x</code> 之前加了一个关键字 <code>mut</code>，表明 <code>x</code> 是一个可变变量。再次运行 <code>cargo run</code>，我们就能看到正确的输出了。</p><h3 id=常量>常量</h3><p>和其它编程语言一样，Rust 中也有常量（constants）这个概念。Rust 中的常量在赋值之后就不能修改。有人可能会问，这不就跟不可变变量一样吗？实际上，这只是常量与不可变变量的一个相同点，二者还是有差异的。</p><p>首先，声明常量的关键字是 <code>const</code>，而声明变量的关键字是 <code>let</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>ONE</span>: <span style=color:#66d9ef>u32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span></code></pre></div><p>以上代码声明了一个名为 <code>ONE</code> 的常量，并赋值为 <code>1</code>。常量名约定使用大写字母，多个单词之间用下划线隔开。</p><p>其次，常量的赋值部分只能是一个常量表达式，不能是某个函数调用的结果或运行期间计算出来的值。而变量就没有这个限制。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>SQUARE</span> <span style=color:#f92672>=</span> x <span style=color:#f92672>*</span> x;
</span></span></code></pre></div><p>上面这段代码是无法正常编译的，因为 <code>x</code> 是变量，而 <code>SQUARE</code> 是常量，<code>x * x</code> 的值是在程序运行过程中计算出来的。</p><p>此外，<code>static</code> 关键字也可以用来声明一个常量，使用 <code>static</code> 关键字声明的常量代表的是一个内存地址，它的生命周期为 <code>'static</code>，而 <code>const</code> 声明的常量代表的是一个值。<a href=https://github.com/rust-lang/rfcs/blob/master/text/0246-const-vs-static.md target=_blank>0246-const-vs-static</a>
描述了二者的不同。</p><h3 id=隐藏>隐藏</h3><p>我们可以多次定义一个同名的变量，后面定义的变量会隐藏（shadowing）它之前的同名变量，即程序只能看到最新一个同名变量的值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> x <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;The value of x in the inner scope is: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The value of x is: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上这段代码很有意思，它首先将变量 <code>x</code> 的值绑定为 <code>5</code>，然后通过 <code>let x =</code> 隐藏 <code>5</code> 这个值，真正可见的值是 <code>6</code>。而在内部作用域中，第二个 <code>let</code> 再次隐藏 <code>x</code> 之前的值，真正可见的值是 <code>12</code>。内部作用域结束，作用域内的隐藏效果也结束了，<code>x</code> 的值又变成 <code>6</code>。所以，这个程序的输出结果应该是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>The value of x <span style=color:#66d9ef>in</span> the inner scope is<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>The value of x <span style=color:#66d9ef>in</span> the inner scope is<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#ae81ff>6</span>
</span></span></code></pre></div><p>如果我们去掉第二行开头的 <code>let</code>，程序就因不可变变量被再次赋值而编译失败。不可变变量的隐藏与不可变变量的赋值是完全不同的，我们可以认为隐藏就是重新声明了一个新的变量。</p><p>既然如此，为啥不直接使用可变变量呢？原因是隐藏更加灵活，因为不可变变量的变量类型在声明之后就不能再改了，而隐藏可以修改变量的数据类型。例如，下面的代码是可以编译成功的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1&#34;</span>;
</span></span></code></pre></div><p>而下面这段代码将会编译失败：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1&#34;</span>;
</span></span></code></pre></div><h3 id=冻结freezing>冻结（Freezing）</h3><p>当数据被绑定到不可变的同名变量上时，该数据会被冻结。被冻结的数据只有在超出不可变绑定的作用域之外才能被修改。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> _mutable_integer <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span><span style=color:#66d9ef>i32</span>;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Shadowing by immutable `_mutable_integer`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> _mutable_integer <span style=color:#f92672>=</span> _mutable_integer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Error! `_mutable_integer` is frozen in this scope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        _mutable_integer <span style=color:#f92672>=</span> <span style=color:#ae81ff>50</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// FIXME ^ Comment out this line
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// `_mutable_integer` goes out of scope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Ok! `_mutable_integer` is not frozen in this scope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _mutable_integer <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=数据类型>数据类型</h2><p>Rust 是一门 <strong>静态类型</strong> 语言，在编译期间就必须确定所有变量的类型。Rust 中的每一个变量的值都属于某一数据类型，Rust 通过数据类型得知变量的值是何种数据，进而决定如何处理这个值。</p><p>我们并不需要一一声明变量所属的数据类型，Rust 的编译器是很智能的，它可以根据值及其使用方式推断出我们想要使用的数据类型。但是，当某个值可能属于多种数据类型时，我们就必须通过类型注解显式地给出变量的数据类型，否则编译就会出错。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// 编译器可以推断出 x 的数据类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> guess: <span style=color:#66d9ef>u32</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;42&#34;</span>.parse().expect(<span style=color:#e6db74>&#34;Not a number!&#34;</span>);  <span style=color:#75715e>// &#34;42&#34;.parse() 的结果可能对应多种类型，所以需要使用类型注解
</span></span></span></code></pre></div><p>在 Rust 中，数据类型分为两类：标量类型（scalar types）和复合类型（compound types）</p><h3 id=标量类型>标量类型</h3><p>一个标量类型表示的是单个值。Rust 中有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。</p><h4 id=整型>整型</h4><p>整型（integer）是没有小数部分的数字。根据是否可以表示负数，整型又可以分为有符号整型和无符号整型。下面的表格列出了 Rust 中的所有整型：</p><table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody><tr><td>8-bit</td><td>i8</td><td>u8</td></tr><tr><td>16-bit</td><td>i16</td><td>u16</td></tr><tr><td>32-bit</td><td>i32</td><td>u32</td></tr><tr><td>64-bit</td><td>i64</td><td>u64</td></tr><tr><td>128-bit</td><td>i128</td><td>u128</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr></tbody></table><p>其中，有符号整型以字母 <code>i</code> 开头，无符号整型以字母 <code>u</code> 开头。<code>i</code> 或 <code>u</code> 后面的数字即该类型所占的二进制位数。假设整型的长度为 <code>n</code> 位，则有符号整型能表示数值范围的区间是 $[-2^{n - 1}, 2^{n - 1} - 1]$，而无符号整型能表示数值范围区间是 $[0, 2^n - 1]$。例如，<code>i8</code> 可存储的数值范围是 [0, 255]，而 <code>u8</code> 可存储的数值范围是 [-128, 127]。表格中的 <code>isize</code> 和 <code>usize</code> 类型由运行程序的机器架构决定：对于 64 位架构的计算机来说，它们就是 64 位的，而对于 32 位架构的计算机来说，它们就是 32 位的。Rust 中默认的整型是 <code>i32</code>。</p><p>除了将整数写成最常见的十进制形式外，Rust 还允许我们将数字写成十六进制、八进制等形式。为了便于阅读，我们不仅可以在数值后面跟上它的具体类型（比如 <code>58u8</code> 表示 <code>u8</code> 类型的数字 <code>58</code>），还可以使用下划线（<code>_</code>）对数字进行分隔（比如 <code>10_000</code> 就是数字 <code>10000</code>）。下面表格列出了 Rust 中的各种整数表示法，除了默认的十进制表示法外，各个表示形式都有特定的前缀：</p><table><thead><tr><th>Number Literals</th><th>Example</th></tr></thead><tbody><tr><td>Decimal</td><td>98_222</td></tr><tr><td>Hex</td><td>0xff</td></tr><tr><td>Octal</td><td>0o77</td></tr><tr><td>Binary</td><td>0b1111_0000</td></tr><tr><td>Byte(<code>u8</code> only)</td><td>b&rsquo;A'</td></tr></tbody></table><h4 id=浮点型>浮点型</h4><p>浮点型（floating-point）是带小数点的数字。Rust 有两种原生的浮点类型：单精度浮点型 <code>f32</code>（占 32 位）和双精度浮点型 <code>f64</code>（占 64 位）。<code>f64</code> 是 Rust 中默认的浮点类型。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Rust data-lang=Rust><span style=display:flex><span><span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2.0</span>;  <span style=color:#75715e>// f64
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> y: <span style=color:#66d9ef>f32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.0</span>; <span style=color:#75715e>// f32
</span></span></span></code></pre></div><p>和大多数编程语言一眼，Rust 中的浮点型是使用 IEEE-754 标准表示的。</p><h4 id=布尔类型>布尔类型</h4><p>Rust 中的布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>。布尔类型占一个字节，类型注解为 <code>bool</code>。</p><h4 id=字符类型>字符类型</h4><p>字符类型（<code>char</code>）占 4 个字节，可以表示 <code>U+0000</code> 到 <code>U+D7FF</code> 之间和 <code>U+E000</code> 到 <code>U+10FFF</code> 之间的 Unicode 字符。</p><h3 id=复合类型>复合类型</h3><p>复合类型可以将多个值组合到一个类型中。Rust 内置了元组（tuples）和数组（arrays）这两种复合类型。</p><h4 id=元组>元组</h4><p>元组是一个由多个值组成的集合，每个值的类型可以不同，其长度在指定后就不能修改。创建一个元组的方式很简单，将各个值用逗号分隔，放在小括号当中即可：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> tup: (<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>u8</span>) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>6.4</span>, <span style=color:#ae81ff>1</span>);
</span></span></code></pre></div><p>以上代码创建了一个包含三个不同类型数值的元组 <code>tup</code>。那么如何访问元组中的元素呢？Rust 给我们提供了两种方法，其中一种是使用模式匹配对元组进行解构（destructure）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> tup <span style=color:#f92672>=</span> (<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>6.4</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> (x, y, z) <span style=color:#f92672>=</span> tup;
</span></span><span style=display:flex><span>println!(<span style=color:#e6db74>&#34;The value of y is: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, y);
</span></span></code></pre></div><p>以上代码首先将元组 <code>(500, 6.4, 1)</code> 绑定到了变量 <code>tup</code> 上，然后使用模式 <code>(x, y, z)</code> 将 <code>tup</code> 分成了三个不同的部分，这个过程就是解构（destructring）。除了使用模式匹配解构外，我们还可以通过点号（<code>.</code>）加索引的方式访问元组中的值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> tup <span style=color:#f92672>=</span> (<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>6.4</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> tup.<span style=color:#ae81ff>0</span>;  <span style=color:#75715e>// 500
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> tup.<span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// 6.4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> z <span style=color:#f92672>=</span> tup.<span style=color:#ae81ff>2</span>;  <span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>println!(<span style=color:#e6db74>&#34;x = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, y = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, z = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x, y, z);
</span></span></code></pre></div><p>和大多数编程语言一样，Rust 中的下标也是从 0 开始的。</p><p>元组甚至可以包含元组，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> tuple_of_tuples <span style=color:#f92672>=</span> ((<span style=color:#ae81ff>1</span><span style=color:#66d9ef>u8</span>, <span style=color:#ae81ff>2</span><span style=color:#66d9ef>u16</span>, <span style=color:#ae81ff>2</span><span style=color:#66d9ef>u32</span>), (<span style=color:#ae81ff>4</span><span style=color:#66d9ef>u64</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#66d9ef>i8</span>), <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span><span style=color:#66d9ef>i16</span>);
</span></span></code></pre></div><p>如果元组中只有一个值，那么末尾的那个逗号是不能省略的，否则编译器会认为那是一个字面量。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>println!(<span style=color:#e6db74>&#34;A tuple: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, (<span style=color:#ae81ff>5</span>,)); <span style=color:#75715e>// A tuple: (5,)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>print!(<span style=color:#e6db74>&#34;An integer: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, (<span style=color:#ae81ff>5</span>));  <span style=color:#75715e>// An integer: 5
</span></span></span></code></pre></div><p>不包含任何值的元组（空元组）是一种特殊的数据类型——单元类型（unit type）。这种数据类型只有一个可能的值，即 <code>()</code>，它被称为单元值（unit value）。虽然单元值是一个元组，但是它并不属于复合类型，因为它并不包含多个值。</p><h4 id=数组>数组</h4><p>数组只能包含多个相同类型得值，其长度在指定后也不能修改。创建一个数组的方式也很简单，将各个值用逗号分隔，然后放到中括号当中即可：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> arr <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span></code></pre></div><p>我们可以通过下标访问数组中的元素：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> arr <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> arr[<span style=color:#ae81ff>0</span>]; <span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> arr[<span style=color:#ae81ff>1</span>]; <span style=color:#75715e>// 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> z <span style=color:#f92672>=</span> arr[<span style=color:#ae81ff>2</span>]; <span style=color:#75715e>// 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>println!(<span style=color:#e6db74>&#34;x = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, y = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, z = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x, y, z);
</span></span></code></pre></div><p>我们也可以在声明数组的时候显式给出数组元素的类型和数组长度，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> arr: [<span style=color:#66d9ef>i32</span>; <span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>];
</span></span></code></pre></div><p>以上代码声明了一个长度为 <code>3</code> 的数组 <code>[1, 2, 3]</code>，数组中的元素类型为 <code>i32</code>。</p><p>此外，Rust 还给我们提供了将数组初始化为相同值的简便写法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> arr <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>; <span style=color:#ae81ff>3</span>];
</span></span></code></pre></div><p>以上代码声明了一个长度为 <code>3</code> 的数组，数组中所有元素都是 <code>1</code>。该写法等价于：<code>let arr = [1, 1, 1]</code>。</p><h3 id=自定义数据类型>自定义数据类型</h3><p>Rust 当然支持我们创建自定义的数据类型，创建自定义数据类型的主要途径有两种：</p><ul><li><a href=../rust_basics_enums_and_patterns_matching>使用 &lt;code>enum&lt;/code> 定义枚举类</a></li><li><a href=../rust_basics_struct>使用 &lt;code>struct&lt;/code> 定义结构体</a></li></ul><h3 id=类型转换>类型转换</h3><h4 id=基本类型之间的类型转换>基本类型之间的类型转换</h4><p>Rust 是不允许基本类型的数据之间进行隐式类型转换的。不过，我们可以使用 <code>as</code> 关键字显式要求进行数据转换。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> decimal <span style=color:#f92672>=</span> <span style=color:#ae81ff>6.5</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>// Error! No implicit conversion
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  let integer: u8 = decimal;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> integer <span style=color:#f92672>=</span> decimal <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> character <span style=color:#f92672>=</span> integer <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>char</span>;
</span></span></code></pre></div><p>Rust 管基本类型数据之间的类型转换叫 Casting。</p><h4 id=自定义类型数据之间的类型转换>自定义类型数据之间的类型转换</h4><p>在 Rust 中，自定义类型数据之间的类型转换是通过使用 traits 实现的。一般情况下使用的 traits 是 <a href=https://doc.rust-lang.org/std/convert/trait.From.html target=_blank>&lt;code>From&lt;/code></a>
和 <a href=https://doc.rust-lang.org/std/convert/trait.Into.html target=_blank>&lt;code>Into&lt;/code></a>
。如果转换可能失败，则使用 <a href=https://doc.rust-lang.org/std/convert/trait.TryFrom.html target=_blank>&lt;code>TryFrom&lt;/code></a>
和 <a href=https://doc.rust-lang.org/std/convert/trait.TryInto.html target=_blank>&lt;code>TryInto&lt;/code></a>
会更合适。此外，数据类型和字符串之间的转换使用的 traits 是 <a href=https://doc.rust-lang.org/std/str/trait.FromStr.html target=_blank>&lt;code>FromStr&lt;/code></a>
和 <a href=https://doc.rust-lang.org/std/string/trait.ToString.html target=_blank>&lt;code>ToString&lt;/code></a>
。</p><p>Rust 管自定义类型数据之间的类型转换叫 Conversion。</p><h3 id=类型别名>类型别名</h3><p>Rust 允许我们使用 <code>type</code> 关键字给已存在的数据类型设置新的名字（alias）。如果新的名字不是驼峰命名的，编译器会发出警告，但编译还是会通过。如果不想让编译器发出警告，可以使用 <code>#[allow(non_camel_case_types)]</code> 属性。类型别名并不是新的数据类型，它只是一个别名而已。类型别名主要用于减少样板代码，比如 <code>IoResult&lt;T></code> 就是 <code>Result&lt;T, IoError></code> 的一个别名。下面是使用类型别名的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>ype NanoSecond <span style=color:#f92672>=</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Inch</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[allow(non_camel_case_types)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>u64_t</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>u64</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// NanoSecond, Inch and u64_t are the same type as u64
</span></span></span></code></pre></div><h2 id=参考资料>参考资料</h2><ol><li>Steve Klabnik, Carol Nichols. <a href=https://doc.rust-lang.org/stable/book/ target=_blank>The Rust Programming Language</a>
.</li><li><a href=https://doc.rust-lang.org/stable/rust-by-example target=_blank>Rust by Example</a>
.</li></ol></div><hr><aside><h4>No linked references</h4></aside><br><aside class=related><h3 class="text-2xl font-black tracking-tight text-indigo-500 capitalize dark:text-indigo-300 sm:text-2xl">Related Content</h3><ul><p class="inline-flex items-center rounded-md bg-gray-300 hover:bg-indigo-200 hover:text-black px-2.5 py-0.5 text-sm font-medium text-gray-900 capitalize"><a style=color:var(--link) href=https://zhannicholas.github.io/posts/rust/hello_rust>Hello, Rust!</a></p></ul></aside></article></div><div x-cloak x-data="{ atTop: false }"><button id=scrollToTop name="scroll to top button" aria-label="scroll to top button" class="fixed z-50 w-10 h-10 font-bold text-center text-white transition-all duration-1000 ease-in-out transform bg-violet-600 rounded-full cursor-pointer animate-bounce bottom-24 right-8 focus:outline-none" :class="{ 'opacity-0 translate-y-24': !atTop, 'opacity-1 translate-y-2' :  atTop}" @click="window.scrollTo({ top: 0, behavior: 'smooth'})" @scroll.window="atTop = (window.pageYOffset > 200)"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentcolor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 11l3-3m0 0 3 3m-3-3v8m0-13a9 9 0 110 18 9 9 0 010-18z"/></svg></button></div><script src=https://zhannicholas.github.io/js/alpine.js defer></script>
<script src=https://zhannicholas.github.io/js/darkmode.js defer></script><footer class=bg-gray-900><div class="max-w-md px-4 py-12 mx-auto overflow-hidden sm:max-w-3xl sm:px-6 lg:max-w-7xl lg:px-8"><nav class="flex flex-wrap justify-center -mx-5 -my-2" aria-label=Footer><div class="px-5 py-2"><a href=https://zhannicholas.github.io/about class="text-base text-gray-400 hover:text-gray-300">About</a></div><div class="px-5 py-2"><a href=https://zhannicholas.github.io/posts class="text-base text-gray-400 hover:text-gray-300">Posts</a></div><div class="px-5 py-2"><a href=https://zhannicholas.github.io/notes class="text-base text-gray-400 hover:text-gray-300">Notes</a></div><div class="px-5 py-2"><a href=https://zhannicholas.github.io/library class="text-base text-gray-400 hover:text-gray-300">Library</a></div><div class="px-5 py-2"><a href=https://zhannicholas.github.io/contact/ class="text-base text-gray-400 hover:text-gray-300">Contact</a></div></nav><div class="flex justify-center mt-2 space-x-6"><a href=https://github.com/zhannicholas class="text-gray-400 hover:text-gray-300"><span class=sr-only>GitHub</span><svg class="w-6 h-6" fill="currentcolor" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483.0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951.0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65.0.0.84-.27 2.75 1.026A9.564 9.564.0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688.0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855.0 1.338-.012 2.419-.012 2.747.0.268.18.58.688.482A10.019 10.019.0 0022 12.017C22 6.484 17.522 2 12 2z" clip-rule="evenodd"/></svg></a>
<a href=mailto:zhan_nicholas@outlook.com class="text-gray-400 hover:text-gray-300"><span class=sr-only>Email</span><svg class="w-6 h-6" fill="currentcolor" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M21 7.38246601V5H3V7.38199365l9.0000224 4.50046115L21 7.38246601zm0 2.23606798-9.0000224 4.50001121L3 9.61810635V19H21V9.61853399zM3 3H21c1.1045695.0 2 .8954305 2 2V19c0 1.1045695-.8954305 2-2 2H3c-1.1045695.0-2-.8954305-2-2V5c0-1.1045695.8954305-2 2-2z" clip-rule="evenodd"/></svg></a>
<a href=https://t.me/zhannicholas class="text-gray-400 hover:text-gray-300"><span class=sr-only>Telegram</span><svg class="w-6 h-6" fill="currentcolor" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.78754 14.0196C5.83131 14.0344 5.87549 14.0448 5.91963 14.0512 5.96777 14.1644 6.02996 14.3107 6.10252 14.4818c.17707.4176.41566.9825.66194 1.5717C7.2667 17.2552 7.77332 18.4939 7.88521 18.8485 8.02372 19.2868 8.17013 19.5848 8.32996 19.7883 8.4126 19.8935 8.50819 19.9853 8.62003 20.0549 8.67633 20.0899 8.7358 20.1186 8.79788 20.14 8.80062 20.141 8.80335 20.1419 8.80608 20.1428 9.1261 20.2636 9.41786 20.2133 9.60053 20.1518 9.69827 20.1188 9.77735 20.0791 9.8334 20.0469 9.86198 20.0304 9.88612 20.0151 9.90538 20.0021L9.90992 19.9991l2.82618-1.7625 3.2646 2.5028C16.0488 20.7763 16.1014 20.8073 16.157 20.8316 16.5492 21.0027 16.929 21.0624 17.2862 21.0136 17.6429 20.9649 17.926 20.8151 18.1368 20.6464 18.3432 20.4813 18.4832 20.2963 18.5703 20.1589 18.6148 20.0887 18.6482 20.0266 18.6718 19.9791 18.6836 19.9552 18.6931 19.9346 18.7005 19.9181L18.7099 19.8963 18.7135 19.8877 18.715 19.8841 18.7156 19.8824 18.7163 19.8808C18.7334 19.8379 18.7466 19.7935 18.7556 19.7482L21.7358 4.72274C21.7453 4.67469 21.7501 4.62581 21.7501 4.57682 21.7501 4.13681 21.5843 3.71841 21.1945 3.46452 20.8613 3.24752 20.4901 3.23818 20.2556 3.25598 20.0025 3.27519 19.7688 3.33766 19.612 3.38757 19.5304 3.41355 19.4619 3.43861 19.4126 3.45773 19.3878 3.46734 19.3675 3.47559 19.3523 3.48188L19.341 3.48666 2.62725 10.0432 2.62509 10.044C2.61444 10.0479 2.60076 10.053 2.58451 10.0593 2.55215 10.0719 2.50878 10.0896 2.45813 10.1126 2.35935 10.1574 2.22077 10.2273 2.07856 10.3247c-.22719.1556-.74968.5817-.6617 1.285.07019.5611.45457.9057.68876 1.0714C2.23421 12.7721 2.35638 12.8371 2.44535 12.8795 2.48662 12.8991 2.57232 12.9339 2.6095 12.9491L2.61889 12.9529l3.16865 1.0667zM19.9259 4.86786 19.9236 4.86888C19.9152 4.8725 19.9069 4.87596 19.8984 4.87928L3.1644 11.4438C3.15566 11.4472 3.14686 11.4505 3.138 11.4536L3.12869 11.4571C3.11798 11.4613 3.09996 11.4686 3.07734 11.4788 3.06451 11.4846 3.05112 11.491 3.03747 11.4978 3.05622 11.5084 3.07417 11.5175 3.09012 11.5251 3.10543 11.5324 3.11711 11.5374 3.1235 11.54l3.14263 1.058C6.32365 12.6174 6.37727 12.643 6.42649 12.674L16.8033 6.59948 16.813 6.59374C16.8205 6.58927 16.8305 6.58353 16.8424 6.5768 16.866 6.56345 16.8984 6.54568 16.937 6.52603 17.009 6.48938 17.1243 6.43497 17.2541 6.39485 17.3444 6.36692 17.6109 6.28823 17.899 6.38064 18.0768 6.43767 18.2609 6.56028 18.3807 6.76798 18.4401 6.87117 18.4718 6.97483 18.4872 7.06972 18.528 7.2192 18.5215 7.36681 18.4896 7.49424 18.4208 7.76875 18.228 7.98287 18.0525 8.14665 17.9021 8.28706 15.9567 10.1629 14.0376 12.0147 13.0805 12.9381 12.1333 13.8525 11.4252 14.5359l-.465.449 5.8719 4.5018C16.9668 19.5349 17.0464 19.5325 17.0832 19.5274 17.1271 19.5214 17.163 19.5045 17.1997 19.4752 17.2407 19.4424 17.2766 19.398 17.3034 19.3557L17.3045 19.354 20.195 4.78102C20.1521 4.79133 20.1087 4.80361 20.0669 4.81691 20.0196 4.83198 19.9805 4.84634 19.9547 4.85637 19.9418 4.86134 19.9326 4.86511 19.9276 4.86719L19.9259 4.86786zM11.4646 17.2618 10.2931 16.3636 10.0093 18.1693 11.4646 17.2618zM9.21846 14.5814l1.16494-1.1247c.7081-.6835 1.6555-1.5979 2.6127-2.5215l.9725-.9382-6.52007 3.8168L7.48351 13.8963c.1777.4191.41736.9864.664940000000001 1.5788.185129999999999.4429.37872.9093.55504 1.3411l.28304-1.8004C9.01381 14.8422 9.09861 14.692 9.21846 14.5814z" clip-rule="evenodd"/></svg></a></div><p class="mt-2 text-base text-center text-gray-400">2018-2023 &copy; Nicholas Zhan. Licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/>CC BY-NC 4.0</a>.</p></div></footer></body></html>