<!doctype html><html lang=zh-cn><head><meta http-equiv=content-type content="text/html" charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon type=image/png sizes=96x96 href=https://zhannicholas.github.io/favicon/favicon-96x96.png><link rel=icon type=image/png sizes=32x32 href=https://zhannicholas.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://zhannicholas.github.io/favicon/favicon-16x16.png><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title itemprop=name>Rust 基础：所有权 |</title><meta name=description content><meta property="og:title" content="Rust 基础：所有权 | "><meta name=twitter:title content="Rust 基础：所有权 | "><meta itemprop=name content="Rust 基础：所有权 | "><meta name=application-name content="Rust 基础：所有权 | "><meta property="og:site_name" content><meta property="og:type" content="website"><meta property="og:title" content><meta property="og:description" content><meta property="og:site_name" content><meta property="og:url" content="https://zhannicholas.github.io/posts/rust/rust_basics_ownership/"><meta property="og:locale" content="en"><meta property="og:image" content="/"><meta property="og:image:secure_url" content="https://zhannicholas.github.io"><meta property="og:type" content="website"><script>localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")</script><link rel=preconnect href=https://fonts.googleapis.com><link rel=stylesheet href="/css/style.min.70a967cc78af9ec5b1e1b5c3552172a911554a27d8e5bdf52000296bdd439d2a.css" integrity="sha256-cKlnzHivnsWx4bXDVSFyqRFVSifY5b31IAApa91DnSo="></head><body class="bg-zinc-100 dark:bg-gray-800"><div class="top-0 z-50 w-full text-gray-200 bg-gray-900 border-2 border-gray-900 md:sticky border-b-stone-200/10"><div x-data="{ open: false }" class="flex flex-col max-w-full px-4 mx-auto md:items-center md:justify-between md:flex-row md:px-6 lg:px-8"><div class="flex flex-row items-center justify-between p-4"><a href=https://zhannicholas.github.io/ class="flex text-gray-100 transition duration-1000 ease-in-out group"><img src=https://zhannicholas.github.io/images/site-logo.svg class="transition-opacity h-9 w-9 group-hover:opacity-50 group-focus:opacity-70" alt=" Logo"><div class="mt-1 text-xl font-black tracking-tight text-gray-100 uppercase transition-colors group-hover:text-gray-400/60"></div></a><button class="rounded-lg md:hidden focus:outline-none focus:shadow-outline" @click="open = !open" role=navigation aria-expanded=false aria-label=Main aria-controls=menuItems><svg fill="currentcolor" viewBox="0 0 20 20" class="w-6 h-6"><path x-show="!open" fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4A1 1 0 013 5zm0 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm6 5a1 1 0 011-1h6a1 1 0 110 2h-6a1 1 0 01-1-1z" clip-rule="evenodd"/><path x-show="open" fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414.0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/></svg></button></div><nav :class="{'flex': open, 'hidden': !open}" class="flex-col flex-grow hidden pb-4 md:pb-0 md:flex md:justify-end md:flex-row"><div @click.away="open = false" class=relative x-data="{ open: false }"><button @click="open = !open" class="flex flex-row items-center w-full px-4 py-2 mt-2 text-sm font-semibold text-left bg-transparent rounded-lg md:w-auto md:inline md:mt-0 md:ml-4 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-600 focus:outline-none focus:shadow-outline">
<span>The Garden</span><svg fill="currentcolor" viewBox="0 0 20 20" :class="{'rotate-180': open, 'rotate-0': !open}" class="inline w-4 h-4 mt-1 ml-1 transition-transform duration-200 transform md:-mt-1"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414.0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414.0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/></svg></button><div x-show=open x-transition:enter="transition ease-out duration-100" x-transition:enter-start="transform opacity-0 scale-95" x-transition:enter-end="transform opacity-100 scale-100" x-transition:leave="transition ease-in duration-75" x-transition:leave-start="transform opacity-100 scale-100" x-transition:leave-end="transform opacity-0 scale-95" class="absolute right-0 z-30 w-full mt-2 origin-top-right rounded-md shadow-lg md:w-48"><div class="px-2 py-2 text-indigo-900 bg-white rounded-md shadow"><a class="block px-4 py-2 mt-2 text-sm font-semibold bg-transparent rounded-lg md:mt-0 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-600 focus:outline-none focus:shadow-outline" href=https://zhannicholas.github.io/posts>Posts</a>
<a class="block px-4 py-2 mt-2 text-sm font-semibold bg-transparent rounded-lg md:mt-0 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-600 focus:outline-none focus:shadow-outline" href=https://zhannicholas.github.io/pages>Notes</a>
<a class="block px-4 py-2 mt-2 text-sm font-semibold bg-transparent rounded-lg md:mt-0 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-700 focus:outline-none focus:shadow-outline" href=https://zhannicholas.github.io/library>Library</a></div></div></div><a class="px-4 py-2 mt-2 text-sm font-semibold rounded-lg md:mt-0 md:ml-4 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-700 focus:outline-none focus:shadow-outline" href=https://zhannicholas.github.io/now>Now</a>
<a class="px-4 py-2 mt-2 text-sm font-semibold bg-transparent rounded-lg md:mt-0 md:ml-4 hover:text-white focus:text-white hover:bg-indigo-600 focus:bg-indigo-700 focus:outline-none focus:shadow-outline" href=https://zhannicholas.github.io/about>About</a>
<button id=theme-toggle type=button class="p-2 text-sm text-gray-500 rounded-lg md: dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:focus:ring-gray-700 md:ml-2 max-w-5 xs:hidden"><svg id="theme-toggle-dark-icon" class="hidden w-5 h-5" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001.0 1010.586 10.586z"/></svg><svg id="theme-toggle-light-icon" class="hidden w-5 h-5" fill="currentcolor" viewBox="0 0 20 20" aria-label="Dark or Light Mode" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1A1 1 0 119 4V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707A1 1 0 1113.536 5.05l.707-.707a1 1 0 011.414.0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707A1 1 0 004.343 5.757l.707.707zm1.414 8.486-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"/></svg></button></nav></div></div><div class=content><article><header class="max-w-2xl mx-auto mb-4 bg-indigo-600"><span class=py-96><h1 class="px-6 pt-6 pb-16 mx-auto dark:prose-invert text-5xl font-black text-center text-white capitalize">Rust 基础：所有权</h1></span></header><div class="max-w-4xl mx-auto mt-8 mb-2"><div class=px-6></div></div><div class="fixed z-20 top-[3.8125rem] bottom-0 right-[max(0px,calc(50%-45rem))] w-[18rem] py-10 overflow-y-auto hidden xl:block"><nav><div class="flex items-center"><h2 class="pl-2 my-0 text-xl font-medium text-zinc-800 uppercase break-words">Table of Contents</h2></div><div class="absolute top-auto bottom-auto right-auto p-0 -left-4" role=menu><div class="relative z-50 max-w-sm m-4 overflow-hidden shadow-lg"><ul class="relative p-4 overflow-x-hidden overflow-y-auto overscroll-y-auto overscroll-x-auto"><li><a class="px-2 text-left text-zinc-700 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e6%a0%88%e4%b8%8e%e5%a0%86>栈与堆</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e6%89%80%e6%9c%89%e6%9d%83%e8%a7%84%e5%88%99>所有权规则</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%8f%98%e9%87%8f%e4%b8%8e%e6%95%b0%e6%8d%ae%e7%9a%84%e4%ba%a4%e4%ba%92%e6%96%b9%e5%bc%8f>变量与数据的交互方式</a><ul><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e7%a7%bb%e5%8a%a8move>移动（Move）</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%85%8b%e9%9a%86clone>克隆（Clone）</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e6%a0%88%e4%b8%8a%e6%95%b0%e6%8d%ae%e7%9a%84%e5%a4%8d%e5%88%b6copy>栈上数据的复制（Copy）</a></li></ul></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e6%89%80%e6%9c%89%e6%9d%83%e4%b8%8e%e5%87%bd%e6%95%b0>所有权与函数</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%bc%95%e7%94%a8>引用</a><ul><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%8f%af%e5%8f%98%e5%bc%95%e7%94%a8>可变引用</a></li></ul></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%88%87%e7%89%87slice>切片（Slice）</a><ul><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%88%87%e7%89%87>字符串切片</a></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%85%b6%e5%ae%83%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%88%87%e7%89%87>其它类型的切片</a></li></ul></li><li><a class="px-2 text-left text-zinc-900 rounded-md focus:outline-none hover:bg-lightBlue-600 hover:text-white" x-data href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99>参考资料</a></li></ul></div></div></nav></div><div class="max-w-2xl px-6 pt-6 pb-16 mx-auto prose dark:prose-invert dark:text-white"><p><strong>所有权（ownership）</strong> 是 Rust 独一无二的功能，也是 Rust 中的核心功能之一。Rust 不需要开发者手动回收内存，也没有垃圾收集器，但它还能保证内存安全，这就是所有权的强大之处。</p><p>在 Rust 中，内存的管理是通过所有权系统（ownership system）进行的，编译器会在编译时根据一系列的规则进行检查。更加令人赞叹的是，所有权系统中的任何功能都不会减慢程序的运行速度！</p><h2 id=栈与堆>栈与堆</h2><p>在开始学习所有权这个概念之前，我们有必要先回顾一下数据在内存中的存放形式。在 Rust 中，数据被存放在栈（stack）或堆（heap）中。</p><p>栈与堆组织数据的方式不同。在栈中，数据时先入后出（FILO）的，即最后存入的数据最先被使用。而在堆中，数据的使用就没有顺序要求，数据在堆中的组织情况比栈中要差很多。此外，存放在栈中的数据占用的空间必须是 <strong>编译期间已知且固定的</strong>，对于那些大小不固定或编译时无法知道大小的数据，应当被存放在堆上。在我们往堆中存数据时，内存分配器会从堆中找出一块大小合适的内存空间，标记其已使用，然后返回给我们一个指向分配地址的指针，后续我们就可以使用这个指针访问堆中的数据。这个指针会被存储在栈上，因为它的大小是固定且已知的。</p><p>将数据存储在栈上的速度要快于存储在堆上的速度。因为当数据被放在栈上时，内存分配器不需要为新数据找出一块空闲空间，数据总是被放在栈顶。如果数据要被放到堆上，内存分配器不仅需要从堆中找出一块合适的空闲空间，还需要防止这块空间被其它数据抢占。类似地，访问栈上数据的速度要快于访问堆上数据的速度。因为堆上的数据需要通过栈上的指针才能定位到，这比栈上的数据多了一次内存访问。</p><p>当我们调用一个函数时，传递给函数的值（或指向堆中数据的指针）和函数中的局部变量都是存放在栈上的。当函数调用结束后，这些值都会从栈中弹出。</p><p>讲了这么多，现在该所有权出场了。所有权负责 <strong>跟踪哪部分代码正在使用堆中的哪部分数据，最大限度地减少堆中的重复数据，清理堆中未使用的数据，防止内存空间被耗尽</strong>。简单来说，所有权管理着堆中的数据。</p><p>那么，Rust 中的哪些数据会被分配在堆上呢？答案是那些大小在编译期间不可知或者大小不固定的数据，比如字符串类型（<code>String</code>）。标量类型（整型、浮点型、布尔类型和字符类型）或复合类型（元组和数组）的数据都是存放在栈上的，作用域结束时就会被从栈上弹出。</p><p>需要注意的是：字符串类型（<code>String</code>）和字符串字面量（string literal）是不同的。字符串字面量（比如 <code>let s = "hello, world";</code>）是代码中硬编码的（编译时大小已知）、不可变的，而字符串类型的数据被存储在堆上，字符串类型的数据是可变的。我们可以使用 <code>String</code> 的 <code>from</code> 函数从字符串字面量创建一个 <code>String</code> 类型的变量，比如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>    s.push_str(<span style=color:#e6db74>&#34;, world!&#34;</span>); <span style=color:#75715e>// push_str() appends a literal to a String
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, s); <span style=color:#75715e>// This will print `hello, world!`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=所有权规则>所有权规则</h2><p>所有权的规则如下，它们不可被违反：</p><ul><li>Rust 中的每个值都有一个变量，这个变量就是这个值的 <strong>所有者（owner）</strong></li><li>每个值在同一时刻有且只有一个所有者</li><li>当所有者（变量）超出作用域（scope），值就会被丢弃（drop），值占据的内存被归还</li></ul><p>变量在进入作用域后开始生效，此后，变量在超出作用域之前一直都是有效的。举个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    { <span style=color:#75715e>// s is not valid here, it’s not yet declared
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;hello&#34;</span>;   <span style=color:#75715e>// s is valid from this point forward
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// do stuff with s
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }  <span style=color:#75715e>// this scope is now over, and s is no longer valid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>实际上，当变量超出作用域时，Rust 会自动为我们调用一个叫 <code>drop</code> 的特殊函数进行内存的归还。在上面这个例子中，<code>drop</code> 会在第一个 <code>}</code> 处被调用。</p><h2 id=变量与数据的交互方式>变量与数据的交互方式</h2><p>在 Rust 中，多个变量可以以不同的方式与同一份数据进行交互，最常见的交互方式有移动（move）和克隆（clone）。</p><h3 id=移动move>移动（Move）</h3><p>先来看一段简单的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;x = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, y = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>.&#34;</span>, x, y);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这段代码很简单，也能通过编译，最终运行会打印出结果 <code>x = 5, y = 5.</code>。如果将 <code>let x = 5;</code> 修改为 <code>let x = "5";</code>，仍然能得到一样的运行结果。但是，如果我将 <code>let x = 5;</code> 修改成 <code>let x = String::from("5");</code>，编译都过不去了😂。我并没有改动代码的结构，唯一改变的只有变量 <code>x</code> 的类型，这里面到底发生了什么？🤔</p><p>要回答这个问题，我们需要了解 Rust 中 <code>String</code> 在内存中的存储形式。为了能够使用官方的图，让我将代码修改为官方的代码😁：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> s1;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;s1 = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, s2 = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, s1, s2);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 Rust 中，<code>String</code> 由三部分组成：指向字符串实际内容的指针、长度和容量。它们存放在栈上，对应下图中的左侧部分，字符串的实际内容则存放在堆上，对应下图中的右侧部分：</p><p><img src=https://zhannicholas.github.io/images/rust/trpl04-01.svg alt></p><p>当变量 <code>s1</code> 被赋值给 <code>s2</code> 后，字符串 <code>s1</code> 在栈上的数据被复制了一份给 <code>s2</code> 用，而堆上的内容没有被复制：</p><p><img src=https://zhannicholas.github.io/images/rust/trpl04-02.svg alt></p><p>这个过程似曾相识，它就像 Java 中的浅拷贝（shallow copy）一样。在，Rust 中，实际的过程不完全是这样，因为当 <code>s1</code> 和 <code>s2</code> 都超出作用域时，显然不应该归还两次内存。Rust 为了保证内存安全，并没有进行复制操作，而是在在执行 <code>let s2 = s1;</code> 之后使 <code>s1</code> 失效。这样，当 <code>s1</code> 超出作用域时，Rust 就不需要因为它释放任何内存了。让 <code>s1</code> 失效的操作在 Rust 中被称为 <strong>移动（move）</strong>，<code>let s2 = s1;</code> 的实际作用是让 <code>s1</code> 移动到 <code>s2</code>。所以，正确的图是下面这样的：</p><p><img src=https://zhannicholas.github.io/images/rust/trpl04-04.svg alt></p><p>这就是上面代码编译失败的原因，这下应该能看懂编译器给出的信息了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>&gt; cargo run
</span></span><span style=display:flex><span>   Compiling ownership v0.1.0 (F:\Code\Rust\rust-study\ownership)
</span></span><span style=display:flex><span>warning<span style=color:#960050;background-color:#1e0010>:</span> unused variable<span style=color:#960050;background-color:#1e0010>:</span> `s2`
</span></span><span style=display:flex><span> --&gt; src\main.rs<span style=color:#960050;background-color:#1e0010>:</span><span style=color:#ae81ff>3</span><span style=color:#960050;background-color:#1e0010>:</span><span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span> |     let s2 = s1;
</span></span><span style=display:flex><span>  |         ^^ help<span style=color:#960050;background-color:#1e0010>:</span> <span style=color:#66d9ef>if</span> this is intentional, prefix it with an underscore<span style=color:#960050;background-color:#1e0010>:</span> `_s2`
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span>  = note<span style=color:#960050;background-color:#1e0010>:</span> `<span style=color:#75715e>#[warn(unused_variables)]` on by default</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error[<span style=color:#66d9ef>E0382</span>]<span style=color:#960050;background-color:#1e0010>:</span> borrow of moved value<span style=color:#960050;background-color:#1e0010>:</span> `s1`
</span></span><span style=display:flex><span> --&gt; src\main.rs<span style=color:#960050;background-color:#1e0010>:</span><span style=color:#ae81ff>4</span><span style=color:#960050;background-color:#1e0010>:</span><span style=color:#ae81ff>28</span>
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span> |     let s1 = String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
</span></span><span style=display:flex><span>  |              -- value moved here
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span> |     println!(<span style=color:#e6db74>&#34;{}, world!&#34;</span>, s1);
</span></span><span style=display:flex><span>  |                            ^^ value borrowed here after move
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error<span style=color:#960050;background-color:#1e0010>:</span> aborting due to previous error; <span style=color:#ae81ff>1</span> warning emitted
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>For</span> more information about this error, <span style=color:#66d9ef>try</span> `rustc --explain E0382`.
</span></span><span style=display:flex><span>error<span style=color:#960050;background-color:#1e0010>:</span> could not compile `ownership`
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>To learn more, run the command again with --verbose.
</span></span><span style=display:flex><span>F:\Code\Rust\rust-study\ownership [master <span style=color:#ae81ff>+4</span> ~<span style=color:#ae81ff>0</span> <span style=color:#ae81ff>-0</span> !]&gt; cargo run
</span></span><span style=display:flex><span>   Compiling ownership v0.1.0 (F:\Code\Rust\rust-study\ownership)
</span></span><span style=display:flex><span>error[<span style=color:#66d9ef>E0382</span>]<span style=color:#960050;background-color:#1e0010>:</span> borrow of moved value<span style=color:#960050;background-color:#1e0010>:</span> `s1`
</span></span><span style=display:flex><span> --&gt; src\main.rs<span style=color:#960050;background-color:#1e0010>:</span><span style=color:#ae81ff>4</span><span style=color:#960050;background-color:#1e0010>:</span><span style=color:#ae81ff>34</span>
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span> |     let s1 = String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span> |     let s2 = s1;
</span></span><span style=display:flex><span>  |              -- value moved here
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span> |     println!(<span style=color:#e6db74>&#34;s1 = {}, s2 = {}&#34;</span>, s1, s2);
</span></span><span style=display:flex><span>  |                                  ^^ value borrowed here after move
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error<span style=color:#960050;background-color:#1e0010>:</span> aborting due to previous error
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>For</span> more information about this error, <span style=color:#66d9ef>try</span> `rustc --explain E0382`.
</span></span><span style=display:flex><span>error<span style=color:#960050;background-color:#1e0010>:</span> could not compile `ownership`
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>To learn more, run the command again with --verbose.
</span></span></code></pre></div><h3 id=克隆clone>克隆（Clone）</h3><p>Rust 不会自动进行数据的深拷贝（deep copy），因为深拷贝会对程序的性能造成很大的影响。如果我们希望 Rust 进行数据的深拷贝，需要使用 <code>clone</code> 方法。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> s1.clone();
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;s1 = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, s2 = </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, s1, s2);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样一来，<code>s1</code> 和 <code>s2</code> 涉及的数据就是下图中展示的这样了：</p><p><img src=https://zhannicholas.github.io/images/rust/trpl04-03.svg alt></p><h3 id=栈上数据的复制copy>栈上数据的复制（Copy）</h3><p>现在来思考为啥 <code>let x = 5;</code> 或 <code>let x = "5";</code>时代码能够正常运行。这是因为 <code>5</code> 和 <code>"5"</code> 的大小都是固定的，程序编译时就可以知道它们的大小，所以数据被分配在了栈上。而 <strong>Rust 对栈上数据的复制采取的是深拷贝</strong>，深拷贝就不存在移动了。</p><p>还记得编译错误“move occurs because <code>s1</code> has type <code>String</code>, which does not implement the <code>Copy</code> trait”吗？Rust 中有一个特殊的注解叫做 <strong><code>Copy</code></strong>。如果某种数据类型实现了 <code>Copy</code>，旧变量在赋值之后仍然是可以使用的。此外，Rust 中还有一个特殊的注解叫做 <strong><code>Drop</code></strong>，它会在变量超出作用域后做些事情。Rust 不允许我们将 <code>Copy</code> 放在了实现了<code>Drop</code> 的类型上，如果我们这么做，编译会失败。</p><p>那么，哪些类型实现了 <code>Copy</code> 呢？说实话，有点多，具体的内容可以查看 <a href=https://doc.rust-lang.org/std/marker/trait.Copy.html# target=_blank>Trait Copy</a>
。你会发现，所有的标量类型都实现了 <code>Copy</code>。</p><h2 id=所有权与函数>所有权与函数</h2><p>传递变量给函数时所有权的变化与变量赋值一样。根据数据类型的不同，可能发生移动（丢失所有权）或复制，下面例子中的注释解释得非常清楚：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);  <span style=color:#75715e>// s comes into scope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    takes_ownership(s);             <span style=color:#75715e>// s&#39;s value moves into the function...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                    <span style=color:#75715e>// ... and so is no longer valid here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;                      <span style=color:#75715e>// x comes into scope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    makes_copy(x);                  <span style=color:#75715e>// x would move into the function,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                    <span style=color:#75715e>// but i32 is Copy, so it&#39;s okay to still
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                    <span style=color:#75715e>// use x afterward
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>} <span style=color:#75715e>// Here, x goes out of scope, then s. But because s&#39;s value was moved, nothing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// special happens.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>takes_ownership</span>(some_string: String) { <span style=color:#75715e>// some_string comes into scope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, some_string);
</span></span><span style=display:flex><span>} <span style=color:#75715e>// Here, some_string goes out of scope and `drop` is called. The backing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// memory is freed.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>makes_copy</span>(some_integer: <span style=color:#66d9ef>i32</span>) { <span style=color:#75715e>// some_integer comes into scope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, some_integer);
</span></span><span style=display:flex><span>} <span style=color:#75715e>// Here, some_integer goes out of scope. Nothing special happens.
</span></span></span></code></pre></div><p>如果函数带返回值呢？这个时候所有权也会发生转移：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> gives_ownership();         <span style=color:#75715e>// gives_ownership moves its return value into s1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s2 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);     <span style=color:#75715e>// s2 comes into scope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s3 <span style=color:#f92672>=</span> takes_and_gives_back(s2);  <span style=color:#75715e>// s2 is moved into takes_and_gives_back, which also
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                        <span style=color:#75715e>// moves its return value into s3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} <span style=color:#75715e>// Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// moved, so nothing happens. s1 goes out of scope and is dropped.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>gives_ownership</span>() -&gt; String {             <span style=color:#75715e>// gives_ownership will move its
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                             <span style=color:#75715e>// return value into the function that calls it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> some_string <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>); <span style=color:#75715e>// some_string comes into scope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    some_string                              <span style=color:#75715e>// some_string is returned and moves out to the calling function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// takes_and_gives_back will take a String and return one
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>takes_and_gives_back</span>(a_string: String) -&gt; String { <span style=color:#75715e>// a_string comes into scope
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    a_string  <span style=color:#75715e>// a_string is returned and moves out to the calling function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=引用>引用</h2><p>如果每次都进行 <code>takes_and_gives_back</code> 这种夺取所有权而后又归还所有权的操作，未免也太过繁琐。幸运的是，Rust 为我们提供了 <strong>引用（reference）</strong>，它可以消除 <code>takes_and_gives_bakc</code> 的尴尬之处。</p><p>下面是使用引用的一个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s1 <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> len <span style=color:#f92672>=</span> calculate_length(<span style=color:#f92672>&amp;</span>s1);
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The length of &#39;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#39; is </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>.&#34;</span>, s1, len);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>calculate_length</span>(s: <span style=color:#66d9ef>&amp;</span>String) -&gt; <span style=color:#66d9ef>usize</span> {  <span style=color:#75715e>// s is a reference to a String
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    s.len()
</span></span><span style=display:flex><span>} <span style=color:#75715e>// Here, s goes out of scope. But because it does not have ownership of what it refers to, nothing happens.
</span></span></span></code></pre></div><p>引用允许我们引用某个变量，而不会夺取变量对数据的所有权。引用相关的操作符是 <code>&</code>，与之相反的操作叫解引用（dereferencing），操作符是 <code>*</code>。在以上代码中，<code>&amp;s1</code> 创建了一个指向 <code>s1</code> 的引用，<code>s1</code> 依然持有字符串 <code>"hello"</code> 的所有权。</p><p><img src=https://zhannicholas.github.io/images/rust/trpl04-05.svg alt></p><p>由于 <code>&amp;s1</code> 不具有数据的所有权，所以当 <code>&amp;s1</code> 超出作用域时，数据不会被丢弃。Rust 将引用作为函数参数的操作称为 <strong>借用（borrowing）</strong>，这有点像现实生活中别人借了我们的东西又归还一样，所有权不会转移。</p><p>默认情况下，Rust 是不允许我们修改借用的数据的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>    change(<span style=color:#f92672>&amp;</span>s);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>change</span>(some_string: <span style=color:#66d9ef>&amp;</span>String) {
</span></span><span style=display:flex><span>    some_string.push_str(<span style=color:#e6db74>&#34;, world&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上代码会编译失败，并且编译器会告诉我们错误原因，并给出正确的修改建议：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>&gt; cargo run
</span></span><span style=display:flex><span>   Compiling ownership v0.1.0 (F:\Code\Rust\rust-study\ownership)
</span></span><span style=display:flex><span>error[<span style=color:#66d9ef>E0596</span>]<span style=color:#960050;background-color:#1e0010>:</span> cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
</span></span><span style=display:flex><span> --&gt; src\main.rs<span style=color:#960050;background-color:#1e0010>:</span><span style=color:#ae81ff>7</span><span style=color:#960050;background-color:#1e0010>:</span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span> | fn change(some_string<span style=color:#960050;background-color:#1e0010>:</span> &amp;String) {
</span></span><span style=display:flex><span>  |                        ------- help<span style=color:#960050;background-color:#1e0010>:</span> consider changing this to be a mutable reference<span style=color:#960050;background-color:#1e0010>:</span> `&amp;mut String`
</span></span><span style=display:flex><span><span style=color:#ae81ff>7</span> |     some_string.push_str(<span style=color:#e6db74>&#34;, world&#34;</span>);
</span></span><span style=display:flex><span>  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error<span style=color:#960050;background-color:#1e0010>:</span> aborting due to previous error
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>For</span> more information about this error, <span style=color:#66d9ef>try</span> `rustc --explain E0596`.
</span></span><span style=display:flex><span>error<span style=color:#960050;background-color:#1e0010>:</span> could not compile `ownership`
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>To learn more, run the command again with --verbose.
</span></span></code></pre></div><h3 id=可变引用>可变引用</h3><p>在上面的错误中，编译器建议我们将 <code>change</code> 函数的参数由 <code>&amp;String</code> 修改为 <code>&amp;mut String</code>，即从不可变引用（immutable reference）修改为可变引用（mutable reference）。这操作和普通变量的可变与不可变类似。正确的代码应该是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>    change(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> s);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>change</span>(some_string: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> String) {
</span></span><span style=display:flex><span>    some_string.push_str(<span style=color:#e6db74>&#34;, world&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里进行了三处修改：首先将 <code>s</code> 改为可变的 <code>mut s</code>，然后是传递给 <code>change</code> 的参数修改为 <code>&amp;mut s</code>，最后是 <code>change</code> 函数的定义修改为 <code>&amp;mut String</code>，三者缺一不可。</p><p>但是，可变引用有一个非常大的限制：<strong>同一时刻，同一数据的可变引用只能有一个，而不可变引用却可以有多个</strong>。例如，下面的代码会编译失败：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> r1 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> s;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> r2 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> s;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, r1, r2);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译器简单明了地指出了我的错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>&gt; cargo run
</span></span><span style=display:flex><span>   Compiling ownership v0.1.0 (F:\Code\Rust\rust-study\ownership)
</span></span><span style=display:flex><span>error[<span style=color:#66d9ef>E0499</span>]<span style=color:#960050;background-color:#1e0010>:</span> cannot borrow `s` as mutable more than once at a time
</span></span><span style=display:flex><span> --&gt; src\main.rs<span style=color:#960050;background-color:#1e0010>:</span><span style=color:#ae81ff>4</span><span style=color:#960050;background-color:#1e0010>:</span><span style=color:#ae81ff>14</span>
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span> |     let r1 = &amp;mut s;
</span></span><span style=display:flex><span>  |              ------ first mutable borrow occurs here
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span> |     let r2 = &amp;mut s;
</span></span><span style=display:flex><span>  |              ^^^^^^ second mutable borrow occurs here
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span> |     println!(<span style=color:#e6db74>&#34;{}, {}&#34;</span>, r1, r2);
</span></span><span style=display:flex><span>  |                        -- first borrow later used here
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error<span style=color:#960050;background-color:#1e0010>:</span> aborting due to previous error
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>For</span> more information about this error, <span style=color:#66d9ef>try</span> `rustc --explain E0499`.
</span></span><span style=display:flex><span>error<span style=color:#960050;background-color:#1e0010>:</span> could not compile `ownership`
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>To learn more, run the command again with --verbose.
</span></span></code></pre></div><p>Rust 这么做的原因是为了防止编译期间的数据竞争（和 Java 并发中的数据竞争类似）。数据竞争会导致程序的行为超出预期，加大运行时诊断问题的难度。</p><p>那么应该如何修改上面有问题的代码呢？拆分两个变量的作用域即可：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> r1 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> s;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> r2 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> s;
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, r1, r2);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>在 Rust 中，引用的作用域从声明开始，结束于引用最后一次被使用</strong>。Rust 不允许同一份数据在一个作用域内同时出现可变引用和不可变引用的情况。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> r1 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s; <span style=color:#75715e>// no problem
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> r2 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s; <span style=color:#75715e>// no problem
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> r3 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> s; <span style=color:#75715e>// BIG PROBLEM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, and </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, r1, r2, r3);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>会出现以下编译错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>&gt; cargo run
</span></span><span style=display:flex><span>   Compiling ownership v0.1.0 (F:\Code\Rust\rust-study\ownership)
</span></span><span style=display:flex><span>error[<span style=color:#66d9ef>E0502</span>]<span style=color:#960050;background-color:#1e0010>:</span> cannot borrow `s` as mutable because it is also borrowed as immutable
</span></span><span style=display:flex><span> --&gt; src\main.rs<span style=color:#960050;background-color:#1e0010>:</span><span style=color:#ae81ff>5</span><span style=color:#960050;background-color:#1e0010>:</span><span style=color:#ae81ff>14</span>
</span></span><span style=display:flex><span>  |
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span> |     let r1 = &amp;s; // no problem
</span></span><span style=display:flex><span>  |              -- immutable borrow occurs here
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span> |     let r2 = &amp;s; // no problem
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span> |     let r3 = &amp;mut s; // BIG PROBLEM
</span></span><span style=display:flex><span>  |              ^^^^^^ mutable borrow occurs here
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span> |     println!(<span style=color:#e6db74>&#34;{}, {}, and {}&#34;</span>, r1, r2, r3);
</span></span><span style=display:flex><span>  |                                -- immutable borrow later used here
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error<span style=color:#960050;background-color:#1e0010>:</span> aborting due to previous error
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>For</span> more information about this error, <span style=color:#66d9ef>try</span> `rustc --explain E0502`.
</span></span><span style=display:flex><span>error<span style=color:#960050;background-color:#1e0010>:</span> could not compile `ownership`
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>To learn more, run the command again with --verbose.
</span></span></code></pre></div><p>但如果我将代码修改为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> r1 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s; <span style=color:#75715e>// no problem
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> r2 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s; <span style=color:#75715e>// no problem
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74> and </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, r1, r2);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// variables r1 and r2 will not be used after this point
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> r3 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> s; <span style=color:#75715e>// no problem
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, r3);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>程序就能通过编译并正常运行。这是因为，<code>r3</code> 被声明之前，<code>r1</code> 和 <code>r2</code> 的作用域已经结束了，不存在作用域的重叠。</p><h2 id=切片slice>切片（Slice）</h2><p>切片（slice）允许我们引用集合中的一段连续元素，它是一种没有所有权的数据类型。</p><h3 id=字符串切片>字符串切片</h3><p>字符串切片（string slice）是一个指向 <code>String</code> 中的一部分内容的引用，这部分内容是原字符串的一个子串。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> s <span style=color:#f92672>=</span> String::from(<span style=color:#e6db74>&#34;hello world&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> hello <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span><span style=color:#ae81ff>5</span>];   <span style=color:#75715e>// hello
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> world <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>6</span><span style=color:#f92672>..</span><span style=color:#ae81ff>11</span>];  <span style=color:#75715e>// world
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, hello, world); <span style=color:#75715e>// hello, world
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>在上面这段代码中，<code>hello</code> 和 <code>world</code> 都只引用了 <code>s</code> 中的一部分：</p><p><img src=https://zhannicholas.github.io/images/rust/trpl04-06.svg alt></p><p>字符串切片类型在 Rust 中用 <code>&amp;str</code> 表示，它比 <code>String</code> 更加灵活。因为 <code>&amp;str</code> 不仅可以引用 <code>String</code> 的一部分，还能引用 <code>String</code> 的所有内容。利用 <code>&amp;str</code>，我们可以编写获取字符串中第一个单词的函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>first_word</span>(s: <span style=color:#66d9ef>&amp;</span>String) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> bytes <span style=color:#f92672>=</span> s.as_bytes();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i, <span style=color:#f92672>&amp;</span>item) <span style=color:#66d9ef>in</span> bytes.iter().enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> item <span style=color:#f92672>==</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39; &#39;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>i];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;</span>s[<span style=color:#f92672>..</span>]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在可以来回答为啥字符串字面量是不可变的这个问题了。因为字符串字面量的数据类型是 <code>&amp;str</code>，而 <code>&amp;str</code> 是不可变引用。</p><h3 id=其它类型的切片>其它类型的切片</h3><p>除了字符串切片（<code>&amp;str</code>），Rust 中还有很多其它类型的切片，比如数组的切片：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#![allow(unused)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> slice <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>a[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span><span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>assert_eq!(slice, <span style=color:#f92672>&amp;</span>[<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>]);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在以上代码中，<code>slice</code> 是数组 <code>a</code> 的切片，它的数据类型是 <code>&[int32]</code>。</p><h2 id=参考资料>参考资料</h2><ol><li>Steve Klabnik, Carol Nichols. <a href=https://doc.rust-lang.org/stable/book/ target=_blank>The Rust Programming Language</a>
.</li></ol></div><hr><aside><h4>No linked references</h4></aside><br><aside class=related><h3 class="text-2xl font-black tracking-tight text-indigo-500 capitalize dark:text-indigo-300 sm:text-2xl">Related Content</h3><ul><p class="inline-flex items-center rounded-md bg-gray-300 hover:bg-indigo-200 hover:text-black px-2.5 py-0.5 text-sm font-medium text-gray-900 capitalize"><a style=color:var(--link) href=https://zhannicholas.github.io/posts/rust/rust_basics_control_flow>Rust 基础：控制流</a></p><p class="inline-flex items-center rounded-md bg-gray-300 hover:bg-indigo-200 hover:text-black px-2.5 py-0.5 text-sm font-medium text-gray-900 capitalize"><a style=color:var(--link) href=https://zhannicholas.github.io/posts/rust/rust_basics_functions>Rust 基础：函数</a></p><p class="inline-flex items-center rounded-md bg-gray-300 hover:bg-indigo-200 hover:text-black px-2.5 py-0.5 text-sm font-medium text-gray-900 capitalize"><a style=color:var(--link) href=https://zhannicholas.github.io/posts/rust/rust_basics_variables_and_data_types>Rust 基础：变量与数据类型</a></p></ul></aside></article></div><div x-cloak x-data="{ atTop: false }"><button id=scrollToTop name="scroll to top button" aria-label="scroll to top button" class="fixed z-50 w-10 h-10 font-bold text-center text-white transition-all duration-1000 ease-in-out transform bg-violet-600 rounded-full cursor-pointer animate-bounce bottom-24 right-8 focus:outline-none" :class="{ 'opacity-0 translate-y-24': !atTop, 'opacity-1 translate-y-2' :  atTop}" @click="window.scrollTo({ top: 0, behavior: 'smooth'})" @scroll.window="atTop = (window.pageYOffset > 200)"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentcolor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 11l3-3m0 0 3 3m-3-3v8m0-13a9 9 0 110 18 9 9 0 010-18z"/></svg></button></div><script src=https://zhannicholas.github.io/js/alpine.js defer></script>
<script src=https://zhannicholas.github.io/js/darkmode.js defer></script><footer class=bg-gray-900><div class="max-w-md px-4 py-12 mx-auto overflow-hidden sm:max-w-3xl sm:px-6 lg:max-w-7xl lg:px-8"><nav class="flex flex-wrap justify-center -mx-5 -my-2" aria-label=Footer><div class="px-5 py-2"><a href=https://zhannicholas.github.io/about class="text-base text-gray-400 hover:text-gray-300">About</a></div><div class="px-5 py-2"><a href=https://zhannicholas.github.io/posts class="text-base text-gray-400 hover:text-gray-300">Posts</a></div><div class="px-5 py-2"><a href=https://zhannicholas.github.io/notes class="text-base text-gray-400 hover:text-gray-300">Notes</a></div><div class="px-5 py-2"><a href=https://zhannicholas.github.io/library class="text-base text-gray-400 hover:text-gray-300">Library</a></div><div class="px-5 py-2"><a href=https://zhannicholas.github.io/contact/ class="text-base text-gray-400 hover:text-gray-300">Contact</a></div></nav><div class="flex justify-center mt-2 space-x-6"><a href=https://github.com/zhannicholas class="text-gray-400 hover:text-gray-300"><span class=sr-only>GitHub</span><svg class="w-6 h-6" fill="currentcolor" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483.0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951.0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65.0.0.84-.27 2.75 1.026A9.564 9.564.0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688.0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855.0 1.338-.012 2.419-.012 2.747.0.268.18.58.688.482A10.019 10.019.0 0022 12.017C22 6.484 17.522 2 12 2z" clip-rule="evenodd"/></svg></a>
<a href=mailto:zhan_nicholas@outlook.com class="text-gray-400 hover:text-gray-300"><span class=sr-only>Email</span><svg class="w-6 h-6" fill="currentcolor" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M21 7.38246601V5H3V7.38199365l9.0000224 4.50046115L21 7.38246601zm0 2.23606798-9.0000224 4.50001121L3 9.61810635V19H21V9.61853399zM3 3H21c1.1045695.0 2 .8954305 2 2V19c0 1.1045695-.8954305 2-2 2H3c-1.1045695.0-2-.8954305-2-2V5c0-1.1045695.8954305-2 2-2z" clip-rule="evenodd"/></svg></a>
<a href=https://t.me/zhannicholas class="text-gray-400 hover:text-gray-300"><span class=sr-only>Telegram</span><svg class="w-6 h-6" fill="currentcolor" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.78754 14.0196C5.83131 14.0344 5.87549 14.0448 5.91963 14.0512 5.96777 14.1644 6.02996 14.3107 6.10252 14.4818c.17707.4176.41566.9825.66194 1.5717C7.2667 17.2552 7.77332 18.4939 7.88521 18.8485 8.02372 19.2868 8.17013 19.5848 8.32996 19.7883 8.4126 19.8935 8.50819 19.9853 8.62003 20.0549 8.67633 20.0899 8.7358 20.1186 8.79788 20.14 8.80062 20.141 8.80335 20.1419 8.80608 20.1428 9.1261 20.2636 9.41786 20.2133 9.60053 20.1518 9.69827 20.1188 9.77735 20.0791 9.8334 20.0469 9.86198 20.0304 9.88612 20.0151 9.90538 20.0021L9.90992 19.9991l2.82618-1.7625 3.2646 2.5028C16.0488 20.7763 16.1014 20.8073 16.157 20.8316 16.5492 21.0027 16.929 21.0624 17.2862 21.0136 17.6429 20.9649 17.926 20.8151 18.1368 20.6464 18.3432 20.4813 18.4832 20.2963 18.5703 20.1589 18.6148 20.0887 18.6482 20.0266 18.6718 19.9791 18.6836 19.9552 18.6931 19.9346 18.7005 19.9181L18.7099 19.8963 18.7135 19.8877 18.715 19.8841 18.7156 19.8824 18.7163 19.8808C18.7334 19.8379 18.7466 19.7935 18.7556 19.7482L21.7358 4.72274C21.7453 4.67469 21.7501 4.62581 21.7501 4.57682 21.7501 4.13681 21.5843 3.71841 21.1945 3.46452 20.8613 3.24752 20.4901 3.23818 20.2556 3.25598 20.0025 3.27519 19.7688 3.33766 19.612 3.38757 19.5304 3.41355 19.4619 3.43861 19.4126 3.45773 19.3878 3.46734 19.3675 3.47559 19.3523 3.48188L19.341 3.48666 2.62725 10.0432 2.62509 10.044C2.61444 10.0479 2.60076 10.053 2.58451 10.0593 2.55215 10.0719 2.50878 10.0896 2.45813 10.1126 2.35935 10.1574 2.22077 10.2273 2.07856 10.3247c-.22719.1556-.74968.5817-.6617 1.285.07019.5611.45457.9057.68876 1.0714C2.23421 12.7721 2.35638 12.8371 2.44535 12.8795 2.48662 12.8991 2.57232 12.9339 2.6095 12.9491L2.61889 12.9529l3.16865 1.0667zM19.9259 4.86786 19.9236 4.86888C19.9152 4.8725 19.9069 4.87596 19.8984 4.87928L3.1644 11.4438C3.15566 11.4472 3.14686 11.4505 3.138 11.4536L3.12869 11.4571C3.11798 11.4613 3.09996 11.4686 3.07734 11.4788 3.06451 11.4846 3.05112 11.491 3.03747 11.4978 3.05622 11.5084 3.07417 11.5175 3.09012 11.5251 3.10543 11.5324 3.11711 11.5374 3.1235 11.54l3.14263 1.058C6.32365 12.6174 6.37727 12.643 6.42649 12.674L16.8033 6.59948 16.813 6.59374C16.8205 6.58927 16.8305 6.58353 16.8424 6.5768 16.866 6.56345 16.8984 6.54568 16.937 6.52603 17.009 6.48938 17.1243 6.43497 17.2541 6.39485 17.3444 6.36692 17.6109 6.28823 17.899 6.38064 18.0768 6.43767 18.2609 6.56028 18.3807 6.76798 18.4401 6.87117 18.4718 6.97483 18.4872 7.06972 18.528 7.2192 18.5215 7.36681 18.4896 7.49424 18.4208 7.76875 18.228 7.98287 18.0525 8.14665 17.9021 8.28706 15.9567 10.1629 14.0376 12.0147 13.0805 12.9381 12.1333 13.8525 11.4252 14.5359l-.465.449 5.8719 4.5018C16.9668 19.5349 17.0464 19.5325 17.0832 19.5274 17.1271 19.5214 17.163 19.5045 17.1997 19.4752 17.2407 19.4424 17.2766 19.398 17.3034 19.3557L17.3045 19.354 20.195 4.78102C20.1521 4.79133 20.1087 4.80361 20.0669 4.81691 20.0196 4.83198 19.9805 4.84634 19.9547 4.85637 19.9418 4.86134 19.9326 4.86511 19.9276 4.86719L19.9259 4.86786zM11.4646 17.2618 10.2931 16.3636 10.0093 18.1693 11.4646 17.2618zM9.21846 14.5814l1.16494-1.1247c.7081-.6835 1.6555-1.5979 2.6127-2.5215l.9725-.9382-6.52007 3.8168L7.48351 13.8963c.1777.4191.41736.9864.664940000000001 1.5788.185129999999999.4429.37872.9093.55504 1.3411l.28304-1.8004C9.01381 14.8422 9.09861 14.692 9.21846 14.5814z" clip-rule="evenodd"/></svg></a></div><p class="mt-2 text-base text-center text-gray-400">2018-2023 &copy; Nicholas Zhan. Licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc/4.0/>CC BY-NC 4.0</a>.</p></div></footer></body></html>