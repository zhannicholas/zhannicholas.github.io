<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 's Digital Garden</title><link>https://zhannicholas.github.io/posts/</link><description>Recent content in Posts on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 02 Dec 2022 20:45:02 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>百度地图 Geohash 可视化</title><link>https://zhannicholas.github.io/posts/geography/baidumap_geohash_visualizer/</link><pubDate>Fri, 02 Dec 2022 20:45:02 +0800</pubDate><guid>https://zhannicholas.github.io/posts/geography/baidumap_geohash_visualizer/</guid><description>最近在百度地图上做基于位置的推荐服务，需要用到 geohash 和相关的可视化工具。由于不同地图厂商采用的坐标系不同，同一个位置在不同地图上的坐标会出现差异，算出来的 geohash 也会不同。我在网上并没有找到可直接用于百度地图的 geohash 可视化工具，所以就自己造了一个小玩具：baidumap-geohash-explorer 。
百度地图 geohash 可视化工具 自己造的百度地图 geohash 可视化工具主要参考了 https://www.movable-type.co.uk/scripts/geohash.html 的设计和网页代码，主要功能有：
根据输入的经度、纬度和 geohash 长度，自动计算出 geohash 根据输入的 geohash，自动计算出对应的经度、纬度和 geohash 长度 自动在百度地图上标注出 geohash 所表示的区域 支持对相邻 8 个区域进行标注，方便观察 geohash 的变化规律 单击拾取坐标 整个项目的代码也非常简单，一个网页就搞定了，源码详见 Github 。克隆代码后，替换 AK，双击浏览器打开即可使用。
其它 Geohash 可视化工具 https://geohash.softeng.co/: 仅支持 OpenStreetMap。它很好地展示了 geohash 每多一位，就会将原来的格子划分为 32 个更小的格子的特点。 https://chrishewett.com/blog/geohash-explorer/：仅支持 OpenStreetMap，能够根据缩放情况自动选择合适级别的 geohash 进行展示。 https://www.movable-type.co.uk/scripts/geohash.html：仅支持 Google Maps。不仅可以根据经度、纬度和期望的 geohash 长度自动算出对应的 geohash 值并展示，还能根据 geohash 解析出其对应的经度、纬度。 https://ryan-miao.gitee.io/geohash_tool/：仅支持高德地图，鼠标点击时会自动绘制 geohash 格子。还支持显示相邻的 8 个区域。 https://bhargavchippada.github.io/mapviz/：支持 Google Maps 和 MapBox，可以同时接收多个 geohash，并将它们显示在地图上。</description></item><item><title>理解 Geohash</title><link>https://zhannicholas.github.io/posts/geography/understanding_geohash/</link><pubDate>Sun, 27 Nov 2022 20:21:07 +0800</pubDate><guid>https://zhannicholas.github.io/posts/geography/understanding_geohash/</guid><description>Geohash 是 Gustavo Niemeyer 在 2008 年发明的一个地理编码系统（geocode system），它将经度和纬度这个二维的地理坐标编码成一个由数字和字母组成的字符串。虽然 geohash 是从经纬度计算出来的，但是 geohash 并不能像经纬度那样能够表示出某个点在地图上的确切位置。实际上，Geohash 表示的是一个区域，这个区域内所有的点都有着相同的 geohash 值。这意味着，geohash 可以帮助用户隐藏确切的位置信息，从而更好地保护用户的隐私。虽然我们可以通过 geohash 得知用户所在的区域，但是我们却无法知道用户到底在这个区域中的哪个点。
很多基于位置的个性化服务都是基于 geohash 实现的。比如查找附近的人，寻找附近的餐厅等等。以查找附近的人为例，如果两个人所处位置的 geohash 相同，那么我们可以认为这两个人在空间上是相近的。至于具体有多近，这取决于 geohash 所表示的位置精度。通过改变 geohash 的长度，我们可以表示任意精度的位置：geohash 越短，其表示的区域越大，位置精度越低；相反，geohash 越长，其表示的区域越小，位置精度越高。
以天府广场（latitude: 30.6599157, longitude: 104.0638546）为例，下图展示了通过不断增加 geohash 长度提高展示位置精度的过程： 当 geohash 长度为 1 时，选择 w 当 geohash 长度为 2 时，选择 wm 当 geohash 长度为 3 时，选择 wm6 当 geohash 长度为 4 时，选择 wm6n 当 geohash 长度为 5 时，选择 wm6nj 当 geohash 长度为 6 时，选择 wm6nj2 需要注意的是，同一个地点在不同地图下的经纬度可能是不一样的。本文采用的是 OpenStreeMap 。</description></item><item><title>Shell 脚本：I/O 重定向</title><link>https://zhannicholas.github.io/posts/linux/shell_scripting_io_redirection/</link><pubDate>Wed, 27 Oct 2021 22:26:55 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/shell_scripting_io_redirection/</guid><description>文件输入和输出是通过整数句柄（integer handle）实现的——每个打开的文件都会被赋予一个数字，这个数字就是文件描述符（file descriptor）。
最常见的文件描述符是标准输入（stdin）、标准输出（stdout）和标准错误（stderr），它们的文件描述符数字分别是 0、1、2。这些数字和相应的设备都是系统保留的，我们可以通过命令 ls -l /dev/std* 查看。
~$ ls -l /dev/std* lrwxrwxrwx 1 root root 15 Oct 16 18:47 /dev/stderr -&amp;gt; /proc/self/fd/2 lrwxrwxrwx 1 root root 15 Oct 16 18:47 /dev/stdin -&amp;gt; /proc/self/fd/0 lrwxrwxrwx 1 root root 15 Oct 16 18:47 /dev/stdout -&amp;gt; /proc/self/fd/1 每个进程看到的 /proc/self 目录下的东西都不一样，因为 /proc/self 实际上是一个指向 /proc/&amp;lt;process_ID&amp;gt; 的符号链接。
输出重定向 COMMAND_OUTPUT &amp;gt;：重定向输出到一个文件。如果文件不存在，则创建并写入，否则覆盖原文件 : &amp;gt; filename：删除（truncate）文件的内容，如果文件不存在，则创建它。: 是一个占位符，代表无。 &amp;gt; filename：和 : &amp;gt; filename 类似，但是在某些 shell 下工作不正常 COMMAND_OUTPUT &amp;gt;&amp;gt;：重定向输出到一个文件，已追加的方式写入 1&amp;gt;filename：重定向标准输出到文件，以覆盖的方式写入 1&amp;gt;&amp;gt;filename：重定向标准输出到文件，以追加的方式写入 2&amp;gt;filename：重定向标准错误到文件，以覆盖的方式写入 2&amp;gt;&amp;gt;filename：重定向标准错误到文件，以追加的方式写入 &amp;amp;&amp;gt;filename：重定向标准输出和标准错误到文件 M&amp;gt;N：重定向文件描述符 M（如果未给出，则默认为 1）对应的文件到文件 N 。注意：M 是一个文件描述符，N 是一个文件。 M&amp;gt;&amp;amp;N：定向文件描述符 M（如果未给出，则默认为 1）对应的文件到文件描述符 N 对应的文件。注意：这里 M 和 N 都是文件描述符 2&amp;gt;&amp;amp;1：重定向标准错误到标准输出 i&amp;gt;&amp;amp;j：重定向文件描述符 i 到 j &amp;gt;&amp;amp;j：重定向标准输出到文件描述符 j 输入重定向 0&amp;lt; filename：从文件获取输入 [j]&amp;lt;&amp;gt;filename：打开文件 filename 进行读写，若该文件不存在则创建它。如果文件描述符 j 未声明，则默认为 0 关闭文件描述符 n&amp;lt;&amp;amp;-：关闭输入文件描述符 n 0&amp;lt;&amp;amp;- 和 &amp;lt;&amp;amp;-：关闭标准输入 n&amp;gt;&amp;amp;-：关闭输出文件描述符 n 1&amp;gt;&amp;amp;- 和 &amp;gt;&amp;amp;-：关闭标准输出 Here documents here document 是一个有着特殊用途的代码块，它告诉 shell 从当前位置读取输入，直到遇到结束字符串。然后，读取到的内容会被用作命令的标准输入。语法如下：</description></item><item><title>Shell 脚本：正则表达式</title><link>https://zhannicholas.github.io/posts/linux/shell_scripting_regular_expressions/</link><pubDate>Wed, 27 Oct 2021 21:10:27 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/shell_scripting_regular_expressions/</guid><description>正则表达式（regular expression, RE）在 Shell 中的应用非常广泛，我们常用的 find、grep、sed、awk 等命令都涉及到正则表达式……
在 Shell 中，表达式就是一个字符串。字符串由字符组成，其中有些字符除了字面含义之外还有特殊含义，这些具有特殊含义的字符就是元字符（metacharacter）。
正则表达式主要用于搜索文本和操作字符串，它包含以下内容：
字符集（character set）。字符集内所有的字符都只具有字面含义，不包括元字符 锚点（anchor）。锚点标识着正则表达式要匹配的文本中的位置，比如 ^ 和 $ 修饰符（modifier）。修饰符的作用是扩展或者缩小正则表达式要匹配的文本的范围，包括星号（*）、方括号（[）和反斜杠（/） 标准正则表达式中的特殊字符 *：匹配前一个字符出现任意次数，包括 0 次 .：匹配除换行符（\n）之外的任何单字符 ^：匹配字符串的开始位置 $：匹配字符串的结束位置 [...]：封装正则表达式中用到的一组字符 \：对特殊字符进行转义，转移后的特殊字符只具备字面含义 \&amp;lt;...\&amp;gt;：标记单词边界 扩展正则表达式中的特殊字符 扩展正则表达式给标准正则表达式中加入了新的元字符，主要用在 egrep、awk 和 Perl 中。
?：匹配前一个字符出现零次或一次 +：匹配前面的子表达式出现一次或多次 \{\}：限定前面的子表达式出现的次数 ()：封装一组正则表达式 |：从一组选择中选择一个，即或的含义 Globbing Bash 本身并不能识别正则表达式，解释正则表达式的是一些像 sed 和 awk 这样的命令和工具。Shell 展开中有一种类型叫文件名展开（filename expansion），但展开的事情并不是 Bash 自己完成的，而是由一个叫做 globbing 的进程完成的。但是 globbing 本身并不能使用标准的正则表达式，它只能识别一些特殊字符（比如 *、?、[]）。这些特殊字符一般称为通配符（wildcards），也叫 globbing 或 pattern matching。需要注意的是：* 并不会匹配以 . 开头的文件名。
参考资料 Bash Guide for Beginners . Advanced Bash-Scripting Guide .</description></item><item><title>Shell 脚本：shell 展开</title><link>https://zhannicholas.github.io/posts/linux/shell_scripting_shell_expansion/</link><pubDate>Sat, 23 Oct 2021 17:15:13 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/shell_scripting_shell_expansion/</guid><description>Bash 和其它 shell 做的工作远不止执行命令那么简单。以下提到的各种展开（expansion）操作发生在 Bash 执行命令之前。准确来说，是在重定向之前，重定向操作完成之后才会真正执行命令。
若命令中存在重定向操作，则 Shell 会在执行命令之前进行处理。管道（|）就是一个很好的例子，Shell 会透明地将上一条命令的 stdout 重定向到下一条命令的 stdin。而与这个重定向操作有关的两条命令根本不知道自己在和谁通信。
在 shell 将读取的命令分割成符号（token）之后，这些符号（或单词）会被展开或解析。Shell 会按照顺序执行八种类型的展开：
Brace expansion Tilde expansion Shell parameter and variable expansion Command substitution Arithmetic expansion Process substitution Word splitting File name expansion 大括号展开 大括号展开的形式为：一个可选的前导符（PREAMBLE）、一组位于一对大括号之间的由逗号分隔的字符串和一个可选的跋（POSTSCRIPT）。例如：
~$ echo sp{el,il,al}l spell spill spall 波浪号展开 如果一个单词以没有被引起来的波浪号（~）开始，则在第一个没有被引起来的斜杠（若没有斜杠，则一直到最后一个字符）之前的字符将被视作波浪号前缀（tidle-prefix）。如果波浪号前缀中没有字符被引起来，那么波浪号前缀中的这些字符就会被当作一个可能的登录用户名。如果这个登录用户名是 null 字符串，则波浪号被替换为 shell 变量 HOME。如果 HOME 变量没有被设置，则替换为执行这个 shell 的用户的主目录。 如果波浪号前缀是”~+“，那么它会被替换为变量 PWD 的值。如果波浪号前缀是”~-“，那么它会被替换为变量 OLDPWD 的值。
参数或变量展开 美元符号（$）用于参数展开、命令替换或算术展开。被展开的参数名或符号可能被包裹在大括号中。 最基本的参数展开的形式是${PARAMETER}。如果我们想在某个变量不存在时创建这个变量，则可以使用${VAR:=value}。
命令替换 命令替换（command substitution）允许我们用命令的输出来替换命令本身，它有两种形式：
$(command) `command` 其中前者工作得更好，是用来取代后者的。</description></item><item><title>Shell 脚本：条件分支与循环</title><link>https://zhannicholas.github.io/posts/linux/shell_scripting_conditional_statements_and_loops/</link><pubDate>Thu, 21 Oct 2021 23:05:45 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/shell_scripting_conditional_statements_and_loops/</guid><description>和其它编程语言类似，bash 也给我们提供了条件语句（conditional statements）。
条件分支 if 在 shell 中，if/then 的语法为：if TEST-COMMANDS; then CONSEQUENT-CONMMANDS; fi。
TEST-COMMANDS 列表执行后，如果它的返回状态是 0，就执行 CONSEQUENT-COMMANDS 列表，其中最后一条命令的退出状态就是整个 if 表达式的返回状态。
在 UNIX/Linux 中，通常用 0 表示成功，非零表示失败。
if/then/else If/then/else 的语法为：if TEST-COMMANDS; then CONSEQUENT-CONMMANDS; else ALTERNATE-CONSEQUENT-COMMANDS; fi
if/then/elif/else if 表达式的完整的语法为：if TEST-COMMANDS; then CONSEQUENT-CONMMANDS; elif MORE-TEST-COMMANDS; then MORE-CONSEQUENT-COMMANDS; else ALTERNATE-CONSEQUENT-COMMANDS; fi
test test 是一个 bash 内置的命令，用于检查文件的类型和进行值的比较。特殊字符 [ 是 test 的同义词。
[] 与 [[]] 的区别在于：[[]]（extended test command）比 [] 更强，它会阻止 shell 进行变量名的分词操作、阻止路径名展开。[ 和 [[ 的类型也不同：
~$ type [ [ is a shell builtin ~$ type [[ [[ is a shell keyword 还有更加有趣的：</description></item><item><title>Shell 脚本：变量</title><link>https://zhannicholas.github.io/posts/linux/shell_scripting_variables/</link><pubDate>Wed, 20 Oct 2021 21:26:46 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/shell_scripting_variables/</guid><description>Shell 脚本用变量（variable）来表示数据，变量仅仅只是一个标签（label），它实际上是一个引用（reference）或指针（pointer），指向着与变量相关联的实际数据所存放的内存地址。 变量的名字就是变量的值的占位符（placehoder），变量的值（value）持有着数据。引用（reference）或检索（retrive）变量的值的操作被称为变量替换（variable substitution）。
变量的名字和值是完全不同的，如果 variable1 是一个变量的名字，那么 $variable1（$variable1 是 ${variable1} 的简单形式）就是对该变量值的引用。$ 符号在这里的作用就是进行变量替换。
按照作用域的不同，变量分为全局变量（global variables）和局部变量（local variables）
全局变量也就是我们通常说的环境变量（environment variables），对所有的 shell 都有效。查看环境变量的命令：env 或 printenv。 局部变量只对当前的 shell 有效。使用 shell 内置的 set 命令（不带任何选项参数）就可以输出所有变量（包括环境变量）和一系列的函数。 创建变量 变量名是大小写敏感的，一般用大写命名全局变量，用小写命名局部变量。变量名可以包含数字，但是不能以数字开头。定义变量的语法为：VARNAME=value。
$ variable1=123 $ echo variable1 variable1 $ echo $variable1 123 $ echo ${variable1} 123 我们经常使用 echo 命令输出某个变量的值。你可能会认为 echo 会计算出变量 variable1 的值，然后将值输出。但事实可不是这样，echo 并不知道变量的值是多少！echo 只负责打印我们传递给它的内容，也就是说，我们传什么给它，它就打印什么。而 shell 会在运行 echo 之前计算出 $variable1 的值，并将结果传给 echo。若 variable1=123，则当我们运行 echo $variable1 时，实际执行的命令是 echo 123。
与我们常用的编程语言不同，shell 中变量定义中的 等号两侧是不能有空格的，否则会出错。这与 shell 对命令的解释有关，例如：</description></item><item><title>Shell 脚本</title><link>https://zhannicholas.github.io/posts/linux/shell_scripting_introduction/</link><pubDate>Wed, 20 Oct 2021 20:45:55 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/shell_scripting_introduction/</guid><description>接下来将会有一系列与 Shell 脚本相关的笔记文章。在之前的工作中，作为一个 Java Boy，我几乎不需要自己编写 Shell 脚本，所以大学学过的 Shell 脚本编程基本忘完（实际上我并没有系统的学过它😂），工作中碰到相关东西时也是 Google 一下就搞定了。但是，现在的工作要求我能够编写 Shell 脚本实现一些自动化操作，所以我决定系统地学习一下 Shell 脚本编程的相关知识。主要参考的学习资料是 The Linux Documentation Project 网站上推荐的两本在线书籍：Bash Guide for Beginners 和 Advanced Bash-Scripting Guide 。前者适合入门，后者适合精进，感谢作者的无私分享。
Shell Shell 既是一个命令解释器（command interpreter），又是一门编程语言。Shell 脚本（shell scripts）是用 shell 编程语言编写的程序，它可以将系统调用、各种工具和已编译的二进制文件粘合在一起，形成新的应用。
Shell 脚本是解释执行的，shell 从脚本中逐行读取命令，然后在系统中昂搜索这些命令并执行。
Shell 有很多种，比如 sh（Bourne Shell）、bash（Bourne Again shell）、csh（C shell）、tcsh（TENEX C shell）、ksh（Korn shell）、tmux 等
查看系统内已经有的 shell：cat /etc/shells。 查看当前用户默认的 shell：cat /etc/passwd | grep $USER | awk 'BEGIN { FS=&amp;quot;:&amp;quot; } { print $7 }。</description></item><item><title>Rust 基础：错误处理</title><link>https://zhannicholas.github.io/posts/rust/rust_basics_error_handling/</link><pubDate>Wed, 29 Sep 2021 20:55:48 +0800</pubDate><guid>https://zhannicholas.github.io/posts/rust/rust_basics_error_handling/</guid><description>任何软件都不可避免地出现各种或大或小的 Bug，软件设计的一大目标就是软件的健壮性，而错误处理就是提高软件健壮性的一大利器。作为一门对安全比较执着的编程语言，Rust 给我们开发者提供了很多处理错误的功能特性。
Rust 中的错误（error）分为两种：可恢复错误（recoverable error）和不可恢复错误（unrecoverable error）。在 Java 中，不仅有错误（error），还有异常（exception），但 Rust 中是没有异常的。对于可恢复错误，Rust 给我们提供了 Result&amp;lt;T, E&amp;gt; 这种数据类型，供我们作进一步决定。而对于不可恢复错误，Rust 给我们提供了一个叫做 panic! 的宏，panic! 会在程序遭遇不可恢复错误时立即停止程序的执行。
不可恢复错误与 panic! 有时候，你碰到的错误（比如数组下标越界）会让你束手无策。这时，你可以使用 Rust 提供的 panic! 宏直接终止程序，防止更坏的事情发生。当 panic! 执行时，Rust 程序默认会先打印出失败信息，解退（unwinding） 并清理栈，然后退出。解退是一种比较优雅退出方式，与之相对的是直接终止（abort）。二者的区别在于，解退会清理数据，归还内存，而直接终止就不会清理数据，回收内存的工作交给了操作系统。
先来看一个简单的 panic!：
fn main() { panic!(&amp;#34;crash and burn&amp;#34;); } 这个程序一运行，就会出现错误信息：
&amp;gt; cargo run Compiling error_handling v0.1.0 (F:\Code\Rust\rust-study\error_handling) Finished dev [unoptimized + debuginfo] target(s) in 3.19s Running `target\debug\error_handling.exe` thread &amp;#39;main&amp;#39; panicked at &amp;#39;crash and burn&amp;#39;, src\main.rs:2:5 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace error: process didn&amp;#39;t exit successfully: `target\debug\error_handling.</description></item><item><title>Rust 基础：枚举与模式匹配</title><link>https://zhannicholas.github.io/posts/rust/rust_basics_enums_and_patterns_matching/</link><pubDate>Mon, 27 Sep 2021 19:04:33 +0800</pubDate><guid>https://zhannicholas.github.io/posts/rust/rust_basics_enums_and_patterns_matching/</guid><description>枚举（enum or enumeration） 是一种允许我们列举出所有可能的值的数据类型，每一个可能的值都是一个 variant。举个简单的例子，常见的 IP 地址有 IPv4 和 IPv6 两种，这时就可以定义一个表示 IP 地址类型的枚举类。
枚举的定义 我们先来定义一个表示 IP 地址类型的枚举类：
enum IpAddrKind { V4, V6, } 现在我们可以使用刚定义的 IpAddrKind 了。在 Rust 中，枚举类型实例的通过 :: 操作符创建的，:: 的左边是命名空间（枚举类型），右边是枚举类型中的可能值（variant）。例如：
let four = IpAddrKind::V4; let six = IpAddrKind::V6; 在 Rust 中，枚举类型中所有 variant 的类型都是相同的，这一点与其它编程语言有些不同。例如 IpAddrKind::V4 和 IpAddrKind::V6 的类型都是 IpAddrKind。现在的 IpAddrKind 只有类型的含义，并不能存储任何 IP 地址数据，我们把它稍微改造一下：
enum IpAddrKind { V4(String), V6(String), } let home = IpAddrKind::V4(String::from(&amp;#34;127.0.0.1&amp;#34;)); let loopback = IpAddrKind::V6(String::from(&amp;#34;::1&amp;#34;)); 现在，IpAddrKind 都能存储地址数据了。不过它还可以变得更加高级，IPv4 的地址可以用四个 0~255 之间的整数表示：</description></item></channel></rss>