<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式的艺术 on Nicholas Zhan</title><link>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/</link><description>Recent content in 设计模式的艺术 on Nicholas Zhan</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 27 Oct 2018 21:41:48 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/index.xml" rel="self" type="application/rss+xml"/><item><title>《设计模式的艺术》学习笔记之十三：代理模式</title><link>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%89%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 27 Oct 2018 21:41:48 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%89%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid><description>代理模式（Proxy Pattern）:给某一个对象提供一个代理，并由代理对象控制对原对象的引用。 代理模式中引入了一个新的代理对象，代理对象可</description></item><item><title>《设计模式的艺术》读书笔记之十二：享元模式</title><link>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%BA%8C%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link><pubDate>Wed, 17 Oct 2018 12:24:25 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%BA%8C%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid><description>享元模式（Flyweight Pattern）：运行共享技术有效的支持大量 细粒度 对象的复用，又称轻量级模式。 享元模式以共享的方式高效的支持大量</description></item><item><title>《设计模式的艺术》读书笔记之十一：外观模式</title><link>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 15 Oct 2018 10:39:37 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid><description>外观模式（Facade Pattern）：外部与一个子系统的通信通过一个统一的外观角色进行，为子系统中的一组接口提供一个统一的入口。外观模式又</description></item><item><title>《设计模式的艺术》学习笔记之十：装饰模式</title><link>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 15 Oct 2018 05:23:56 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</guid><description>装饰模式（Decotator Pattern）：动态的给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更加灵活。 装饰模</description></item><item><title>《设计模式的艺术》读书笔记之九：组合模式</title><link>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B9%9D%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 13 Oct 2018 11:16:37 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B9%9D%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid><description>组合模式（Composite Pattern）：组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构。组合模式对单个对象（叶子对象）</description></item><item><title>《设计模式的艺术》读书笔记之八：桥接模式</title><link>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AB%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link><pubDate>Tue, 09 Oct 2018 08:48:04 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AB%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid><description>桥接模式（Bridge Pattern）：将类的功能层次结构（抽象部分）和实现层次结构（实现部分）分离，使二者能够 独立 的变化，并在二者之间搭建</description></item><item><title>《设计模式的艺术》读书笔记之七：适配器模式</title><link>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%83%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 08 Oct 2018 14:53:10 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%83%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>适配器模式（Adapter Pattern）：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，又称包装器（Wrappe</description></item><item><title>《设计模式的艺术》读书笔记之六：建造者模式</title><link>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 07 Oct 2018 09:04:12 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>建造者模式（Builder Pattern）：将一个复杂的对象的构建与它的表示分离，使得同样的创建过程可以创建不同的表示。建造者模式又称为生成</description></item><item><title>《设计模式的艺术》读书笔记之五：原型模式</title><link>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 06 Oct 2018 11:35:30 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>原型模式（Prototype Pattern）：使用原型实例指定创建对象，并通过克隆这些原型得到新的对象。 原型模式的工作原理就是：将一个原型对</description></item><item><title>《设计模式的艺术》读书笔记之四：抽象工厂模式</title><link>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%9B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 05 Oct 2018 13:17:22 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%9B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列相关或者相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称Ki</description></item><item><title>《设计模式的艺术》读书笔记三：工厂方法模式</title><link>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link><pubDate>Wed, 03 Oct 2018 08:40:29 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid><description>工厂方法模式（Factory Method Pattern）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化，这让一个类的实例化延迟到了其子类。工</description></item><item><title>《设计模式的艺术》读书笔记二：简单工厂模式</title><link>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Tue, 02 Oct 2018 11:04:22 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>简单工厂模式（Simple Factory Pattern）：定义一个工厂类，工厂类根据参数返回不同的实例，被创建的实例通常具有共同的父类。由于创建实例的方</description></item><item><title>《设计模式的艺术》读书笔记一：单例模式</title><link>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Oct 2018 13:28:15 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid><description>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类就是单例类。 从单例模式</description></item><item><title>面向对象设计的7个原则</title><link>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%847%E4%B8%AA%E5%8E%9F%E5%88%99/</link><pubDate>Sat, 29 Sep 2018 20:51:23 +0800</pubDate><guid>https://zhannicholas.github.io/posts/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%847%E4%B8%AA%E5%8E%9F%E5%88%99/</guid><description>面向对象设计的7个原则 面向对象设计存在7个原则。在设计中使用这些原则，有助于提高设计模型的灵活性和可维护性，提高类的內聚度，降低类之间的耦合</description></item></channel></rss>