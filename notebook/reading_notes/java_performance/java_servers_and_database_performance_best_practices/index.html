<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Notes from Java Performance, 2nd Edition by Scott Oaks. Java Servers Scaling servers is mostly about effective use of threads, and that use requires event-driven, nonblocking I/O. Some newer frameworks offer programming models based on reactive programming. At their cores, reactive programming is based on handling asynchronous data streams using an event-based paradigm. Java NIO Overview Blocking I/O requires that the server has a one-to-one correspondence between client connections and"><meta name=theme-color content="#ffcd00"><meta property="og:title" content="Java Performance: Java Servers and Database Performance Best Practices • Nicholas Zhan"><meta property="og:description" content="Notes from Java Performance, 2nd Edition by Scott Oaks. Java Servers Scaling servers is mostly about effective use of threads, and that use requires event-driven, nonblocking I/O. Some newer frameworks offer programming models based on reactive programming. At their cores, reactive programming is based on handling asynchronous data streams using an event-based paradigm. Java NIO Overview Blocking I/O requires that the server has a one-to-one correspondence between client connections and"><meta property="og:url" content="https://zhannicholas.github.io/notebook/reading_notes/java_performance/java_servers_and_database_performance_best_practices/"><meta property="og:site_name" content="Nicholas Zhan"><meta property="og:type" content="article"><meta property="og:image" content="https://www.gravatar.com/avatar/85f2cc2a45fd9533b91a65214224f9d7?s=256"><meta property="article:section" content="notebook"><meta property="article:tag" content="Java"><meta property="article:published_time" content="2021-12-09T20:17:09+08:00"><meta property="article:modified_time" content="2021-12-09T20:17:09+08:00"><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.107.0"><title>Java Performance: Java Servers and Database Performance Best Practices • Nicholas Zhan</title><link rel=canonical href=https://zhannicholas.github.io/notebook/reading_notes/java_performance/java_servers_and_database_performance_best_practices/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/assets/css/main.ab98e12b.css><link rel=stylesheet href=/css/custom.css><style>:root{--color-accent:#ffcd00}</style></head><body class='page type-notebook has-sidebar'><div class=site><div id=sidebar class=sidebar><a class=screen-reader-text href=#main-menu>跳到主菜单</a><div class=container><section class='widget widget-about sep-after'><header><div class=logo><a href=/><img src=/images/logo.png></a></div><h2 class='title site-title'><a href=/>Nicholas Zhan</a></h2><div class=desc>后端攻城狮，骑行爱好者。微信公众号：一三 Dev</div></header></section><section class='widget widget-search sep-after'><header><h4 class='title widget-title'>搜索</h4></header><form action=/search id=search-form class=search-form><label><span class=screen-reader-text>搜索</span>
<input id=search-term class=search-term type=search name=q placeholder=搜索&mldr;></label></form></section><section class='widget widget-sidebar_menu sep-after'><nav id=sidebar-menu class='menu sidebar-menu' aria-label=侧边栏菜单><div class=container><ul><li class='item has-children'><a href=/java/>Java</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/java/jakartaee/>Jakarta EE</a></li><li class=item><a href=/java/jvm/>JVM</a></li><li class=item><a href=/java/concurrency/>并发</a></li></ul></li><li class=item><a href=/rust/>Rust</a></li><li class=item><a href=/distributed_computing/>分布式计算</a></li><li class=item><a href=/operating_systems/>操作系统</a></li><li class='item has-children'><a href=/computer_networks/>计算机网络</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/computer_networks/http/>HTTP</a></li><li class=item><a href=/computer_networks/fundamentals/>基础知识</a></li></ul></li></ul></div></nav></section><section class='widget widget-taxonomy_cloud sep-after'><header><h4 class='title widget-title'>标签</h4></header><div class='container list-container'><ul class='list taxonomy-cloud'><li><a href=/tags/communication/ style=font-size:1em>Communication</a></li><li><a href=/tags/c%E7%AE%97%E6%B3%95/ style=font-size:1.2380952380952381em>C算法</a></li><li><a href=/tags/english/ style=font-size:1em>English</a></li><li><a href=/tags/gc/ style=font-size:1.0952380952380953em>GC</a></li><li><a href=/tags/geography/ style=font-size:1.0476190476190477em>GeoGraphy</a></li><li><a href=/tags/geohash/ style=font-size:1.0476190476190477em>Geohash</a></li><li><a href=/tags/git/ style=font-size:1em>Git</a></li><li><a href=/tags/http/ style=font-size:1.3333333333333333em>HTTP</a></li><li><a href=/tags/hugo/ style=font-size:1em>Hugo</a></li><li><a href=/tags/jakartaee/ style=font-size:1.0952380952380953em>JakartaEE</a></li><li><a href=/tags/java/ style=font-size:2em>Java</a></li><li><a href=/tags/jdbc/ style=font-size:1em>JDBC</a></li><li><a href=/tags/jvm/ style=font-size:1.1428571428571428em>JVM</a></li><li><a href=/tags/leetcode/ style=font-size:1.0952380952380953em>Leetcode</a></li><li><a href=/tags/life/ style=font-size:1em>Life</a></li><li><a href=/tags/linux/ style=font-size:1.1428571428571428em>Linux</a></li><li><a href=/tags/mybatis/ style=font-size:1em>MyBatis</a></li><li><a href=/tags/networks/ style=font-size:1.0952380952380953em>Networks</a></li><li><a href=/tags/os/ style=font-size:1.2857142857142856em>OS</a></li><li><a href=/tags/ostep/ style=font-size:1.0952380952380953em>OSTEP</a></li><li><a href=/tags/python/ style=font-size:1em>Python</a></li><li><a href=/tags/redis/ style=font-size:1.3333333333333333em>Redis</a></li><li><a href=/tags/rpc/ style=font-size:1em>RPC</a></li><li><a href=/tags/rust/ style=font-size:1.3333333333333333em>Rust</a></li><li><a href=/tags/shell/ style=font-size:1.2380952380952381em>Shell</a></li><li><a href=/tags/sicp/ style=font-size:1em>SICP</a></li><li><a href=/tags/spring/ style=font-size:1em>Spring</a></li><li><a href=/tags/spring-boot/ style=font-size:1em>Spring Boot</a></li><li><a href=/tags/tomcat/ style=font-size:1em>Tomcat</a></li><li><a href=/tags/zookeeper/ style=font-size:1em>ZooKeeper</a></li><li><a href=/tags/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE/ style=font-size:1em>百度地图</a></li><li><a href=/tags/%E5%B9%B6%E5%8F%91/ style=font-size:1.380952380952381em>并发</a></li><li><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/ style=font-size:1.0476190476190477em>分布式计算</a></li><li><a href=/tags/%E5%B7%A5%E7%A8%8B%E6%80%9D%E7%BB%B4/ style=font-size:1em>工程思维</a></li><li><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ style=font-size:1.5714285714285714em>设计模式</a></li><li><a href=/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/ style=font-size:1em>设计原则</a></li><li><a href=/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/ style=font-size:1em>生产者消费者</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/ style=font-size:1.0476190476190477em>数据库</a></li><li><a href=/tags/%E6%90%9C%E7%B4%A2/ style=font-size:1em>搜索</a></li><li><a href=/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/ style=font-size:1.1428571428571428em>算法导论</a></li><li><a href=/tags/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ style=font-size:1.0476190476190477em>现代操作系统</a></li><li><a href=/tags/%E6%B8%B8%E8%AE%B0/ style=font-size:1em>游记</a></li></ul></div></section></div><div class=sidebar-overlay></div></div><div class=main><nav id=main-menu class='menu main-menu' aria-label=主菜单><div class=container><a class=screen-reader-text href=#content>跳到内容</a>
<button id=sidebar-toggler class=sidebar-toggler aria-controls=sidebar>
<span class=screen-reader-text>Toggle Sidebar</span>
<span class=open><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></span><span class=close><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span></button><ul><li class=item><a href=/>主页</a></li><li class=item><a href=/posts/>博客</a></li><li class='item current'><a aria-current=page href=/notebook/>笔记本</a></li><li class=item><a href=/linux/>Linux</a></li></ul></div></nav><div class=header-widgets><div class=container><style>.widget-breadcrumbs li:after{content:'\2f '}</style><section class='widget widget-breadcrumbs sep-after'><nav id=breadcrumbs><ol><li><a href=/>主页</a></li><li><a href=/notebook/>笔记本</a></li><li><span>Java Performance: Java Servers and Database Performance Best Practices</span></li></ol></nav></section></div></div><header id=header class='header site-header'><div class='container sep-after'><div class=header-info><p class='site-title title'>Nicholas Zhan</p><p class='desc site-desc'>后端攻城狮，骑行爱好者。微信公众号：一三 Dev</p></div></div></header><main id=content><article lang=zh-cn class=entry><header class='header entry-header'><div class='container sep-after'><div class=header-info><h1 class=title>Java Performance: Java Servers and Database Performance Best Practices</h1></div><div class=entry-meta><span class=posted-on><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg><span class=screen-reader-text>Posted on</span>
<time class=entry-date datetime=2021-12-09T20:17:09+08:00>2021, Dec 09</time></span>
<span class=byline><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M21 21V20c0-2.76-4-5-9-5s-9 2.24-9 5v1"/><path d="M16 6.37A4 4 0 1112.63 3 4 4 0 0116 6.37z"/></svg><span class=screen-reader-text>by </span><a href=/authors/zhannicholas>Nicholas Zhan</a></span>
<span class=reading-time><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 15 15"/></svg>3 mins read</span></div></div></header><details class='container entry-toc'><summary class=title><span>目录</span></summary><nav id=TableOfContents><ul><li><a href=#java-servers>Java Servers</a><ul><li><a href=#java-nio-overview>Java NIO Overview</a></li><li><a href=#server-containers>Server Containers</a></li><li><a href=#async-rest-servers>Async Rest Servers</a></li><li><a href=#json-processing>JSON Processing</a></li></ul></li><li><a href=#database-performance-best-practices>Database Performance Best Practices</a><ul><li><a href=#jdbc>JDBC</a></li><li><a href=#transactions>Transactions</a></li><li><a href=#jpa>JPA</a></li><li><a href=#summary>Summary</a></li></ul></li></ul></nav></details><div class='container entry-content'><blockquote><p>Notes from <em>Java Performance, 2nd Edition by Scott Oaks.</em></p></blockquote><h2 id=java-servers>Java Servers</h2><p>Scaling servers is mostly about effective use of threads, and that use requires event-driven, nonblocking I/O.</p><p>Some newer frameworks offer programming models based on reactive programming. At their cores, <strong>reactive programming</strong> is based on handling asynchronous data streams using an event-based paradigm.</p><h3 id=java-nio-overview>Java NIO Overview</h3><p>Blocking I/O requires that the server has a one-to-one correspondence between client connections and server threads; each thread can handle only a single connection. This is particularly an issue for clients that want to use HTTP keepalive to avoid the performance impact of creating a new socket with every request.</p><p>NIO is classic event-driven programming: when data on a socket connection is available to be read, a thread (usually from a pool) is notified of that event. That thread reads the data, processes it (or passes the data to yet another thread to be processed), and then returns to the pool.</p><h3 id=server-containers>Server Containers</h3><p>The threads notify the system call when I/O is available and are called <strong>selector threads</strong>. Then a separate thread pool of <strong>worker threads</strong> handles the actual request/response to a client after the selector notifies them that I/O is pending for the client.</p><p>The selector and worker threads can be set up in various ways:</p><ul><li>Selector and worker thread pools can be separate. The selectors wait for notification on all sockets and hand off requests to the worker thread pool.</li><li>Alternately, when the selector is notified about I/O, it reads (perhaps only part of) the I/O to determine information about the request. Then the selector forwards the request to different server thread pools, depending on the type of request.</li><li>A selector pool accepts new connections on a <code>ServerSocket</code>, but after the connections are made, all work is handled in the worker thread pool. A thread in the worker thread pool will sometimes use the <code>Selector</code> class to wait for pending I/O about an existing connection, and it will sometimes be handling the notification from a worker thread that I/O for a client is pending (e.g., it will perform the request/response for the client).</li><li>There needn’t be a distinction at all between threads that act as selectors and threads that handle requests. A thread that is notified about I/O available on a socket can process the entire request. Meanwhile, the other threads in the pool are notified about I/O on other sockets and handle the requests on those other sockets.</li></ul><h3 id=async-rest-servers>Async Rest Servers</h3><p>An alternative to tuning the request thread pool of a server is to defer work to another thread pool.</p><p>There are three reasons you would use an async response:</p><ul><li>To introduce more parallelism into the business logic.</li><li>To limit the number of active threads.</li><li>To properly throttle the server.</li></ul><h3 id=json-processing>JSON Processing</h3><p>Given a series of JSON strings, a program must convert those strings into data suitable for processing by Java. This is called either <strong>marshaling</strong> or <strong>parsing</strong>, depending on the context and the resulting output. If the output is a Java object, the process is called <strong>marshaling</strong>; if the data is processed as it is read, the process is called <strong>parsing</strong>. The reverse—producing JSON strings from other data—is called <strong>unmarshaling</strong>.</p><h2 id=database-performance-best-practices>Database Performance Best Practices</h2><p>There is no corresponding standard for NoSQL databases, and hence there is no standard platform support for accessing them.</p><h3 id=jdbc>JDBC</h3><p>The JDBC driver is the most important factor in the performance of database applications.</p><p>JDBC drivers come in four types (1–4). The driver types in wide use today are type 2 (which uses native code) and type 4 (which is pure Java).</p><ul><li>Type 1 drivers provide a bridge between Open Database Connectivity (ODBC) and JBDC. If an application must talk to a database using ODBC, it must use this driver. Type 1 drivers generally have quite bad performance.</li><li>Type 2 drivers use a native library to access the database.</li><li>Type 3 drivers are, like type 4 drivers, written purely in Java, but they are designed for a specific architecture in which a piece of middleware (sometimes, though usually not, an application server) provides an intermediary translation.</li><li>Type 4 drivers are pure Java drivers that implement the wire protocol that the database vendor has defined for accessing their database.</li></ul><p>Connections to a database are time-consuming to create, so JDBC connections are another prototypical object that you should reuse in Java.</p><p>In most circumstances, code should use a <code>PreparedStatement</code> rather than a <code>Statement</code> for its JDBC calls. This aids performance: prepared statements allow the database to reuse information about the SQL that is being executed. That saves work for the database on subsequent executions of the prepared statement. Prepared statements also have security and programming advantages, particularly in specifying parameters to the call.</p><p>Prepared statement pools operate on a per connection basis.</p><p>The size of the connection pool also matters because it is caching those prepared statements, which take up heap space (and often a lot of heap space).</p><p>Applications that process large amounts of data from a query should consider changing the fetch size of the data.</p><p>A trade-off exists between loading too much data in the application (putting pressure on the garbage collector) and making frequent database calls to retrieve a set of data.</p><h3 id=transactions>Transactions</h3><p>Database transactions have two performance penalties. First, it takes time for the database to set up and then commit the transaction. Second, during a database transaction, it is common for the transaction to obtain a lock for a particular set of data.</p><p>Transactions are expensive to commit, so one goal is to perform as much work in a transaction as is possible. Unfortunately, that principle is completely at odds with another goal: because transactions can hold locks, they should be as short as possible.</p><p>Committing all the data at once offers the fastest performance.</p><p>Here are the basic transaction isolation modes (in order from most to least expensive):</p><ul><li>TRANSACTION_SERIALIZABLE: This is the most expensive transaction mode; it requires that all data accessed within the transaction be locked for the duration of the transaction.</li><li>TRANSACTION_REPEATABLE_READ: This requires that all accessed data is locked for the duration of the transaction. However, other transactions can insert new rows into the table at any time. This mode can lead to phantom reads</li><li>TRANSACTION_READ_COMMITTED: This mode locks only rows that are written during a transaction. This leads to nonrepeatable reads</li><li>TRANSACTION_READ_UNCOMMITTED: This is the least expensive transaction mode. No locks are involved, so one transaction may read the written (but uncommitted) data in another transaction. This is known as a dirty read.</li></ul><h3 id=jpa>JPA</h3><p>The performance of JPA is directly affected by the performance of the underlying JDBC driver, and most of the performance considerations regarding the JDBC driver apply to JPA. JPA has additional performance considerations.</p><p>JPA achieves many of its performance enhancements by altering the bytecode of the entity classes.</p><p>In JDBC, we looked at two critical performance techniques: reusing prepared statements and performing updates in batches.</p><p>One common way to optimize writes to a database is to write only those fields that have changed.</p><p>The JPA Query Language (JPQL) doesn’t allow you to specify fields of an object to be retrieved.</p><h4 id=jpa-caching>JPA Caching</h4><p>JPA is designed with that architecture in mind. Two kinds of caches exist in JPA. Each entity manager instance is its own cache: it will locally cache data that it has retrieved during a transaction. It will also locally cache data that is written during a transaction; the data is sent to the database only when the transaction commits.</p><p>When an entity manager commits a transaction, all data in the local cache can be merged into a global cache. The global cache is shared among all entity managers in the application. The global cache is also known as the Level 2 (L2) cache or the second-level cache; the cache in the entity manager is known as the Level 1, L1, or first-level cache.</p><h3 id=summary>Summary</h3><p>Properly tuning JDBC and JPA access to a database is one of the most significant ways to affect the performance of a middle-tier application. Keep in mind these best practices:</p><ul><li>Batch reads and writes as much as possible by configuring the JDBC or JPA configuration appropriately.</li><li>Optimize the SQL the application issues. For JDBC applications, this is a question of basic, standard SQL commands. For JPA applications, be sure to consider the involvement of the L2 cache.</li><li>Minimize locking where possible. Use optimistic locking when data is unlikely to be contended, and use pessimistic locking when data is contended.</li><li>Make sure to use a prepared statement pool.</li><li>Make sure to use an appropriately sized connection pool.</li><li>Set an appropriate transaction scope: it should be as large as possible without negatively affecting the scalability of the application because of the locks held during the transaction.</li></ul></div><footer class=entry-footer><div class='container sep-before'><div class=categories><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5A2 2 0 014 3H9l2 3h9a2 2 0 012 2z"/></svg><span class=screen-reader-text>分类: </span><a class=category href=/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>读书笔记</a></div><div class=tags><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2H12l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=screen-reader-text>标签: </span><a class=tag href=/tags/java/>Java</a></div></div></footer></article><nav class=entry-nav><div class=container><div class='prev-entry sep-before'><a href=/notebook/reading_notes/java_performance/threading_and_synchronization_performance/><span aria-hidden=true><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="20" y1="12" x2="4" y2="12"/><polyline points="10 18 4 12 10 6"/></svg>Previous</span>
<span class=screen-reader-text>上一篇: </span>Java Performance: Threading and Synchronization Performance</a></div><div class='next-entry sep-before'><a href=/notebook/reading_notes/java_performance/java_se_api_tips/><span class=screen-reader-text>下一篇: </span>Java Performance: Java SE API Tips<span aria-hidden=true>下一个<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="4" y1="12" x2="20" y2="12"/><polyline points="14 6 20 12 14 18"/></svg></span></a></div></div></nav></main><footer id=footer class=footer><div class='container sep-before'><section class='widget widget-social_menu sep-after'><nav aria-label=社交菜单><ul><li><a href=https://github.com/zhannicholas target=_blank rel='noopener me'><span class=screen-reader-text>Open Github account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li><a href=https://t.me/zhannicholas target=_blank rel='noopener me'><span class=screen-reader-text>Open Telegram account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M23.91 3.79 20.3 20.84c-.25 1.21-.98 1.5-2 .94l-5.5-4.07-2.66 2.57c-.3.3-.55.56-1.1.56-.72.0-.6-.27-.84-.95L6.3 13.7.85 12c-1.18-.35-1.19-1.16.26-1.75l21.26-8.2c.97-.43 1.9.24 1.53 1.73z"/></svg></a></li><li><a href=mailto:zhan_nicholas@outlook.com target=_blank rel='noopener me'><span class=screen-reader-text>Contact via Email</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></li><li><a href=https://linkedin.com/in/%e4%bc%9f%e4%bc%9f-%e8%a9%b9-27871a104 target=_blank rel='noopener me'><span class=screen-reader-text>Open Linkedin account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li></ul></nav></section><div class=copyright><p>&copy; 2018-2022 Nicholas Zhan</p></div></div></footer></div></div><script>window.__assets_js_src="/assets/js/"</script><script src=/assets/js/main.c3bcf2df.js></script><script src=/js/custom.js></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"processEscapes":true}})
</script>
<script type=text/javascript async src='//unpkg.com/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML'></script></body></html>