<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="之所以放在 Notebook 中，是因为本文的绝大部分内容来自某网课，做笔记备忘，便于以后碰到相关问题更快地定位和排查问题。 MyBatis 三层架构 MyBatis 的整体架构分为三层，分"><meta name=theme-color content="#ffcd00"><meta property="og:title" content="Mybatis • Nicholas Zhan"><meta property="og:description" content="之所以放在 Notebook 中，是因为本文的绝大部分内容来自某网课，做笔记备忘，便于以后碰到相关问题更快地定位和排查问题。 MyBatis 三层架构 MyBatis 的整体架构分为三层，分"><meta property="og:url" content="https://zhannicholas.github.io/notebook/mybatis/"><meta property="og:site_name" content="Nicholas Zhan"><meta property="og:type" content="article"><meta property="og:image" content="https://www.gravatar.com/avatar/85f2cc2a45fd9533b91a65214224f9d7?s=256"><meta property="article:section" content="notebook"><meta property="article:tag" content="MyBatis"><meta property="article:published_time" content="2021-03-22T23:58:56+08:00"><meta property="article:modified_time" content="2021-03-22T23:58:56+08:00"><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.81.0"><title>Mybatis • Nicholas Zhan</title><link rel=canonical href=https://zhannicholas.github.io/notebook/mybatis/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/assets/css/main.ab98e12b.css><link rel=stylesheet href=/css/custom.css><style>:root{--color-accent:#ffcd00}</style></head><body class="page type-notebook has-sidebar"><div class=site><div id=sidebar class=sidebar><a class=screen-reader-text href=#main-menu>跳到主菜单</a><div class=container><section class="widget widget-about sep-after"><header><div class=logo><a href=/><img src=/images/logo.png></a></div><h2 class="title site-title"><a href=/>Nicholas Zhan</a></h2><div class=desc>Java Developer, Runner, Cyclist</div></header></section><section class="widget widget-sidebar_menu sep-after"><nav id=sidebar-menu class="menu sidebar-menu" aria-label=侧边栏菜单><div class=container><ul><li class="item has-children"><a href=/posts/databases/>Database</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/posts/databases/redis/>Redis</a></li><li class=item><a href=/posts/databases/fundamentals/>基础理论</a></li></ul></li><li class="item has-children"><a href=/posts/java/>Java</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/posts/java/jakartaee/>Jakarta EE</a></li><li class=item><a href=/posts/java/concurrency/>Java并发</a></li><li class=item><a href=/posts/java/jvm/>JVM</a></li></ul></li><li class="item has-children"><a href=/posts/operating_systems/>操作系统</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/posts/operating_systems/memory_management/>内存管理</a></li><li class=item><a href=/posts/operating_systems/virtualization/>虚拟化</a></li><li class=item><a href=/posts/operating_systems/processes_management/>进程管理</a></li></ul></li><li class="item has-children"><a href=/posts/computer_networks/>计算机网络</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/posts/computer_networks/http/>HTTP</a></li><li class=item><a href=/posts/computer_networks/fundamentals/>基础知识</a></li></ul></li><li class="item has-children"><a href=/reading_notes/>读书笔记</a><button class=sub-menu-toggler>
<span class=screen-reader-text>expand sub menu</span>
<span class=sign></span></button><ul class=sub-menu><li class=item><a href=/reading_notes/algorithms_in_c/>C算法</a></li><li class=item><a href=/reading_notes/ostep/>OSTEP</a></li><li class=item><a href=/reading_notes/sicp_in_python/>SICP in Python</a></li><li class=item><a href=/reading_notes/the_art_of_multiprocessor_programming/>多处理器编程的艺术</a></li><li class=item><a href=/reading_notes/modern_operating_systems/>现代操作系统</a></li><li class=item><a href=/reading_notes/introduction_to_algorithms/>算法导论</a></li><li class=item><a href=/reading_notes/%E7%AE%97%E6%B3%95%E8%B6%A3%E9%A2%98/>算法趣题</a></li><li class=item><a href=/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/>设计模式的艺术</a></li></ul></li></ul></div></nav></section><section class="widget widget-taxonomy_cloud sep-after"><header><h4 class="title widget-title">分类</h4></header><div class="container list-container"><ul class="list taxonomy-cloud"><li><a href=/categories/db/ style=font-size:1.1818181818181819em>DB</a></li><li><a href=/categories/java/ style=font-size:1.5151515151515151em>Java</a></li><li><a href=/categories/leetcode/ style=font-size:1.0606060606060606em>Leetcode</a></li><li><a href=/categories/linux/ style=font-size:1em>Linux</a></li><li><a href=/categories/networks/ style=font-size:1.303030303030303em>Networks</a></li><li><a href=/categories/notebook/ style=font-size:1em>Notebook</a></li><li><a href=/categories/os/ style=font-size:1.1515151515151516em>OS</a></li><li><a href=/categories/tools/ style=font-size:1em>Tools</a></li><li><a href=/categories/%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF/ style=font-size:1.0606060606060606em>新手上路</a></li><li><a href=/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/ style=font-size:2em>读书笔记</a></li></ul></div></section></div><div class=sidebar-overlay></div></div><div class=main><a class=screen-reader-text href=#content>跳到内容</a>
<button id=sidebar-toggler class=sidebar-toggler aria-controls=sidebar>
<span class=screen-reader-text>Toggle Sidebar</span>
<span class=open><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></span><span class=close><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span></button><div class=header-widgets><div class=container><style>.widget-breadcrumbs li:after{content:'\2f '}</style><section class="widget widget-breadcrumbs sep-after"><nav id=breadcrumbs><ol><li><a href=/>Home</a></li><li><a href=/notebook/>Notebooks</a></li><li><span>Mybatis</span></li></ol></nav></section></div></div><header id=header class="header site-header"><div class="container sep-after"><div class=header-info><p class="site-title title">Nicholas Zhan</p><p class="desc site-desc">Java Developer, Runner, Cyclist</p></div></div></header><main id=content><article lang=zh-cn class=entry><header class="header entry-header"><div class="container sep-after"><div class=header-info><h1 class=title>Mybatis</h1></div><div class=entry-meta><span class=posted-on><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg><span class=screen-reader-text>Posted on</span>
<time class=entry-date datetime=2021-03-22T23:58:56+08:00>2021, Mar 22</time></span>
<span class=byline><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M21 21V20c0-2.76-4-5-9-5s-9 2.24-9 5v1"/><path d="M16 6.37A4 4 0 1112.63 3 4 4 0 0116 6.37z"/></svg><span class=screen-reader-text>by </span><a href=/authors/zhannicholas>Nicholas Zhan</a></span>
<span class=reading-time><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 15 15"/></svg>15 mins read</span></div></div></header><details class="container entry-toc"><summary class=title><span>目录</span></summary><nav id=TableOfContents><ul><li><a href=#mybatis-三层架构>MyBatis 三层架构</a><ul><li><a href=#基础支撑层>基础支撑层</a></li><li><a href=#核心处理层>核心处理层</a></li><li><a href=#接口层>接口层</a></li></ul></li></ul></nav></details><div class="container entry-content"><p>之所以放在 Notebook 中，是因为本文的绝大部分内容来自某网课，做笔记备忘，便于以后碰到相关问题更快地定位和排查问题。</p><h2 id=mybatis-三层架构>MyBatis 三层架构</h2><p>MyBatis 的整体架构分为三层，分别是：<strong>基础支撑层</strong>、<strong>逻辑处理层</strong> 和 <strong>接口层</strong>。</p><p><img src=/images/notebook/MyBatis/MyBatis%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E5%9B%BE.png alt></p><h3 id=基础支撑层>基础支撑层</h3><p>基础支撑层为整个 MyBatis 框架提供最基础的功能，分为九个基础模块，每个模块都具有各自不同的能力。</p><h4 id=类型转换模块>类型转换模块</h4><blockquote><p>在使用 JDBC 操作数据库时，我们面临着三个不同层次的数据类型差异——数据库自己的数据类型、JDBC 定义的数据类型和 Java 数据类型。JDBC 在中间，作为规范标准，它可以屏蔽底层数据的差异，但 JDBC 类型与 Java 类型并不是一一对应的，所以需要进行适当的类型转换。</p></blockquote><p><a href=https://download.oracle.com/otn-pub/jcp/jdbc-4_2-mrel2-eval-spec/jdbc4.2-fr-spec.pdf>JDBC Spec 4.2</a> 中定义了 JDBC 类型到 Java 类型的映射关系、Java 类型到 JDBC 类型的映射关系等等。</p><p><img src=/images/notebook/MyBatis/MyBatis%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%9D%97.png alt></p><p>类型转换模块实现了 MyBatis 中定义的 JDBC 类型与 Java 类型之间的相互转换：</p><ul><li>当 MyBatis 在将 SQL 模板与用户传入的参数相绑定（在我们使用 <code>PreparedStatement</code> 执行 SQL 之前，需要手动调用 <code>setInt()</code>、<code>setString()</code> 等方法绑定参数）时，类型转换模块会将 Java 类型数据转换为 JDBC 类型数据。</li><li>当取得查询结果后，类型转换模块会将 <code>ResultSet</code> 中的 JDBC 类型数据转换为 Java 类型数据。</li></ul><p>此外，类型转换模块还实现了别名的功能。我们可以在 <code>mybatis-config.xml</code> 配置文件中使用 <code>&lt;typeAlias></code> 标签为 Java 类的完整名称定义相应的别名。然后在后续编写 SQL 语句、定义 <code>&lt;resultMap></code> 的时候，就可以直接使用这些别名替代相应的 Java 类名，这样就非常易于代码的编写和维护。<code>TypeAliasRegistry</code> 是维护别名配置的核心实现，它提供了别名注册、别名查询等基本功能。</p><h5 id=typehandler>TypeHandler</h5><p>MyBatis 中的类型转换模块包含众多类型转换器，这些类型转换器都有一个父接口——<code>TypeHandler</code>。整个转换器的层次结构如下（为了简单，图中省略了不少类型转换器）：</p><p><img src=/images/notebook/MyBatis/TypeHandler.png alt></p><p>其中，<code>BaseTypeHandler</code> 不仅实现了一些 <code>TypeHandler</code> 的公共逻辑，还实现了抽象类 <code>TypeReference</code>。</p><p>除了这些默认的 <code>TypeHandler</code> 之外，我们还可以在 <code>mybatis-config.xml</code> 中使用标签配置自定义的 <code>TypeHandler</code> 实现，也可以在定义 <code>Mapper.xml</code> 的时候指定 <code>typeHandler</code> 属性。不管是哪种方式，MyBatis 都会在初始化的过程中，获取所有已知的 <code>TypeHandler</code>，创建对应的实例并注册到 <code>TypeHandlerRegistry</code> 中，由 <code>TypeHandlerRegistry</code> 统一管理所有的 <code>TypeHandler</code> 实例。</p><h4 id=日志模块>日志模块</h4><p>MyBatis 提供的日志模块可以很方便地集成各种第三方 Java 日志框架，比如 Log4j、Log4j2、slf4j、java.util.logging 等。由于这些日志框架来源于不同的开源组织，给用户暴露的接口也不尽相同。所以 MyBatis 使用了 <strong>适配器模式</strong>（<a href=../../reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%83%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F>设计模式读书笔记之适配器模式</a>）对第三方日志框架接口进行了统一。</p><p>MyBatis 自己定义了一个 <code>Log</code> 接口，然后使用适配器模式针对不同的日志框架进行了适配，将第三方日志框架的日志接口转化为了它自己的 <code>Log</code> 接口，这样就成功集成了第三方日志框架的日志打印功能。</p><p><code>Log</code> 接口及相关适配器实现均位于 <code>org.apache.ibatis.logging</code> 包中。整体结构如下：</p><p><img src=/images/notebook/MyBatis/Logging.png alt></p><p>其中，<code>LoggFactory</code> 负责创建 <code>Log</code> 对象，这个工厂类中有一段静态代码块，会依次加载各个第三方日志框架的适配器。</p><h4 id=binding-模块>Binding 模块</h4><p>在使用 MyBatis 时，我们无须编写 <code>Mapper</code> 接口的具体实现，Binding 模块会自动生成 <code>Mapper</code> 接口的动态代理对象，通过代理对象可以执行关联 <code>Mapper.xml</code> 文件（或 <code>Mapper</code> 接口中的注解）中的数据库操作。Binding 模块的核心类如下：</p><p><img src=/images/notebook/MyBatis/binding-module.png alt></p><p><code>MapperRegistry</code>（在 MyBatis 初始化过程中构造） 主要负责统一维护 <code>Mapper</code> 接口以及这些 <code>Mapper</code> 对应的代理对象工厂 <code>MapperProxyFactory</code>。<code>MapperProxyFactory</code> 通过 JDK 动态代理的方式创建 <code>Mapper</code> 接口的代理对象 <code>MapperProxy</code>，<code>MapperProxy</code> 封装核心代理逻辑，将拦截到的目标方法委托给 <code>MapperMethod</code> 处理。</p><h5 id=mapperproxy>MapperProxy</h5><p><code>MapperProxy</code> 是生成 <code>Mapper</code> 接口代理对象的关键，它实现了 <code>InvocationHandler</code> 接口。<code>Mapper</code> 代理对象的执行入口正是 <code>MapperProxy</code> 的 <code>invoke()</code> 方法。该方法内部会针对所有的非 <code>Object</code> 方法调用 <code>cachedInvoker()</code> 方法获取对应的 <code>MapperMethodInvoker</code> 对象，并调用其 <code>invoke()</code> 方法执行代理逻辑以及目标方法。</p><p>在 <code>cachedInvoker()</code> 方法中，首先会查询 <code>methodCache</code> 缓存（类型为 <code>Map&lt;Method, MapperMethodInvoker></code>），如果查询的方法为 <code>default</code> 方法，则会根据当前使用的 JDK 版本，获取对应的 <code>MethodHandle</code>（相关文档：<a href=https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html>MethodHandle</a>） 并封装成 <code>DefaultMethodInvoker</code> 对象写入缓存备用；如果查询的方法是非 <code>default</code> 方法，则创建 <code>PlainMethodInvoker</code> 对象写入缓存备用。</p><p><img src=/images/notebook/MyBatis/MapperMethodInvoker.png alt></p><p><code>DefaultMethodInvoker</code> 与 <code>PlainMethodInvoker</code> 的内部实现稍有不同，前者通过 <code>MethodHandle</code> 完成调用，而后者通过 <code>MapperMethod</code> 完成调用。</p><h5 id=mappermethod>MapperMethod</h5><p><code>MapperMethod</code> 记录了 <code>Mapper</code> 接口中的对应方法，也是最终执行 SQL 语句的地方（<code>execute()</code>方法），<code>execute()</code> 方法会根据要执行的 SQL 语句的具体类型执行 <code>SqlSession</code> 的相应方法完成数据库操作。</p><p>在 <code>MapperMethod</code> 中，<code>command</code> 字段（<code>SqlCommand</code> 类型，它是 <code>MapperMethod</code> 的一个内部类）维护了关联 SQL 语句的相关信息。先简单看一下 <code>SqlCommand</code> 类：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SqlCommand</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> String name<span style=color:#f92672>;</span>          <span style=color:#75715e>// 关联 SQL 语句的唯一标识
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> SqlCommandType type<span style=color:#f92672>;</span>  <span style=color:#75715e>// 关联 SQL 语句的操作类型
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</code></pre></div><p>MyBatis 中的 SQL 语句有五种不同的操作类型：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>enum</span> SqlCommandType <span style=color:#f92672>{</span>
  UNKNOWN<span style=color:#f92672>,</span> INSERT<span style=color:#f92672>,</span> UPDATE<span style=color:#f92672>,</span> DELETE<span style=color:#f92672>,</span> SELECT<span style=color:#f92672>,</span> FLUSH
<span style=color:#f92672>}</span>
</code></pre></div><p><code>MapperMethod</code> 中的 <code>method</code> 字段（<code>MethodSignature</code> 类型）则是维护了 <code>Mapper</code> 接口中方法的相关信息。它依赖 <code>ParamNameResolver</code> 这个解析方法参数列表的工具类。这里有必要单独说一下这个工具类。</p><p><code>ParamNameResolver</code> 中有一个 <code>name</code> 字段记录了各个参数参数在参数列表中的位置以及参数名称，其中 key 是参数在参数列表中的位置索引， value 为参数的名称。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> SortedMap<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>,</span> String<span style=color:#f92672>&gt;</span> names<span style=color:#f92672>;</span>
</code></pre></div><p>我们可以通过 <code>@Param</code> 注解指定一个参数名称，如果没有指定，则默认使用参数列表中的变量名称作为其名称，这与 <code>ParamNameResolver</code> 的 <code>useActualParamName</code> 有关，它是一个全局配置。如果将其配置为 <code>false</code>，则使用参数的下标索引作为其名称。此外，<code>names</code> 集合会跳过类型为 <code>RowBounds</code> 和 <code>ResultHandler</code> 类型的参数，如果使用下标作为索引作为参数名称的话，这时就会在 <code>names</code> 集合中出现 KV 不一致的情况。例如：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>aMethod(@Param(&#34;M&#34;) int a, @Param(&#34;N&#34;) int b) -&gt; {{0, &#34;M&#34;}, {1, &#34;N&#34;}}
aMethod(int a, int b) -&gt; {{0, &#34;0&#34;}, {1, &#34;1&#34;}}
aMethod(int a, RowBounds rb, int b) -&gt; {{0, &#34;0&#34;}, {2, &#34;1&#34;}}
</code></pre></div><h4 id=资源加载模块>资源加载模块</h4><p>资源加载模块主要是对类加载器进行封装，确定类加载器的使用顺序，并提供了加载类文件以及其他资源文件的功能。</p><h4 id=数据源模块>数据源模块</h4><p>数据源是持久层框架中最核心的组件之一，MyBatis 不仅提供了一套默认的数据源实现，还能够很方便地集成第三方数据源。在 Java 中，数据源这个抽象由 <code>javax.sql.DataSource</code> 接口表示，MyBatis 自带的数据源实现就实现了该接口。MyBatis 默认实现了两种类型的数据源——<code>UnpooledDataSource</code> 和 <code>PooledDataSource</code>。</p><p><img src=/images/notebook/MyBatis/datasource-implementations.png alt></p><p>此外，对于这两种不同的数据源实现，MyBatis 还使用工厂方法模式（<a href=../../reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F>设计模式读书笔记之工厂方法模式</a>）提供了相应的工厂类：</p><p><img src=/images/notebook/MyBatis/DataSourceFactory.png alt></p><p>使用工厂方法模式的好处在于，如果需要扩展新的数据源，只需要添加相应的 <code>DataSourceFactory</code> 接口实现类即可。这里的 <code>DataSource</code> 即工厂方法模式中的 <code>Product</code>。<code>DataSourceFactory</code> 定义了两个方法：<code>setProperties()</code> 用于配置数据源属性，<code>getDataSource()</code> 用于返回数据源对象。从上图可以看出，<code>PooledDataSourceFactory</code> 并没有直接实现 <code>DatasourceFactory</code> 接口，而是直接继承了 <code>UnpooledDataSourceFactory</code> 类。</p><h4 id=缓存管理模块>缓存管理模块</h4><p>缓存是优化数据库性能的常用手段之一，正确使用缓存可以将一部分数据库请求拦截在缓存层，减少数据库的压力，提升系统性能。</p><p><img src=/images/notebook/MyBatis/cache-model.png alt=缓存原理></p><p>MyBatis 就提供了许多不同策略的缓存，这些缓存分为两个级别：一级缓存和二级缓存，它们都实现了 <code>Cache</code> 接口。</p><p><img src=/images/notebook/MyBatis/Cache.png alt></p><p><code>Cache</code> 接口定义了 MyBatis 缓存最基本、最核心的行为，其中的核心方法主要是 <code>putObject()</code>、<code>getObject()</code> 和 <code>removeObject()</code>，分别用来添加、查询和删除缓存数据。MyBatis 在实现缓存模块时采用了装饰器模式（<a href=../../reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F>设计模式读书笔记之装饰器模式</a>），其中 <code>PerpetualCache</code> 扮演的正是装饰器模式中的 <code>ConcretComponent</code> 的角色，它实现了 <code>Cache</code> 接口缓存的基本能力。除 <code>PerpetualCache</code> 以外的其它 <code>Cache</code> 接口实现都是装饰器，扮演的是装饰器模式中的 <code>ConcreteDecorator</code> 的角色，不同装饰器提供了不同的功能扩展。</p><p>例如，<code>BlockingCache</code> 在原有缓存实现之上添加了阻塞线程的特性，<code>FifoCache</code> 添加了先进先出的特性，<code>LruCache</code> 添加了最近最少适用的淘汰机制等等。</p><h4 id=解析器模块>解析器模块</h4><p>MyBatis 中需要解析的配置文件分为两部分：一个是 <code>mybatis-config.xml</code> 配置文件，另一个是 <code>Mapper.xml</code> 配置文件。这两个文件都是由 MyBatis 的解析器模块进行解析的，其中主要是依赖 XPath 实现 XML 配置文件以及各类表达式的高效解析。</p><h4 id=事务管理模块>事务管理模块</h4><p>MyBatis 对数据库中的事务进行了一层简单的抽象，提供了简单易用的事务接口和实现。在 MyBatis 中，数据库事务被抽象为 <code>Transaction</code> 接口，它定义了提交事务、回滚事务以及获取底层数据库连接的方法。<code>TransactionFactory</code> 则是用于创建 <code>Transaction</code> 对象的工厂接口。</p><p><img src=/images/notebook/MyBatis/Transaction.png alt></p><h4 id=反射工具模块>反射工具模块</h4><p>MyBatis 在 Java 反射的基础上进行了封装，为上层使用方提供了更加灵活、方便的 API 接口。反射工具箱的具体代码位于 <code>org.apache.ibatis.reflection</code> 包中。<code>Reflector</code> 是整个模块的基础，在使用反射模块操作一个 <code>Class</code> 之前，MyBatis 会将 <code>Class</code> 封装成一个 <code>Reflector</code>，为了提高反射执行的效率，<code>Reflector</code> 中缓存了 <code>Class</code> 的元数据信息。</p><p><code>Reflector</code> 将类的属性与方法等信息记录在自己的核心字段中，它的核心字段如下所示：</p><p><img src=/images/notebook/MyBatis/Reflector.png alt></p><p><code>Reflector</code> 的构造函数以 <code>Class</code> 为参数，在构造方法内部会解析传入的 <code>Class</code> 对象，填充以上字段。</p><p>同样，为了提高 <code>Reflector</code> 的初始化速度，MyBatis 提供了 <code>ReflectorFactory</code> 工厂接口。该接口的默认实现 <code>DefaultReflectorFactory</code> 在内存中通过 <code>ConcurrentHashMap&lt;Class&lt;?>, Reflector></code>（即 <code>reflectorMap</code>）对 <code>Reflector</code> 对象进行了缓存，该接口的核心方法 <code>findForClass(Class&lt;?> type)</code> 就会根据传入 <code>Class</code> 查找 <code>reflectorMap</code> 缓存，若查找成功，则直接返回，否则创建相应的 <code>Reflector</code> 对象并放入缓存，以便下次使用。</p><p><code>ObjectFactory</code> 是 MyBatis 中的对象反射工厂接口，它提供了两个不同的 <code>create</code> 方法，我们可以用它来创建指定类型的对象。<code>DefaultObjectFactory</code> 是此接口的默认实现，底层会利用反射根据入参列表选择合适的构造函数实例化对象。我们可以在 <code>mybatis-config.xml</code> 中配置自定义的 <code>ObjectFactory</code> 接口的扩展实现类，达到自定义功能扩展的目的。</p><p>反射模块内还提供了几个用于解析属性的工具类：</p><ul><li><code>PropertyTokenizer</code>：负责解析由 <code>.</code> 和 <code>[]</code> 构成的表达式，支持对嵌套多层表达式的处理</li><li><code>PropertyCopier</code> 用于属性拷贝</li><li><code>PropertyNamer</code> 可以将方法名转换为属性名，亦能检测一个方法是否为 setter 或 getter 方法</li></ul><p>此外，反射模块还有 <code>MetaClass</code>，它封装了 Class 的元数据信息，以及 <code>ObjectWrapper</code>，它封装了对象的元数据信息。</p><h3 id=核心处理层>核心处理层</h3><p>MyBatis 的核心实现，涉及 MyBatis 的初始化以及执行一条 SQL 语句的全流程。</p><h4 id=配置解析>配置解析</h4><p>MyBatis 中有三处可以添加配置信息的地方：<code>mybatis-config.xml</code> 配置文件、<code>Mapper.xml</code> 配置文件，以及 <code>Mapper</code> 接口中的注解信息。MyBatis 会在初始化的时候加载这些配置信息，并在解析完成之后，将解析得到的配置到对象保存到 <code>Configuration</code> 对象中。</p><p>配置解析过程中用到了设计模式中的建造者模式（<a href=../../reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F>设计模式读书笔记之建造者模式</a>）。</p><h5 id=mybatis-configxml-解析>mybatis-config.xml 解析</h5><p>MyBatis 初始化的第一个步骤就是加载和解析 <code>mybatis-config.xml</code> 这个全局配置文件。入口位于 <code>XMLConfigBuilder</code> 这个 Builder 对象，它由 <code>SqlSessionFactoryBuilder.build()</code> 方法创建。</p><p><code>XMLConfigBuilder</code> 会将 <code>mybatis-config.xml</code> 解析为对应的 <code>Configuration</code> 全局配置对象，然后 <code>SqlSessionFactoryBuilder</code> 会根据得到的 <code>Configuration</code> 对象创建一个 <code>DefaultSqlSessionFactory</code> 供上层使用。</p><p><code>XMLConfigBuiler</code> 继承自 <code>BaseBuilder</code> 抽象类，该类的继承关系如下：</p><p><img src=/images/notebook/MyBatis/BaseBuilder.png alt></p><p><code>BaseBuilder</code> 提供了三方面的能力：</p><ul><li>关联 <code>Configuration</code> 对象</li><li>解析别名</li><li>解析 <code>TypeHandler</code></li></ul><p><code>mybatis-config.xml</code> 文件的解析是由 <code>XMLConfigBuilder.parse()</code> 方法触发的，其中的 <code>parseConfiguration()</code> 方法定义了解析 <code>mybatis-config.xml</code> 的完整流程。其核心步骤如下：</p><p><img src=/images/notebook/MyBatis/parseConfiguration.png alt></p><h5 id=mapperxml-解析>Mapper.xml 解析</h5><p><code>mybatis-config.xml</code> 中可以定义多个 <code>&lt;mapper></code> 标签，指定 <code>Mapper</code> 配置文件的位置。MyBatis 会为每个 <code>Mapepr.xml</code> 映射文件都创建一个 <code>XMLMapperBuilder</code> 实例，从而完成相关解析工作。</p><h4 id=sql-解析与-scripting-模块>SQL 解析与 scripting 模块</h4><p>动态 SQL 是 MyBatis 最大的亮点，这个模块负责动态生成 SQL。具体来说，它会根据运行时用户传入的实参解析动态 SQL 中的标签，并形成 SQL 模板，然后处理 SQL 模板中的占位符，用实参填充占位符，得到真正可执行的 SQL 语句。</p><p>scripting 模块是 MyBatis 中动态生成 SQL 的核心模块，它会根据用户传入的实参解析动态 SQL 中的标签，形成 SQL 模板，然后用运行时的实参填充模板中的占位符，得到真正可以在数据库中执行的 SQL 语句。</p><h5 id=dynamiccontext>DynamicContext</h5><p>MyBatis 解析一条动态 SQL 语句的整个流程可能会非常长，其中涉及多层方法的调用、方法的递归、复杂的循环等，其中产生的中间结果需要有一个地方进行存储，那就是 <code>DynamicContext</code> 上下文对象。</p><p><code>DynamicContext</code> 有两个核心属性：一个是 <code>sqlBuilder</code> 字段（<code>StringJoiner</code> 类型），用来记录解析之后的 SQL 语句；另一个是 <code>bindings</code> 字段（<code>ContextMap</code> 类型），用来记录上下文中的一些 KV 信息。<code>ContextMap</code> 是 <code>DynamicContext</code> 定义的一个内部类，用来记录运行时用户传入的、用来替换“#{}”占位符的实参。</p><h5 id=sqlnode>SqlNode</h5><p>MyBatis 在处理动态 SQL 语句的时候，会将动态 SQL 标签解析为 <code>SqlNode</code> 对象，多个 <code>SqlNode</code> 对象通过组合模式（<a href=../../reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B9%9D%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F>设计模式读书笔记之组合模式</a>）组成树形结构供上层使用。<code>SqlNode</code> 接口充当的就是组合模式中的 <code>Component</code> 的角色，它的实现类非常多，很多都对应着一个动态 SQL 标签（组合模式中的 <code>Leaf</code> 角色），少数实现类扮演着组合模式中的 <code>Composite</code> 角色（比如 <code>MixedSqlNode</code>）。</p><p><img src=/images/notebook/MyBatis/SqlNode.png alt></p><ul><li><code>StaticTextSqlNode</code>用于表示非动态的 SQL 片段，其中维护了一个 <code>text</code> 字段（<code>String</code> 类型），用于记录非动态 SQL 片段的文本内容。</li><li><code>MixedSqlNode</code> 在整个 <code>SqlNode</code> 树中充当了树枝节点，也就是扮演了组合模式中 <code>Composite</code> 的角色，其中维护的 <code>List&lt;SqlNode></code> 集合了记录 <code>MixedSqlNode</code> 下所有的子 <code>SqlNode</code> 对象。</li><li><code>TextSqlNode</code> 抽象了包含 “${}”占位符的动态 SQL 片段，它通过一个 <code>text</code> 字段（<code>String</code> 类型）来记录包含“${}”占位符的 SQL 文本内容。</li><li><code>IfSqlNode</code> 对应了动态 SQL 语句中的 <code>&lt;if></code> 标签，MyBatis 的 标签的 <code>test</code> 属性可以指定一个表达式，当表达式成立时，<code>&lt;if></code> 标签内的 SQL 片段才会出现在完整的 SQL 语句中。</li><li><code>TrimSqlNode</code> 对应 MyBatis 动态 SQL 语句中的 <code>&lt;trim></code> 标签。在使用 <code>&lt;trim></code> 标签的时候，我们可以指定 <code>prefix</code> 和 <code>suffix</code> 属性添加前缀和后缀，也可以指定 <code>prefixesToOverrides</code> 和 <code>suffixesToOverrides</code> 属性来删除多个前缀和后缀（使用“|”分割不同字符串）。</li><li><code>ForeachSqlNode</code> 对应 MyBatis 动态 SQL 语句中的 <code>&lt;foreach></code> 标签。我们可以在动态 SQL 语句中使用 <code>&lt;foreach></code> 标签对一个集合进行迭代。在迭代过程中，可以通过 <code>index</code> 属性值指定的变量作为元素的下标索引（迭代 <code>Map</code> 集合的话，就是 <code>Key</code> 值），使用 <code>item</code> 属性值指定的变量作为集合元素（迭代 <code>Map</code> 集合的话，就是 <code>Value</code> 值）。另外，我们还可以通过 <code>open</code> 和 <code>close</code> 属性在迭代开始前和结束后添加相应的字符串，也可以使用 <code>separator</code> 属性自定义分隔符。</li><li><code>ChooseSqlNode</code> 对应 MyBatis 动态 SQL 语句中的 <code>&lt;choose></code> 标签。其内部的<code>&lt;when></code> 标签会被解析成 <code>IfSqlNode</code> 对象，<code>&lt;otherwise></code> 标签会被解析成 <code>MixedSqlNode</code> 对象。</li><li><code>VarDeclSqlNode</code> 抽象了 <code>&lt;bind></code> 标签，其核心功能是将一个 OGNL 表达式的值绑定到一个指定的变量名上，并记录到 <code>DynamicContext</code> 中。</li></ul><h5 id=sqlsourcebuilder>SqlSourceBuilder</h5><p>动态 SQL 语句在被解析成 <code>SqlNode</code> 对象后，会经由 <code>SqlSourceBuilder</code> 进一步处理。<code>SqlSourceBuilder</code> 的核心操作主要有两个：</p><ul><li>解析“#{}”占位符中携带的各种属性。</li><li>将 SQL 语句中的“#{}”占位符替换成“?”占位符，替换之后的 SQL 语句就可以提交给数据库进行编译了。</li></ul><p><code>SqlSourceBuilder</code> 完成了“#{}”占位符的解析和替换之后，会将最终的 SQL 语句以及得到的 <code>ParameterMapping</code> 集合封装成一个 <code>StaticSqlSource</code> 对象并返回。</p><h5 id=sqlsource>SqlSource</h5><p>动态 SQL 经过 <code>SqlNode</code> 和 <code>SqlSourceBuilder</code> 之后，最终会由 <code>SqlSource</code> 进行最后的处理。<code>SqlSource</code> 接口中只定义了一个 <code>getBoundSql()</code> 方法，它控制着动态 SQL 语句解析的整个流程。它会根据从 <code>Mapper.xml</code> 映射文件（或注解）解析到的 SQL 语句以及执行 SQL 时传入的实参，返回一条可执行的 SQL。接口继承关系如下：</p><p><img src=/images/notebook/MyBatis/SqlSource.png alt></p><h6 id=dynamicsqlsource>DynamicSqlSource</h6><p><code>DynamicSqlSource</code> 主要负责解析动态 SQL 语句以及“#{}”占位符。</p><p>动态 SQL 的判断标准：如果某个 SQL 片段包含了未解析的“${}”占位符或动态 SQL 标签，则为动态 SQL 语句。但是，只包含“#{}”占位符的 SQL 并不是动态 SQL。</p><h6 id=rawsqlsource>RawSqlSource</h6><p>与 <code>DynamicSqlSource</code> 不同，<code>RawSqlSourc</code> 处理的是非动态 SQL 语句，它解析 SQL 语句的时机是在初始化流程中。</p><h6 id=staticsqlsource>StaticSqlSource</h6><p>无论是 <code>DynamicSqlSource</code> 还是 <code>RawSqlSource</code>，底层都依赖 <code>SqlSourceBuilder</code> 解析之后得到的 <code>StaticSqlSource</code> 对象。<code>StaticSqlSource</code> 中维护了解析之后的 SQL 语句以及“#{}”占位符的属性信息。</p><h4 id=sql-执行>SQL 执行</h4><p>在 MyBatis 中，执行一条 SQL 的核心组件有 <code>Executor</code>、<code>StatementHandler</code>、<code>ParameterHandler</code> 和 <code>ResultSetHandler</code>。其中，<code>Executor</code> 会调用事务管理模块实现事务的相关通知，同时会通过缓存模块的一级缓存和二级缓存。SQL 语句的真正执行由 <code>StatementHandler</code> 实现，它会依赖 <code>ParameterHandler</code> 进行 SQL 模板的数据绑定，然后传到数据库执行，从数据库拿到 <code>ResultSet</code>。最后，<code>ResultSetHandler</code> 会将 <code>ResultSet</code> 映射为 Java 对象返回给调用方。下图展示了一条 SQL 执行的大致过程：</p><p><img src=/images/notebook/MyBatis/sql-execution-process.png alt="SQL 语句执行过程"></p><h5 id=executor>Executor</h5><p>MyBatis 中有多个 <code>Executor</code> 接口的实现类，如下图所示：</p><p><img src=/images/notebook/MyBatis/Executor.png alt></p><h6 id=baseexecutor>BaseExecutor</h6><p><code>BaseExecutor</code> 使用模板方法模式实现了 <code>Executor</code> 接口中的方法，其中，不变的部分是事务管理和缓存管理两部分的内容，由 <code>BaseExecutor</code> 实现；变化的部分则是具体的数据库操作，由 <code>BaseExecutor</code> 子类实现，涉及 <code>doUpdate()</code>、<code>doQuery()</code>、<code>doQueryCursor()</code> 和 <code>doFlushStatement()</code> 这四个方法。</p><h6 id=simpleexecutor>SimpleExecutor</h6><p><code>SimpleExecutor</code> 是 <code>Executor</code> 接口最简单的实现。</p><h6 id=reuseexecutor>ReuseExecutor</h6><p>重用 <code>Statement</code> 对象是一种常见的优化手段，不仅可以减少 SQL 预编译开销，还能降低 <code>Statement</code> 对象的创建和销毁频率，这在一定程度上可以提升系统性能。<code>ReuseExecutor</code> 就实现了重用 <code>Statement</code> 的优化。</p><p><code>ReuseExecutor</code> 中的 <code>do*()</code> 方法实现与 <code>SimpleExecutor</code> 实现完全一样，两者唯一的区别在于其中依赖的 <code>prepareStatement()</code> 方法：<code>SimpleExecutor</code> 每次都会创建全新的 <code>Statement</code> 对象，<code>ReuseExecutor</code> 则是先尝试查询 <code>statementMap</code> 缓存，如果缓存命中，则会重用其中的 <code>Statement</code> 对象。</p><h6 id=batchexecutor>BatchExecutor</h6><p>批处理是 JDBC 编程中的一种常见优化手段。不过，有一点需要特别注意：每次向数据库发送的 SQL 语句的条数是有上限的，如果批量执行的时候超过这个上限值，数据库就会抛出异常，拒绝执行这一批 SQL 语句，所以我们需要控制批量发送 SQL 语句的条数和频率。<code>BatchExecutor</code> 是用于实现批处理的 <code>Executor</code> 实现类。</p><h6 id=cachingexecutor>CachingExecutor</h6><p><code>CachingExecutor</code> 是一个 <code>Executor</code> 装饰器实现，会在其他 <code>Executor</code> 的基础之上添加二级缓存的相关功能。</p><h4 id=插件>插件</h4><p>我们可以通过自定义的插件来扩展 MyBatis，或者改变 MyBatis 的默认行为。插件模块中最核心的接口就是 <code>Interceptor</code> 接口，所有 MyBatis 插件都必须要实现的这个接口。</p><h3 id=接口层>接口层</h3><p>接口层中的接口都是 MyBatis 最常使用的一些接口，比如 <code>SqlSession</code> 和 <code>SqlSessionFactory</code> 等，其中最核心的接口是 <code>SqlSession</code>，我们可以通过它获取 <code>Mapper</code> 代理、执行 SQL 语句、控制事务开关等。</p><h4 id=sqlsession>SqlSession</h4><p><code>SqlSession</code> 是 MyBatis 对外提供的一个 API 接口，整个 MyBatis 接口层也是围绕 <code>SqlSession</code> 接口展开的，SqlSession 接口中定义了下面几类方法。</p><ul><li><p><code>select*()</code> 方法：用来执行查询操作的方法，<code>SqlSession</code> 会将结果集映射成不同类型的结果对象，例如，<code>selectOne()</code> 方法返回单个 Java 对象，<code>selectList()</code>、<code>selectMap()</code> 方法返回集合对象。</p></li><li><p><code>insert()</code>、<code>update()</code>、<code>delete()</code> 方法：用来执行 DML 语句。</p></li><li><p><code>commit()</code>、<code>rollback()</code> 方法：用来控制事务。</p></li><li><p><code>getMapper()</code>、<code>getConnection()</code>、<code>getConfiguration()</code> 方法：分别用来获取接口对应的 <code>Mapper</code> 对象、底层的数据库连接和全局的 <code>Configuration</code> 配置对象。</p></li></ul><p>MyBatis 提供了两个 <code>SqlSession</code> 接口的实现类，还提供了 <code>SqlSessionFactory</code> 来创建 <code>SqlSession</code> 对象。相关类的关系如下：</p><p><img src=/images/notebook/MyBatis/SqlSession-interface.png alt></p><p>其中，<code>DefaultSqlSession</code> 是 <code>SqlSession</code> 的默认实现，它维护了一个 <code>Executor</code> 对象，用来完成数据库操作以及事务管理。</p><p><code>DefaultSqlSessionFactory</code> 是创建 <code>DefaultSqlSession</code> 的具体实现。</p><p><code>SqlSessionManager</code> 同时实现了 <code>SqlSession</code> 和 <code>SqlSessionFactor</code>y 两个接口，也就是说，它同时具备操作数据库的能力和创建 <code>SqlSession</code> 的能力。</p></div><footer class=entry-footer><div class="container sep-before"><div class=categories><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5A2 2 0 014 3H9l2 3h9a2 2 0 012 2z"/></svg><span class=screen-reader-text>分类: </span><a class=category href=/categories/notebook/>Notebook</a></div><div class=tags><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2H12l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=screen-reader-text>标签: </span><a class=tag href=/tags/mybatis/>MyBatis</a></div></div></footer></article></main><footer id=footer class=footer><div class="container sep-before"><section class="widget widget-social_menu sep-after"><nav aria-label=社交菜单><ul><li><a href=https://github.com/zhannicholas target=_blank rel="noopener me"><span class=screen-reader-text>Open Github account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li><a href=https://t.me/zhannicholas target=_blank rel="noopener me"><span class=screen-reader-text>Open Telegram account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><title>Telegram icon</title><path d="M23.91 3.79 20.3 20.84c-.25 1.21-.98 1.5-2 .94l-5.5-4.07-2.66 2.57c-.3.3-.55.56-1.1.56-.72.0-.6-.27-.84-.95L6.3 13.7.85 12c-1.18-.35-1.19-1.16.26-1.75l21.26-8.2c.97-.43 1.9.24 1.53 1.73z"/></svg></a></li><li><a href=mailto:zhan_nicholas@outlook.com target=_blank rel="noopener me"><span class=screen-reader-text>Contact via Email</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></li><li><a href=https://linkedin.com/in/%e4%bc%9f%e4%bc%9f-%e8%a9%b9-27871a104 target=_blank rel="noopener me"><span class=screen-reader-text>Open Linkedin account in new tab</span><svg class="icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg></a></li></ul></nav></section><div class=copyright><p>&copy; 2018-2021 Nicholas Zhan</p></div></div></footer></div></div><script>window.__assets_js_src="/assets/js/"</script><script src=/assets/js/main.c3bcf2df.js></script><script src=/js/custom.js></script></body></html>