<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on Nicholas Z.</title>
    <link>https://zhannicholas.github.io/</link>
    <description>Recent content in Home on Nicholas Z.</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 25 Sep 2019 19:24:06 +0800</lastBuildDate>
    
	<atom:link href="https://zhannicholas.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://zhannicholas.github.io/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zhannicholas.github.io/about/</guid>
      <description>学习笔记 踩坑日记 生活杂记 &amp;hellip;</description>
    </item>
    
    <item>
      <title>初见Redis</title>
      <link>https://zhannicholas.github.io/blogs/%E5%88%9D%E8%A7%81redis/</link>
      <pubDate>Wed, 25 Sep 2019 19:24:06 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E5%88%9D%E8%A7%81redis/</guid>
      <description>Redis是一个位于内存中的数据结构存储系统，可用作数据库、缓存和消息中间件。它支持的数据结构有：string、hash、list、set、</description>
    </item>
    
    <item>
      <title>Linux添加用户并授予root权限的简单方法</title>
      <link>https://zhannicholas.github.io/blogs/linux%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8E%88%E4%BA%88root%E6%9D%83%E9%99%90%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 13 Feb 2019 16:29:45 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/linux%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8E%88%E4%BA%88root%E6%9D%83%E9%99%90%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/</guid>
      <description>快速方法 使用root操作 Step 1: 添加一个用户 adduser username Step 2: 授予root权限 usermod -aG sudo username 但是&amp;hellip;&amp;hellip; 有些时候，这并不管用 在vultr</description>
    </item>
    
    <item>
      <title>《设计模式的艺术》学习笔记之十三：代理模式</title>
      <link>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%89%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 27 Oct 2018 21:41:48 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%89%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>代理模式（Proxy Pattern）:给某一个对象提供一个代理，并由代理对象控制对原对象的引用。 代理模式中引入了一个新的代理对象，代理对象可</description>
    </item>
    
    <item>
      <title>《设计模式的艺术》读书笔记之十二：享元模式</title>
      <link>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%BA%8C%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 17 Oct 2018 12:24:25 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%BA%8C%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid>
      <description>享元模式（Flyweight Pattern）：运行共享技术有效的支持大量 细粒度 对象的复用，又称轻量级模式。 享元模式以共享的方式高效的支持大量</description>
    </item>
    
    <item>
      <title>《设计模式的艺术》读书笔记之十一：外观模式</title>
      <link>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 15 Oct 2018 10:39:37 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>外观模式（Facade Pattern）：外部与一个子系统的通信通过一个统一的外观角色进行，为子系统中的一组接口提供一个统一的入口。外观模式又</description>
    </item>
    
    <item>
      <title>《设计模式的艺术》学习笔记之十：装饰模式</title>
      <link>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 15 Oct 2018 05:23:56 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</guid>
      <description>装饰模式（Decotator Pattern）：动态的给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更加灵活。 装饰模</description>
    </item>
    
    <item>
      <title>《设计模式的艺术》读书笔记之九：组合模式</title>
      <link>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B9%9D%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 13 Oct 2018 11:16:37 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B9%9D%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description>组合模式（Composite Pattern）：组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构。组合模式对单个对象（叶子对象）</description>
    </item>
    
    <item>
      <title>《设计模式的艺术》读书笔记之八：桥接模式</title>
      <link>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AB%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 09 Oct 2018 08:48:04 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AB%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>桥接模式（Bridge Pattern）：将类的功能层次结构（抽象部分）和实现层次结构（实现部分）分离，使二者能够 独立 的变化，并在二者之间搭建</description>
    </item>
    
    <item>
      <title>《设计模式的艺术》读书笔记之七：适配器模式</title>
      <link>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%83%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 08 Oct 2018 14:53:10 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%83%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>适配器模式（Adapter Pattern）：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，又称包装器（Wrappe</description>
    </item>
    
    <item>
      <title>《设计模式的艺术》读书笔记之六：建造者模式</title>
      <link>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 07 Oct 2018 09:04:12 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>建造者模式（Builder Pattern）：将一个复杂的对象的构建与它的表示分离，使得同样的创建过程可以创建不同的表示。建造者模式又称为生成</description>
    </item>
    
    <item>
      <title>《设计模式的艺术》读书笔记之五：原型模式</title>
      <link>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 06 Oct 2018 11:35:30 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>原型模式（Prototype Pattern）：使用原型实例指定创建对象，并通过克隆这些原型得到新的对象。 原型模式的工作原理就是：将一个原型对</description>
    </item>
    
    <item>
      <title>《设计模式的艺术》读书笔记之四：抽象工厂模式</title>
      <link>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%9B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 05 Oct 2018 13:17:22 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%9B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列相关或者相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称Ki</description>
    </item>
    
    <item>
      <title>《设计模式的艺术》读书笔记三：工厂方法模式</title>
      <link>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 Oct 2018 08:40:29 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>工厂方法模式（Factory Method Pattern）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化，这让一个类的实例化延迟到了其子类。工</description>
    </item>
    
    <item>
      <title>《设计模式的艺术》读书笔记二：简单工厂模式</title>
      <link>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 02 Oct 2018 11:04:22 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>简单工厂模式（Simple Factory Pattern）：定义一个工厂类，工厂类根据参数返回不同的实例，被创建的实例通常具有共同的父类。由于创建实例的方</description>
    </item>
    
    <item>
      <title>《设计模式的艺术》读书笔记一：单例模式</title>
      <link>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 Oct 2018 13:28:15 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类就是单例类。 从单例模式</description>
    </item>
    
    <item>
      <title>面向对象设计的7个原则</title>
      <link>https://zhannicholas.github.io/blogs/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%847%E4%B8%AA%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sat, 29 Sep 2018 20:51:23 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%847%E4%B8%AA%E5%8E%9F%E5%88%99/</guid>
      <description>面向对象设计的7个原则 面向对象设计存在7个原则。在设计中使用这些原则，有助于提高设计模型的灵活性和可维护性，提高类的內聚度，降低类之间的耦合</description>
    </item>
    
    <item>
      <title>Java Web复习笔记</title>
      <link>https://zhannicholas.github.io/blogs/java-web%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 19 Aug 2018 23:02:41 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/java-web%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>Java WEB复习笔记 这是为了准备秋招面试而对Java Web开发进行的复习。 首先，对于一个Java Web应用，它由一组Servlet、HTML页、</description>
    </item>
    
    <item>
      <title>完全平方数</title>
      <link>https://zhannicholas.github.io/blogs/perfect-squares/</link>
      <pubDate>Tue, 07 Aug 2018 07:15:52 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/perfect-squares/</guid>
      <description>这是Leetcoce上的第279个问题，解题的方法很有启发意义，以此备忘。 题目描述 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, &amp;hell</description>
    </item>
    
    <item>
      <title>Java中反转字符串的几种方法</title>
      <link>https://zhannicholas.github.io/blogs/java%E4%B8%AD%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 20 Jul 2018 13:51:14 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/java%E4%B8%AD%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</guid>
      <description>这是Leetcode上的第344题，虽然很简单，但是涉及到一些技巧，于是我决定把我试过的方法记录下来。 题目描述 请编写一个函数，其功能是将输入</description>
    </item>
    
    <item>
      <title>寻找数组中的第K个最大的元素</title>
      <link>https://zhannicholas.github.io/blogs/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Fri, 20 Jul 2018 10:33:07 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>这是Leetcode上的第215题：数组中的第k个最大元素。 问题描述 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第</description>
    </item>
    
    <item>
      <title>荷兰国旗问题</title>
      <link>https://zhannicholas.github.io/blogs/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 19 Jul 2018 22:15:46 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/</guid>
      <description>问题描述 荷兰国旗问题(Dutch national flag problem)是Dijkstra提出的一个经典的编程练习。原问题大概是这样说的： Dijkstra used the Dutch National Flag Problem* as a structured programming</description>
    </item>
    
    <item>
      <title>北邮回忆</title>
      <link>https://zhannicholas.github.io/blogs/%E5%8C%97%E9%82%AE%E5%9B%9E%E5%BF%86/</link>
      <pubDate>Wed, 18 Jul 2018 08:26:18 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E5%8C%97%E9%82%AE%E5%9B%9E%E5%BF%86/</guid>
      <description>在北邮一年的交换学习已经结束。仔细想想我这一年，好像并没有什么值得一提的。在我的印象里，第一学期的大多数时间都花在了学校开设的课程上，总是在</description>
    </item>
    
    <item>
      <title>产生均匀随机排列的两种方法</title>
      <link>https://zhannicholas.github.io/blogs/two-ways-to-produce-a-uniform-random-permutation/</link>
      <pubDate>Wed, 11 Jul 2018 12:46:30 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/two-ways-to-produce-a-uniform-random-permutation/</guid>
      <description>许多随机算法通过排列给定的输入数组来使输入随机化。这里的目标是构造数组 A 的一个随机排列。 方法一：排序 为数组的每一个元素 A[i] 分配一个随机的优先级</description>
    </item>
    
    <item>
      <title>通过偏概率0/1生成器，得到无偏概率0/1生成器</title>
      <link>https://zhannicholas.github.io/blogs/%E9%80%9A%E8%BF%8701%E6%9C%89%E5%81%8F%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%97%A0%E5%81%8F%E6%A6%82%E7%8E%87/</link>
      <pubDate>Wed, 11 Jul 2018 09:51:21 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/%E9%80%9A%E8%BF%8701%E6%9C%89%E5%81%8F%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%97%A0%E5%81%8F%E6%A6%82%E7%8E%87/</guid>
      <description>问题描述 这是《算法导论》的习题5.1-3： &amp;gt; 假设你希望以各1/2的概率输出0和1。你可以自由使用一个输出0或1的过程BIASED-RANDO</description>
    </item>
    
    <item>
      <title>配置Anaconda源</title>
      <link>https://zhannicholas.github.io/blogs/anaconda-source-configuration/</link>
      <pubDate>Sat, 07 Jul 2018 09:38:08 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/anaconda-source-configuration/</guid>
      <description>Anaconda 是一个 python 的发行版，可以用来管理 python 的包和环境，同时它包含1000+的开源package。正如那句话一样： The Most Trusted Distribution for Data Science 还有一个没有包含那么多</description>
    </item>
    
    <item>
      <title>矩阵乘法</title>
      <link>https://zhannicholas.github.io/blogs/matrix-multiplication/</link>
      <pubDate>Mon, 02 Jul 2018 08:44:56 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/matrix-multiplication/</guid>
      <description>矩阵乘法 矩阵相乘只有在第一个矩阵的列数（column）和第二个矩阵的行数（row）相同时才有定义。若 A 为 m x n 矩阵，B为 n x p 矩阵，则他们的</description>
    </item>
    
    <item>
      <title>最大子数组问题</title>
      <link>https://zhannicholas.github.io/blogs/maximum-sub-array-problem/</link>
      <pubDate>Fri, 29 Jun 2018 10:44:26 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/maximum-sub-array-problem/</guid>
      <description>问题 有一个数组A，寻找一个 A[] 的子数组 B[] ， 使得B的元素和大于A的任何一个子数组。比如A = [13, -3, 25, 20, -4, -20, -25, 18, 20, -5, 16, -5, -22, 18, -6, 8], 我们要求的 B[] 就是：[1</description>
    </item>
    
    <item>
      <title>哈希表</title>
      <link>https://zhannicholas.github.io/blogs/hashing-table/</link>
      <pubDate>Sun, 03 Jun 2018 10:49:04 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/hashing-table/</guid>
      <description>键索引搜索方法中，表中的第 i 个位置保存了键为 i 对应的项，以便达到快速访问的目的。它将键作为数组的索引，并且依赖于同一范围内不同整数的键作为表</description>
    </item>
    
    <item>
      <title>树</title>
      <link>https://zhannicholas.github.io/blogs/binary-tree/</link>
      <pubDate>Sat, 02 Jun 2018 10:07:28 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/binary-tree/</guid>
      <description>树是满足一定要求的顶点和边的非空集合。 二叉树 二叉树的每个节点至多有2个子节点。 一种表示方法： struct Node{type key; Node *lchild, *richild;} typedef Node *link; 这种表示方法只适合从根节点开始</description>
    </item>
    
    <item>
      <title>各种排序算法</title>
      <link>https://zhannicholas.github.io/blogs/sorting/</link>
      <pubDate>Wed, 30 May 2018 18:55:31 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/sorting/</guid>
      <description>学习《C算法》中排序这一部分时做的一些笔记。主要使用C++实现了书中的大部分排序算法。 开始之前 为了方便增加代码的灵活性，我采取了书中作者的部</description>
    </item>
    
    <item>
      <title>Git初探</title>
      <link>https://zhannicholas.github.io/blogs/about-git/</link>
      <pubDate>Wed, 30 May 2018 15:56:02 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/about-git/</guid>
      <description>开始 文件的三种状态 已提交(committed) 数据已经安全的保存在了本地的数据库中 已修改(modified) 修改了文件，但还没保存到数据库中</description>
    </item>
    
    <item>
      <title>约瑟夫问题</title>
      <link>https://zhannicholas.github.io/blogs/josepus-problem/</link>
      <pubDate>Sun, 27 May 2018 11:35:18 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/josepus-problem/</guid>
      <description>问题由来 这是一个很经典的问题了，大概就是说： 已知n个人（以编号1，2，3&amp;hellip;n分别表示）围成一个圆圈。 从第一个人开始报数，数到m</description>
    </item>
    
    <item>
      <title>厄拉多筛法求素数</title>
      <link>https://zhannicholas.github.io/blogs/seive-of-eratosthenes/</link>
      <pubDate>Sat, 26 May 2018 10:43:44 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/seive-of-eratosthenes/</guid>
      <description>筛法原理 给出要筛数值的范围maxn，找出maxn以内所有的素数。先用2去筛，即把2留下，把2的倍数剔除掉；再用下一个素数，也就是3筛，把3留</description>
    </item>
    
    <item>
      <title>并查集</title>
      <link>https://zhannicholas.github.io/blogs/union-find/</link>
      <pubDate>Sat, 26 May 2018 10:43:44 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/union-find/</guid>
      <description>记录一下最近学习的并查集。 问题引入 假定有一个整数对序列，其中每个整数代表某种类型的一个对象，而且将 p-q 解释为“p与q连通”。关系是可传递的，如</description>
    </item>
    
    <item>
      <title>用hugo和github pages搭建个人博客</title>
      <link>https://zhannicholas.github.io/blogs/building-your-blogsite-with-github-pages-and-hugo/</link>
      <pubDate>Tue, 15 May 2018 16:28:59 +0800</pubDate>
      
      <guid>https://zhannicholas.github.io/blogs/building-your-blogsite-with-github-pages-and-hugo/</guid>
      <description>本文主要是想记录一下自己在win10下使用hugo和github pages搭建博客的过程，备忘。 为什么我要用hugo而不用hexo呢,最主要</description>
    </item>
    
    <item>
      <title>Search</title>
      <link>https://zhannicholas.github.io/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zhannicholas.github.io/search/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Search</title>
      <link>https://zhannicholas.github.io/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zhannicholas.github.io/search/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>