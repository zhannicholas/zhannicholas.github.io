<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Leetcode on 's Digital Garden</title><link>https://zhannicholas.github.io/tags/leetcode/</link><description>Recent content in Leetcode on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 07 Aug 2018 07:15:52 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>完全平方数</title><link>https://zhannicholas.github.io/posts/leetcode/perfect-squares/</link><pubDate>Tue, 07 Aug 2018 07:15:52 +0800</pubDate><guid>https://zhannicholas.github.io/posts/leetcode/perfect-squares/</guid><description>这是Leetcoce上的第279 个问题，解题的方法很有启发意义，以此备忘。
题目描述 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, &amp;hellip;）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
示例 1:
输入: n = 12 输出: 3 解释: 12 = 4 + 4 + 4. 示例 2:
输入: n = 13 输出: 2 解释: 13 = 4 + 9. 解决方案 一个错误的方法 最开始的想法是依次对每个数进行开方操作，这样能够找到比它小的最接近它的完全平方数。代码如下：
private int numSquares1(int n){ int step = 0; while(n &amp;gt; 0){ n -= Math.pow((int)(Math.sqrt(n)), 2); step ++; } return step; } 这段代码使用的是贪心算法的思想，每次找比 n 小的最大的完全平方数。错误的原因是：这个贪心策略在这里 并不适用 。题目中就有一个反例：</description></item><item><title>寻找数组中的第K个最大的元素</title><link>https://zhannicholas.github.io/posts/leetcode/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/</link><pubDate>Fri, 20 Jul 2018 10:33:07 +0800</pubDate><guid>https://zhannicholas.github.io/posts/leetcode/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/</guid><description>这是Leetcode上的第215题：数组中的第k个最大元素。
问题描述 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
示例 1:
输入: [3,2,1,5,6,4] 和 k = 2 输出: 5 示例 2:
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 输出: 4 解决方案 提供两种解法，一种是使用快速排序的解法，一种是使用划分思想但不排序的解法。
使用排序 要找出数组中第K个最大的元素，最直观的方法就是先将原数组按照非递增顺序排序，然后返回第K个元素。我这里使用的是快速排序。
快速排序需要先对数组进行划分，划分的代码如下：
/** * 总是使用最右端的元素A[r]将数组A[p..r]划分为A[p..q - 1]、A[q]、A[q + 1..r] * A[p..q - 1] &amp;gt;= A[q] * A[q + 1..r] &amp;lt; A[q] * @param A 待划分数组 * @param p 下界 * @param r 上界 * @return q */ private int partition(int[] A, int p, int r){ int x = A[r]; // 保存最右端元素 int i = p - 1; // i最终指向A[p.</description></item><item><title>荷兰国旗问题</title><link>https://zhannicholas.github.io/posts/leetcode/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/</link><pubDate>Thu, 19 Jul 2018 22:15:46 +0800</pubDate><guid>https://zhannicholas.github.io/posts/leetcode/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/</guid><description>问题描述 荷兰国旗问题(Dutch national flag problem)是Dijkstra提出的一个经典的编程练习。原问题大概是这样说的：
Dijkstra used the Dutch National Flag Problem* as a structured programming exercise in program derivation and program proof. Given `N&amp;rsquo; objects coloured red, white or blue, sort them so that objects of the same colour are adjacent, with the colours in the order red, white and blue.
Leetcode上的第75题——分类颜色 考查的也正是这个问题。
解决方案 使用任意一种排序算法 这其实是一个对数组元素进行排序的问题，因此使用任意一种排序算法均可以达到目的。
使用计数排序 一个较为方便的排序算法是使用计数排序，统计每种颜色出现的次数，然后按照红、白、蓝(使用0,1,2代表红、白、蓝)的出现的次数排序，重写当前数组，这正是计数排序的思想。这个方法要扫描两遍数组：第一遍统计各元素出现的次数；第二遍重写当前数组。还需要开辟额外的空间来支持计数这个操作。
时间复杂度为：O(n); 空间复杂度为：O(k), k为元素的取值范围; Java实现 private void countingSort(int[] nums){ int[] c = new int[3]; int n = nums.</description></item></channel></rss>