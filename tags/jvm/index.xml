<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JVM on 's Digital Garden</title><link>https://zhannicholas.github.io/tags/jvm/</link><description>Recent content in JVM on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 21 Apr 2021 23:30:52 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/tags/jvm/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 对象的一生</title><link>https://zhannicholas.github.io/posts/java/jvm/java_object_lifecycle/</link><pubDate>Wed, 21 Apr 2021 23:30:52 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jvm/java_object_lifecycle/</guid><description>The Truth About Garbage Collection 这篇文章写得挺好的，本文的很多内容也是基于这篇文章而来。
Java 是一门面向对象的编程语言，在程序的运行过程中，不断有新的对象被创建出来，也不断有对象被回收。JVM 中的对象从创建到回收，通常会经历以下大多数状态：
Created In use (strongly reachable) Invisible Unreachable Collected Finalized Deallocated Created 对象的创建通常会经历以下几个步骤：
为对象分配空间 开始构造对象 调用父类的构造函数 初始化实例与实例变量 执行构造函数的剩余部分 这些操作的具体代价取决于 JVM 的实现，以及构造类的过程是如何实现的。对象被创建后，如果它被赋给某给变量（有变量引用了这个对象），它就会直接进入 In Use 状态。
其实以上五个步骤可以分为两个大的步骤——实例化（Instantiation）和初始化（Initialization）。为了便于理解，我举一个例子。先定义一个类 Bird，它有一个 name 属性：
public class Bird { private final String name; public Bird(String name) {this.name = name;} } 当我们想创建一个 Bird 对象时，我们会怎么做？最简单最直接的方法当然是使用 new 关键字啦。比如：
Bird eagle = new Bird(&amp;#34;eagle&amp;#34;); 这行代码包含三个部分：
声明（Declaration）：Bird eagle 声明了一个类型为 Bird 的变量，变量名为 eagle。 实例化（Instantiation）：Java 使用 new 关键字创建新对象。new 先为新对象分配内存，然后返回那块内存的引用，这个过程就是对象的实例化。 初始化（Initialization）：new 会调用构造器 Bird(&amp;quot;eagle&amp;quot;)，构造器会初始化前面创建的新对象。 In Use 若对象被至少一个强引用持有，它就处于使用中（In Use）状态。JDK 1.</description></item><item><title>HotSpot VM中的内存管理(J2SE 5.0)</title><link>https://zhannicholas.github.io/posts/java/jvm/memory_management_in_javase5/</link><pubDate>Sun, 13 Dec 2020 18:44:54 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jvm/memory_management_in_javase5/</guid><description>这篇笔记的主要内容来自Memory Management in the Java HotSpot VM 。其主要讲的是J2SE 5.0中HotSpot VM的内存管理，文章中描述了J2SE5.0中的垃圾收集器，并在如何选择和配置垃圾收集器、设置被管理内存的区域大小等方面提出了一些建议。
内存管理系统需要考虑以下三个方面：
如何分配内存。 如何识别存活对象。 如何回收死亡对象占据的空间，以便将来使用。 显式内存释放 vs 自动内存管理 动态内存分配 几乎所有的现代编程语言都采用动态内存分配(dynamic momory allocation)，即允许进程在运行时分配或释放那些无法在编译期间确定大小的对象，并且对象的存活时间可以超过创建它们的子程序的存活时间。动态分配的对象并不位于于栈(分配对象的程序的 活动记录（activation record） 或 栈帧（stack frame） )上，也没有被静态储存（对象的名字被绑定到编译或链接期间所确定的存储位置），而是位于堆（heap）中。在堆中分配对象有一些好处，它允许程序员：
动态选择新对象的大小，从而避免程序运行中出现因硬编码而出现的一些错误。 定义和使用像 list、tree、map 这样的递归数据结构。 将新创建的对象返回给父程序。例如工厂方法。 将函数作为另一个函数的返回结果。例如一些函数式编程语言中的 closure 和 suspension。 堆中分配的对象是通过 引用(reference) 来访问的。通常，引用是一个指向对象的指针，即对象在内存中的地址。然而，引用也可能间接地指向对象，例如引用指向 句柄(handle)，句柄再指向对象。句柄的优点是：在对象被移动时，只需要更新句柄中到对象的指针，而不需要更新程序中所有其它对该对象(或句柄)的引用。
显式内存释放 在一些编程语言里，程序员需要手动管理内存。手动管理内存一件非常复杂的工作，并可能出现很多错误，这些错误可能导致程序异常甚至崩溃。因此，绝大部分开发时间都被用在了调试并尝试解决这些问题上。手动回收可能会出现以下两个问题：
悬挂指针(dangling pointer)。当一个对象还被其它对象引用时，若该对象占用的内存被回收，那些指向它的引用就会称为悬挂指针。悬挂指针一旦出现，程序的行为就会变得不可预测。因为，当尝试通过悬挂指针访问原对象时，被引用的内存空间可能早已分配给其它对象。 内存泄漏(memory leak)。例如，为了释放一个单链表所占用的内存空间，我们需要回收链表中的所有节点，若只回收了头节点，其它节点就无法再被访问，它们占据的内存空间也就无法被回收。内存泄漏会不断的消耗可用内存，直至内存枯竭。 自动内存管理 自动化内存管理解决了显式内存管理中的很多问题。垃圾收集器(Garbage Collector, GC) 防止可以防止悬挂指针的出现，因为只有当一个对象不被任何其它对象引用时，这个对象才能被回收。原则上讲，GC会回收所有不可达对象，但有两点需要注意：
追踪式回收(tracing collection) 引入了“垃圾”这一定义明确的概念，但“垃圾”并不一定包括所有不再被使用的对象。 出于效率原因，某些对象可能不会被回收。 GC还解决了内存泄漏的问题，因为它会自动释放所有不再被引用的对象。
什么是垃圾收集 简而言之，垃圾收集器负责：
为新生对象分配内存。 保证不回收被引用的对象。 回收那些不再可达对象的所占据内存空间。 垃圾收集是指发现垃圾并回收的这一过程。那么何时会发生垃圾收集呢，这要看使用何种垃圾收集器(或垃圾收集算法)了。通常情况下，当堆或堆的一部分已满，或已分配的空间超过了某个阈值时，就会进行垃圾收集。
垃圾收集器的特点 一个理想的垃圾收集器应该具备以下特点：
既 安全（safe），又 完善（comprehensive）。也就是说，存活对象不能被错误的回收，并且一个垃圾不应该在经过几轮回收之后依然存在。 高效（efficient），它不会长时间暂停应用程序。 减少甚至消除内存碎片。整理（compaction） 就是一种消除碎片的方式。 可伸缩（scalable）。对于多处理器系统上的多线程应用来说，内存的分配与回收都不应该成为性能瓶颈。 设计选择 当设计或选择垃圾回收算法时，需要考虑很多点：</description></item><item><title>HotSpot引擎架构</title><link>https://zhannicholas.github.io/posts/java/jvm/hotspot_engine_architecture/</link><pubDate>Sun, 13 Dec 2020 18:43:36 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jvm/hotspot_engine_architecture/</guid><description>这篇笔记主要来自于The Java HotSpot Performance Engine Architecture ，感觉主要是在讲 JDK8中 HotSpot VM 的整体架构。
Java HotSpot VM 原来是 Sun 公司为 Java 平台实现的高性能虚拟机，是 Java SE 的基础组成部分。为了使 Java 应用达到达到最佳的性能，HotSpot 采用了很多高级技术，包括先进的内存模式、垃圾收集器和自适应优化器。
HotSpot VM架构 内存模型（Memory Model） 对象的访问定位 Java 程序通过栈上的引用（reference）操作堆上的具体对象。在早期 JVM 中，比如 Classic VM，对象的访问定位是通过 间接句柄（indirect handle） 实现的。由于引用中存放的是句柄的地址，所以在对象被移动时，只需要改变句柄中到对象实例数据的指针即可。这一点虽然可以简化垃圾回收过程中对象的重定位过程，但却成为了性能瓶颈，因为在 Java 中通过句柄访问实例变量需要进行 两次 间接访问。
在 HotSopt VM 中，对象的访问定位是通过 直接指针（direct pointers） 来实现的，只需要 一次 访问就可以获取到实例变量。当对象在内存回收过程中被移动时，垃圾收集器需要负责找到并更新所有到该对象的引用。
两字（Two-Word）的对象头 HotSpot VM 中的对象头大小为两个机器字，而 Classic VM 中的对象头为三个字。通常，Java 对象都很小，所以对象头的大小对空间消耗的影响还是很大的。对象头的第一个字（mark word）包含了 hashCode 和 GC 的状态等信息，而第二个字（kclass pointer）是一个指向对象所属类（class）的指针。只有数组对象的对象头中有第三个部分——这一部分记录了数组的大小。
以对象表示的反射数据 类、方法和其它内部反射数据都直接被表示成堆上的对象。这既简化了 VM 内部的对象模型，也允许类被为其它对象设计的垃圾回收器回收。</description></item><item><title>垃圾回收调优指南(Java SE 8)</title><link>https://zhannicholas.github.io/posts/java/jvm/garbage_collection_tuning_guide_in_javase8/</link><pubDate>Sun, 13 Dec 2020 18:40:26 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jvm/garbage_collection_tuning_guide_in_javase8/</guid><description>这篇笔记地主要内容来自Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide 。文章中介绍了一些调优目标以及 JDK 8中 Hotspot VM 提供的一些垃圾收集器，并提出了很多调优建议。
GC（Garbage Collector） 是一个内存管理工具，它通过以下操作实现了自动内存管理：
将新生对象分配到 年轻代（Young Generation），并将足够老的对象提升到 年老代（Old Generation）。 通过并发（或并行）标记阶段找出年老代中的存活对象。当整个 Java 堆的空间使用率超过阈值时，HotSpot VM 就会触发标记阶段。 通过并行复制整理存活对象，以释放堆空间，恢复可用内存。 Ergonomics Ergonomics is the process by which the Java Virtual Machine (JVM) and garbage collection tuning, such as behavior-based tuning, improve application performance.
JVM 会根据所运行平台选择默认的 GC、堆大小和运行时编译器等。此外，基于行为的调优会动态地调整堆大小以满足不同应用的要求。
基于行为的调优 Java SE 为 并行收集器 提供了两个参数以实现不同的应用行为：最大暂停时间（maximum pause time goal） 和 吞吐量（application throughput goal）。这两个参数在其它收集器中是不可用的。在某些时候，预期行为可能不会出现，因为应用需要一个至少能存放下所有存活对象的堆空间。对堆空间的最小要求可能会妨碍达成预期目标。</description></item></channel></rss>