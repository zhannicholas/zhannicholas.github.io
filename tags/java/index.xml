<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Nicholas Zhan</title><link>https://zhannicholas.github.io/tags/java/</link><description>Recent content in Java on Nicholas Zhan</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 06 Dec 2021 20:15:55 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Jit_compiler</title><link>https://zhannicholas.github.io/notebook/reading_notes/java_performance/jit_compiler/</link><pubDate>Mon, 06 Dec 2021 20:15:55 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/java_performance/jit_compiler/</guid><description>Notes from Java Performance, 2nd Edition by Scott Oaks. The just-in-time (JIT) compiler is the heart of the Java Virtual Machine; nothing controls the performance of your application more than the JIT compiler. Just-in-Time Compilers: An Overview Computers can execute only a relatively few, specific instructions, which are called machine code. All programs that the CPU executes must therefore be translated into these instruction. There are typically two kinds of</description></item><item><title>Java Performance: foundamentals</title><link>https://zhannicholas.github.io/notebook/reading_notes/java_performance/java_performance_fundamentals/</link><pubDate>Wed, 24 Nov 2021 20:52:36 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/java_performance/java_performance_fundamentals/</guid><description>Notes from Java Performance, 2nd Edition by Scott Oaks. To be a good Java Performance engineer, we need some specific knowledge. This knowledge falls into two broad categories: The performance of the Java Virtual Machine (JVM) itself: the way that the JVM is configured affects many aspects of a program’s performance. To understand how the features of the Java platform affect performance.</description></item><item><title>Java 中的原子类</title><link>https://zhannicholas.github.io/java/concurrency/java_atomic_variables/</link><pubDate>Wed, 01 Sep 2021 09:46:58 +0800</pubDate><guid>https://zhannicholas.github.io/java/concurrency/java_atomic_variables/</guid><description>一谈到原子类（或原子变量），我们可能就会想知道它和我们编程中常说的原子性（Atomicy）之间是否有关系。若一组操作具备“要么全部成功，要么</description></item><item><title>Java 中的并发队列</title><link>https://zhannicholas.github.io/java/concurrency/java_concurrent_queue/</link><pubDate>Tue, 31 Aug 2021 21:11:09 +0800</pubDate><guid>https://zhannicholas.github.io/java/concurrency/java_concurrent_queue/</guid><description>并发队列（或线程安全的队列）是在我们在进行多线程并发编程时经常使用的一种数据结构。并发队列不仅具备基本队列的所有特性，还是线程安全的。由于并</description></item><item><title>Java 中的 hashCode() 与 equals()</title><link>https://zhannicholas.github.io/java/java_lang/java-hashcode-equals-contracts/</link><pubDate>Fri, 27 Aug 2021 22:22:46 +0800</pubDate><guid>https://zhannicholas.github.io/java/java_lang/java-hashcode-equals-contracts/</guid><description>有一道经典的 Java 面试题叫：重写了 equals()，为什么还要重写 hashCode()？ 不幸的是，笔者最近也被问到这个问题的变种了。当时面试官的</description></item><item><title>Spring Ioc</title><link>https://zhannicholas.github.io/java/spring/spring-ioc/</link><pubDate>Sat, 21 Aug 2021 13:49:54 +0800</pubDate><guid>https://zhannicholas.github.io/java/spring/spring-ioc/</guid><description>Ioc（Inverse of Control），又叫 DI（Dependence Injection）。它是这样一个过程：对象声明自己的依赖，然后容器</description></item><item><title>Java 中的引用与对象可达性</title><link>https://zhannicholas.github.io/java/java_lang/references_and_reachability_in_java/</link><pubDate>Tue, 20 Apr 2021 21:40:00 +0800</pubDate><guid>https://zhannicholas.github.io/java/java_lang/references_and_reachability_in_java/</guid><description>JDK 1.2 之后，Java 将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Refere</description></item><item><title>Java 线程池</title><link>https://zhannicholas.github.io/java/concurrency/java_thread_pool/</link><pubDate>Sun, 13 Dec 2020 18:35:11 +0800</pubDate><guid>https://zhannicholas.github.io/java/concurrency/java_thread_pool/</guid><description>线程池是管理一组同构工作线程的资源池，内部主要分为四部分： 线程池管理器：负责线程池的创建、销毁、添加任务等管理工作。 工作队列（Work Que</description></item><item><title>Java 线程</title><link>https://zhannicholas.github.io/java/concurrency/java_thread/</link><pubDate>Sun, 13 Dec 2020 18:32:20 +0800</pubDate><guid>https://zhannicholas.github.io/java/concurrency/java_thread/</guid><description>进程（process）是资源分配的基本单元，而线程（thread）是程序执行的基本单元。一个进程可以包含多个线程，多个线程之间共享进程的资源</description></item><item><title>Java 中的 synchronized</title><link>https://zhannicholas.github.io/java/concurrency/synchronization/</link><pubDate>Sun, 13 Dec 2020 18:31:16 +0800</pubDate><guid>https://zhannicholas.github.io/java/concurrency/synchronization/</guid><description>Java语言提供了多种线程间通信机制（同步、while轮询、等待/通知、管道等等），其中最基础的通信方式就是 同步（synchronizati</description></item><item><title>锁</title><link>https://zhannicholas.github.io/java/concurrency/locks/</link><pubDate>Sun, 13 Dec 2020 18:29:44 +0800</pubDate><guid>https://zhannicholas.github.io/java/concurrency/locks/</guid><description>文章中涉及的源代码摘自 OpenJdk 11。 乐观锁与悲观锁 乐观锁与悲观锁是一种广义上的概念，体现了我们看待线程同步的不同角度。 乐观锁 乐观锁采用的思想是：冲</description></item><item><title>Java 代理</title><link>https://zhannicholas.github.io/java/java_lang/proxy/</link><pubDate>Sun, 13 Dec 2020 18:25:38 +0800</pubDate><guid>https://zhannicholas.github.io/java/java_lang/proxy/</guid><description>Wikipedia 中是这样描述 Proxy 的： A proxy, in its most general form, is a class functioning as an interface to something else. The proxy could interface to anything: a network connection, a large object in memory, a file, or some other resource that is expensive or impossible to duplicate. In short, a proxy is a wrapper or agent object that is being called by the</description></item><item><title>反射</title><link>https://zhannicholas.github.io/java/java_lang/reflection/</link><pubDate>Sun, 13 Dec 2020 18:22:56 +0800</pubDate><guid>https://zhannicholas.github.io/java/java_lang/reflection/</guid><description>反射(Reflection) 是Java语言的一大特性，它允许Java程序在运行过程中获取自身的相关信息，还能改变程序的内部属性。我们可以使用</description></item><item><title>Cloning Objects</title><link>https://zhannicholas.github.io/java/java_lang/cloning_objects/</link><pubDate>Sun, 13 Dec 2020 18:19:11 +0800</pubDate><guid>https://zhannicholas.github.io/java/java_lang/cloning_objects/</guid><description>通过克隆（Clone），我们可以快速构建出一个已有对象的副本。 浅克隆 VS 深克隆 浅克隆（Shadow Clone） 或 浅复制（Shallow Copy</description></item><item><title>Nested Classes</title><link>https://zhannicholas.github.io/java/java_lang/nested_classes/</link><pubDate>Sun, 13 Dec 2020 18:18:04 +0800</pubDate><guid>https://zhannicholas.github.io/java/java_lang/nested_classes/</guid><description>Java允许我们在一个类中定义另一个类，后者被称为嵌套类（nested class）。嵌套类可以分为两种： 静态内部类（static nested class</description></item><item><title>Jedis</title><link>https://zhannicholas.github.io/posts/redis/jedis/</link><pubDate>Sun, 13 Dec 2020 17:40:18 +0800</pubDate><guid>https://zhannicholas.github.io/posts/redis/jedis/</guid><description>Jedis是一个Java编写的Redis客户端，提供了完整的Redis API。Redis客户端通常需要具备三种能力：管理Redis连接、实现</description></item></channel></rss>