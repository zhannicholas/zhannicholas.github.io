<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on 's Digital Garden</title><link>https://zhannicholas.github.io/tags/java/</link><description>Recent content in Java on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 07 Dec 2021 20:00:10 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Notes from Java Performance</title><link>https://zhannicholas.github.io/library/java_performance/</link><pubDate>Tue, 07 Dec 2021 20:00:10 +0800</pubDate><guid>https://zhannicholas.github.io/library/java_performance/</guid><description>Notes from Java Performance, 2nd Edition by Scott Oaks.
Fundamentals To be a good Java Performance engineer, we need some specific knowledge. This knowledge falls into two broad categories:
The performance of the Java Virtual Machine (JVM) itself: the way that the JVM is configured affects many aspects of a program’s performance. To understand how the features of the Java platform affect performance. JVM tuning flags With a few exceptions, the JVM accepts two kinds of flags: boolean flags, and flags that require a parameter.</description></item><item><title>Java 中的 hashCode() 与 equals()</title><link>https://zhannicholas.github.io/posts/java/lang/java-hashcode-equals-contracts/</link><pubDate>Fri, 27 Aug 2021 22:22:46 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/lang/java-hashcode-equals-contracts/</guid><description>有一道经典的 Java 面试题叫：重写了 equals()，为什么还要重写 hashCode()？
不幸的是，笔者最近也被问到这个问题的变种了。当时面试官的提问点有点奇葩，问我这两个方法在被调用时谁先谁后的问题。笔者当时想，这面试官是不是八股文看多了，连这两方法调用先后都问出来了吗？严格上来说，equals() 和 hashCode() 在绝大多数情况下都是单独调用的，只有在像 HashMap 这样的数据结构的内部实现中，才会存在方法调用的先后关系。笔者当时也没完全搞清楚面试官到底想问什么，所以就象征性的回答了 hashCode() 先调用。今天，笔者突然想到这个问题，感觉当时面试官想问的是 HashMap 内部实现时对这两个方法的依赖情况。
在 Java 中，一切皆对象。并且所有的对象都直接或间接地继承自 java.lang.Object。Object 类定义了一系列 Java 对象所共有的方法，hashCode() 和 equals() 就在其中。
hashCode() {hashCode()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()) 方法用于返回对象的哈希值。Object 类定义了 hashCode() 的契约，这里我直接列出：
The general contract of hashCode is:
Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified.</description></item><item><title>Spring Ioc</title><link>https://zhannicholas.github.io/posts/java/spring/spring-ioc/</link><pubDate>Sat, 21 Aug 2021 13:49:54 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/spring/spring-ioc/</guid><description>Ioc（Inverse of Control），又叫 DI（Dependence Injection）。它是这样一个过程：对象声明自己的依赖，然后容器在创建 Bean 的时候注入这些依赖。如果不使用 IoC，我们在创建对象之前就需要先把对象的依赖创建出来，这个正向的过程会导致对象与对象之间的强耦合。如果反过来，对象不自己创建依赖，而是由 Spring 的 Ioc 容器自动装配，这就是控制反转。逆向的过程使得程序的结构变得更加灵活，没有强耦合，还有利于对象的复用。
Ioc 容器 在 Spring 中，org.springframework.context.ApplicationContext 接口就是 IoC 容器的抽象表示，它负责 Bean 的实例化、配置以及组装。那么，IoC 容器是如何知道要管理哪些 Bean 呢？答案是配置元数据（Configuration Metadata）。配置元数据可以是 XML、注解，还可以是 Java 代码。
配置元数据 Spring 的 Ioc 容器会读取配置元数据，然后根据配置元数据去实例化、配置和组装应用程序中的 Bean。在 Spring 的早期版本中，配置信息使用的是 XML。Spring 2.5 开始支持基于注解的配置，我们常用的 @Required 和 @Autowired 就是基于注解的配置。 Spring 3.0 开始支持基于 Java 代码的配置。现在，我们甚至可以同时使用 XML 和 注解去配置 Bean。
实际上，在 IoC 容器内部，这些配置元数据会被解析成 BeanDefinition 对象，BeanDefinition 封装的就是 Bean 的定义和描述信息，比如类名、构造器参数、属性值、作用域、生命周期等，容器会根据 BeanDefinition 中封装的信息来创建 Bean。
使用 BeanFactoryPostProcessor 对配置元数据进行个性化配置 在 Spring 中，BeanFactory 提供了一种管理任何类型对象的高级机制，我们经常遇到的 ApplicationContext 则是它的一个子接口。若要用一句话来描述二者的差异，那就是：BeanFactory 提供配置框架和基本功能，ApplicationContext 则是添加了更多的企业级功能。</description></item><item><title>Java 中的引用与对象可达性</title><link>https://zhannicholas.github.io/posts/java/lang/references_and_reachability_in_java/</link><pubDate>Tue, 20 Apr 2021 21:40:00 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/lang/references_and_reachability_in_java/</guid><description>JDK 1.2 之后，Java 将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）四种，这四种引用的强度依次减弱，它们与 Java 的对象回收有着很大的关系。
A reference object encapsulates a reference to some other object so that the reference itself may be examined and manipulated like any other object. Three types of reference objects are provided, each weaker than the last: soft, weak, and phantom. Each type corresponds to a different level of reachability.
这段话已经描述得很清楚了：Java 中有三种引用对象（reference object），它们封装了一些其它的对象，从而让我们可以像操作其它对象一样操作引用本身，不同引用对象的可达性不同。
除开与 Finalization 有关的类，下图展示了 java.lang.ref 包中的类结构：
Reference 对象用于维持对其它对象的引用，但 GC 仍然可以回收这些被引用的其它对象。当 GC 决定回收某个引用对象关联的对象时，它会将对应的引用对象放入与之关联的引用队列（ReferenceQueue）中，这样我们就可以得到对象被回收的通知了。</description></item><item><title>Java 代理</title><link>https://zhannicholas.github.io/posts/java/lang/proxy/</link><pubDate>Sun, 13 Dec 2020 18:25:38 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/lang/proxy/</guid><description>Wikipedia 中是这样描述 Proxy 的：
A proxy, in its most general form, is a class functioning as an interface to something else. The proxy could interface to anything: a network connection, a large object in memory, a file, or some other resource that is expensive or impossible to duplicate. In short, a proxy is a wrapper or agent object that is being called by the client to access the real serving object behind the scenes.</description></item><item><title>Java 反射</title><link>https://zhannicholas.github.io/posts/java/lang/reflection/</link><pubDate>Sun, 13 Dec 2020 18:22:56 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/lang/reflection/</guid><description>反射(Reflection) 是Java语言的一大特性，它允许Java程序在运行过程中获取自身的相关信息，还能改变程序的内部属性。我们可以使用反射获取类、接口、字段、方法的属性，也可以用反射来实例化一个对象、进行方法调用、获取或修改字段的值。
以下是Oracle官方对反射的解释：
Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.
获取Class对象 Java中共有两种类型：引用类型和 基本类型。引用类型包括：类、数组(类和数组都继承自 java.lang.Object)和接口。基本类型包括：boolean、byte、short、char、int、long、float、double。 当Java程序运行时，JVM会为每种类型实例化一个不可变的 **java.lang.Class**类，实例的很多数据都来自对应的 **.class文件。java.lang.Class**是反射API的入口，它不仅提供了获取及修改对象内部信息方法，还提供了世袭化对象的途径。有三种方式可以获取到 **Class**实例的引用：直接获取、使用 **Object**类的getClass()方法和使用 **Class**类的静态forName(String className)方法。
直接获取 对于 **A**类，我们可以直接使用 **A.class**来获取它对应的 **Class**对象，这也适用于基本类型。对于包装类，其内部的静态final变量 **TYPE**与对应基本类型的 **Class**对象是同一个。例如：
Class&amp;lt;Object&amp;gt; objectClass = Object.class; System.out.println(int.class == Integer.TYPE); // true System.out.println(int.class == Integer.class); // false System.out.println(void.class == Void.</description></item><item><title>Cloning Objects</title><link>https://zhannicholas.github.io/posts/java/lang/cloning_objects/</link><pubDate>Sun, 13 Dec 2020 18:19:11 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/lang/cloning_objects/</guid><description>通过克隆（Clone），我们可以快速构建出一个已有对象的副本。
浅克隆 VS 深克隆 浅克隆（Shadow Clone） 或 浅复制（Shallow Copy） 把原对象中成员变量为值类型的属性都复制给克隆对象，把原对象中成员变量为引用类型的引用地址也复制给克隆对象。当原对象中存在引用类型的成员变量时，该变量的地址会被原对象和克隆对象共享。
深克隆（Deep Clone） 或 深复制（Deep Copy） 将原对象中的所有类型的成员变量（无论是值类型还是引用类型）都复制一份给克隆对象。
简单来说，浅克隆和深克隆的区别就在于对引用类型的成员变量的复制：前者复制的是引用对象的地址，而后者复制的是引用对象本身。
Cloneable 接口 在 Java 中，为了实现对象的克隆，我们需要让类实现 Cloneable 接口并重写 Object 类的 clone() 方法。例如：
@Data @AllArgsConstructor public class CloneableName implements Cloneable { private String firstName; private String lastName; @Override public CloneableName clone() throws CloneNotSupportedException { return (CloneableName) super.clone(); } } @Data @AllArgsConstructor public class CloneableUser implements Cloneable { private String id; private CloneableName name; private int age; @Override public CloneableUser clone() throws CloneNotSupportedException { return (CloneableUser) super.</description></item><item><title>Nested Classes</title><link>https://zhannicholas.github.io/posts/java/lang/nested_classes/</link><pubDate>Sun, 13 Dec 2020 18:18:04 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/lang/nested_classes/</guid><description>Java允许我们在一个类中定义另一个类，后者被称为嵌套类（nested class）。嵌套类可以分为两种：
静态内部类（static nested class） 内部类（inner class） 其中内部类又可以分为三种：
非静态成员类（non-static member class） 局部内部类（local class） 匿名内部类（anonymous class） 四种嵌套类的定义如下：
class OuterClass { static class NestedClass{} // 静态嵌套类 class MemberClass{} // 非静态成员类 void m1() { class LocalClass{} // 局部内部类 new Thread(new Runnable() { // 匿名内部类 @Override public void run() { // nothing } }); } } 静态内部类 静态内部类指被声明为static的内部类，它可以单独实例化，其它的内部类需要在外部类实例化之后才能实例化。静态内部类不能和外部类同名，不能访问外部类的实例变量，只能访问外部类的类变量和类方法（包括被private修饰的类变量和类方法）。
非静态成员类 非静态成员类不被static修饰。它可以自由的访问外部类的属性和方法，无论这些属性和方法是静态的还是非静态的。但是成员类是和外部类实例相绑定的，因此不可以定义静态变量和静态方法。只有在外部类实例化之后，这个成员类才能被实例化。
局部内部类 局部内部类是指定义在一个代码块内的类，它的作用范围只限于其所在的代码块。局部内部类和局部变量类似，不能被private、public、protected和static关键字修饰，并且只能访问方法中定义为final的局部变量。局部类的其它限制和成员类基本相同。
匿名内部类 匿名内部类没有类名。不能使用关键字class、extends、implements，没有构造函数。一个匿名类一定是在new的后面，并且它必须继承其它类或实现一个接口。成员类的限制也适用于匿名类。</description></item></channel></rss>