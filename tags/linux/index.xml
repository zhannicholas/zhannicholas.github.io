<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on 's Digital Garden</title><link>https://zhannicholas.github.io/tags/linux/</link><description>Recent content in Linux on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 27 Jul 2021 10:46:48 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux 中的硬链接与软链接</title><link>https://zhannicholas.github.io/posts/linux/links_in_the_linux_filesystem/</link><pubDate>Tue, 27 Jul 2021 10:46:48 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/links_in_the_linux_filesystem/</guid><description>在 Linux 中，有一个东西叫链接文件，它有点像 Windows 中的快捷方式，可以很方便地实现文件的共享。链接主要分为两种：硬链接（hard link） 和 软连接（soft link）。链接在 Linux 非常有用，因为在 Linux 中，“every thing is a file”，链接可以带来极大的灵活性。
Inode 在开始之前，让我们先简单了解一下磁盘分区与 索引节点（inode） 。
为了方便管理和保证数据的安全，我们通常会对磁盘进行分区。每个分区都可以被单独挂载（mount）或取消挂载（umount）。每个分区都有自己的文件系统，不同分区的文件系统可以不同。在 Linux 文件系统中，文件就用 inode 表示，每个文件都有自己对应的 inode。每个分区都有一组自己的 inode ，不同分区的 inode 互不影响，因为它们位于不同的文件系统。在建立文件系统时，会建立一个 inode 表，表中包含一定数量的 inode 。每创建一个文件，系统就会分配一个 inode 号（inode number）给它，这个 inode 号就相当于文件的地址。
Linux 的文件实际上由两部分组成：数据部分和文件名部分。文件名部分保存在目录中，它包含文件的名字以及对应的 inode 号，通过 inode 号我们就可以找到数据部分的相关信息。通过分开存储文件名和文件数据，Linux 系统就能做到多个文件名关联同一个 inode 号。文件的数据部分不仅包括文件所有者、创建时间等元数据，还包括实际文件内容所在的磁盘位置。硬链接和软连接其实就是两种将多个文件名关联到同一份文件数据的方法。
硬链接 多个文件名可以指向同一个 inode 号，这些文件的关系就是硬链接的关系。简单来说，一个硬链接就是一个目录项，它关联的是文件名与 inode。由于文件本身就是一个目录项，因此一个文件至少有一个硬链接。删除硬链接时，对应 inode 的硬链接数量减一，只有当 inode 的硬链接数量为 0 时，文件才会被删除。硬链接是不能跨分区（或者跨文件系统）的，因为每个分区都有自己独立的 inode。
软连接 软链接也叫符号链接（symbolic link or symlink），它是一种特殊类型的文件。符号链接的文件内容实际上是另外一个文件（目标文件）的路径。操作系统会把对符号链接的读写操作重定向到目标文件上。由于符号链接指向的是文件路径而不是 inode，所以符号链接是可以跨分区的。删除符号链接并不会对目标文件造成任何影响。但是，如果目标文件被删除或者重命名了，符号链接就成为了死链接。
用一张图来说明硬链接与符号链接的区别：
实践 创建链接的命令是 ln targetfile linkname，命令默认创建的是硬链接，若要创建符号链接，需要加上 -s 参数，即 ln -s targetfile linkname。此外，我们可以通过 ls -l 查看文件硬链接的个数，通过 ls -i 查看文件所对应的 inode 号。</description></item><item><title>Linux 目录结构</title><link>https://zhannicholas.github.io/posts/linux/linux_directory_structure/</link><pubDate>Sat, 24 Jul 2021 21:57:59 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/linux_directory_structure/</guid><description>在平常使用 Linux 的过程中，总感觉各个目录的作用存在某种约定，似乎大家都将程序放在 /bin、/sbin、/usr/bin 或 usr/sbin 下，将配置文件放到 /etc 下，将用户的主目录放到 /home 下……深入查阅相关资料后才发现，这背后还隐藏着一个标准——Filesystem Hierarchy Standard 。本文的主要内容就来自 FHS 3.0。
仔细一想，这么做也很有道理。毕竟 Linux 是开源的，发行版众多，更有很多人在 Linux 的基础上进行定制开发。如果大家都按照自己的想法配置 Linux 系统的文件系统结构，对文件的管理将会是一个令人头疼的问题。为了避免五花八门的目录层级结构，Linux 基金会发布了 FHS（Filesystem Hierarchy Standard），标准主要规范了 Linux 系统中一级目录和部分二级目录的用途，以及各个目录应该存储什么样的数据，大多数 Linux 发行版都遵循这一标准。这样，在与 FHS 相兼容的 Linux 系统上，用户可以很方便地进行文件的管理。
区分文件 FHS 采用了两种不同的方式对文件进行区分：
可共享（sharable）vs 不可共享（unsharable） 可变（variable） vs 不可变（static） 可共享文件指那些可以共享给其它主机使用的文件，不可共享文件则相反。不可变文件包括二进制文件、库文件、文档等，文件的改变通常需要系统的管理员介入，可变文件则相反。
以下是 FHS 给出的一个例子：
sharable unsharable static /usr, /opt /etc, /boot variable /var/mail, /var/spool/news /var/run, /var/lock 根目录 Linux 将整个文件系统看成一棵树，这棵树的根节点就是根目录，用 / 表示。根目录很重要，所有的目录都是由根目录衍生出来的，它还与开机、还原、系统修复等操作有关。
FHS 建议将根目录放在不太大的分区，因为分区越大，可放入的数据就越多，出错的可能性就会增大。FHS 要求根目录下应该有以下目录：
/bin：存放供所有用户使用的完成基本维护任务的命令。这里的 bin 是 binaries 的缩写，代表二进制文件，通常是可执行的。一些常用的命令，比如 cat、ls、cp、rm 等都在这个目录下。FHS 还要求 /bin 目录不能有子目录。 /boot：存放启动 Linux 时用到的一些核心文件，比如操作系统内核、引导程序 Grub 等。 /dev：存放所有的设备文件。从此目录可以访问磁盘、内存、CD-ROM 等系统设备。dev 表示 devices。FHS 还要求 /dev 下有以下设备： /dev/null：写到这个设备的所有内容都会被丢弃，我们可以通过 &amp;gt; 重定向符号将输出流重定向到 /dev/null 来忽略输出的结果。 /dev/zero：这是一个产生数字 0 的设备，写到这个设备的所有内容都会被丢弃。无论你对它进行多少次读取，都会读到 0。 /dev/tty：表示当前进程的控制终端（如果有的话）。所以，当我们执行 echo &amp;quot;hello&amp;quot; &amp;gt; /dev/tty 时，hello 就会出现在屏幕上。tty 是 Teletype 的缩写。 /etc：存放配置文件。 /home：用户的主目录，存放用户的个人文件。除 root 用户外，每个用户的主目录均在 /home 下以用户自己的名字命名。 /lib：存放启用系统或运行 /bin 和 /sbin 目录中的命令所需的共享库。/lib目录可能会有一些变种，比如 lib32 存放 32 位程序所需的库文件，而 lib64 存放 64 位程序所需的库文件。 /media：挂载可移动设备，一般用于自动挂载 U 盘等媒体。 /mnt：临时用于挂载文件系统的地方， /opt：多数第三方软件默认会安装到此位置。这里的 opt 是 optional 的缩写。 /root：root 用户主目录的默认位置。 /run：存放系统启动后与系统的信息数据，包括 PID(process identifier) 文件，PID 文件通常命名为 &amp;lt;program-name&amp;gt;.</description></item><item><title>Linux/Unix 中的文件类型</title><link>https://zhannicholas.github.io/posts/linux/file_types_in_linux_or_unix/</link><pubDate>Thu, 22 Jul 2021 09:20:30 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/file_types_in_linux_or_unix/</guid><description>在 Windows 中，文件类型是根据扩展名来确定的。例如：a.pdf 是一个 pdf 文件，而 b.txt 是一个 txt 文件。但在 Linux/Unix 中，文件类型与文件扩展名没有关系，它们是两个完全不同的概念。Linux/Unix 将一切都看作是文件，了解文件类型有助于我们对它们进行高效的管理。
POSIX 中定义了七种标准的文件类型：
普通文件（regular file） 目录（directory） 符号链接（symbolic link） 命名管道（FIFO special file or named pipe） 套接字（socket） 字符设备（character special file） 块设备（block special file） 此外，部分 Linux/Unix 操作系统发行版中可能还有 POSIX 规定以外的文件类型，比如 Solaris 中的 door 类型。
在 Linux/Unix 文件系统中，文件的元数据存储在一个被称为 inode 的数据结构中，每个文件都有一个对应的 inode。我们可以使用 stat 命令来查看某个文件的 inode 信息。若只需要查看文件类型，stat输出内容未免太多了点，这个时候我们可以使用 file 命令或者 ll(或 ls -l) 命令。file 命令会直接展示文件类型，而 ll 命令的文件类型隐藏在输出的第一个字母中，以下面输出为例：
drwxr-xr-x 4 ubuntu ubuntu 4096 Feb 24 23:28 test ls -l 命令中的参数 l 表示 “use a long listing format”，该输出的内容从左到右分别是：文件类型（d）、权限（rwxr-xr-x）、硬链接个数（4）、所有者（ubuntu）、所属组（ubuntu）、文件大小（4096）、上次修改时间（Feb 24 23:28）和文件名（test）。其中权限又分为三部分，从左到右分别是所有者权限（rwr）、所属组权限（r-x）和其他人权限（r-x）。我们这里主要关心的是文件类型，即输出中的第一个字母。ls 的文档给出了 13 个字母，用来标识不同的文件类型：</description></item><item><title>Linux添加用户并授予root权限的简单方法</title><link>https://zhannicholas.github.io/posts/linux/linux%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8E%88%E4%BA%88root%E6%9D%83%E9%99%90%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/</link><pubDate>Wed, 13 Feb 2019 16:29:45 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/linux%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8E%88%E4%BA%88root%E6%9D%83%E9%99%90%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/</guid><description>快速方法 使用root操作
Step 1: 添加一个用户 adduser username Step 2: 授予root权限 usermod -aG sudo username 但是&amp;hellip;&amp;hellip; 有些时候，这并不管用
在vultr新租的Debian VPS上，我想添加sarkar这个用户，并授予它root权限。依然执行了上面的命令，但可怜的sarkar还是一个普通用户。解决方案如下：
Step1: 安装sudo # apt-get install sudo Step2: 修改/etc/sudoers # cd /etc # chmod +w sudoers # vim sudoers 找到下面内容：
# User privilege specification root ALL=(ALL:ALL) ALL 在后面添加一行，声明sarkar的权限：
# User privilege specification root ALL=(ALL:ALL) ALL sarkar ALL=(ALL:ALL) ALL 保存并退出。然后：
# chmod -w sudoers 使/etc/sudoers再次成为不可写的状态。
现在，sarkar就具有root权限了。</description></item></channel></rss>