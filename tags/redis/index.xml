<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Redis on 's Digital Garden</title><link>https://zhannicholas.github.io/tags/redis/</link><description>Recent content in Redis on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 19 Aug 2021 09:52:38 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/tags/redis/index.xml" rel="self" type="application/rss+xml"/><item><title>Redis 中的 key 过期与淘汰机制</title><link>https://zhannicholas.github.io/posts/redis/key_expiration_and_eviction_in_redis/</link><pubDate>Thu, 19 Aug 2021 09:52:38 +0800</pubDate><guid>https://zhannicholas.github.io/posts/redis/key_expiration_and_eviction_in_redis/</guid><description>作为一个内存数据库，Redis 的容量肯定是有限的。如果 Redis 允许我们不断写入数据而又不作任何清理工作的话，内存迟早要被耗尽。此外，若我们在 Redis 中创建了一个不带过期时间的 key，这个 key 即使不被使用，它也会在我们使用 DEL 命令删除它之前一直存在于 Redis 中，这可不是一件好事儿。所以，为 key 设置一个过期时间还是很有必要的。那么，Redis 是如何让 key 过期的呢，它又是如何淘汰过期的 key 的呢？这就是本文要将的主要内容。
key 过期 我们可以在创建 key 时指定它的存活时间，也可以用 EXPIRE key seconds [NX|XX|GT|LT] 命令给 key 设置存活时间。当 key 过期时，它会被自动删除。
Redis 使用 volatile 这个术语来描述带有过期时间的 key，我们会在 key 的淘汰策略中再次与这个术语见面。对于不带过期时间的 key，Redis 也有一个专门的术语，那就是 persistent。
相关命令 Redis 支持不少与 key 过期有关的命令，包括为 key 设置过期时间、查看 key 还有多久过期和移除 key 的过期时间。
为 key 设置过期时间 相关命令有：
EXPIRE：设置 key 的存活时间，单位为秒 PEXPIRE：设置 key 的存活时间，单位为毫秒 EXPIREAT：设置 key 过期的 UNIX 时间戳，单位为秒 PEXPIREAT：设置 key 过期的 UNIX 时间戳，单位为毫秒 EXPIRE 和 PEXPIRE 设置的是 key 的存活时间（time to live），key 的存活时间会随着时间的流逝而不断减少，当值为 0 时，Redis 就会移除这个 key。EXPIREAT 和 PEXPIRE 设置的是 key 的过期时间（expire time），当系统的当前 UNIX 时间超过设置的时间后，key 就会被删除。</description></item><item><title>Redis中的事务</title><link>https://zhannicholas.github.io/posts/redis/redis_transactions/</link><pubDate>Sun, 13 Dec 2020 17:52:50 +0800</pubDate><guid>https://zhannicholas.github.io/posts/redis/redis_transactions/</guid><description>Redis中提供了5个和事务相关的命令：MULTI、EXEC、DISCARD、**WATCH key [key ...]**和 UNWATCH。Redis事务一次执行一组命令，并保证：
一个事务中的所有命令按顺序串行执行。若某一个连接已开启事务，其它连接提交的命令并不会插入到这个事务中，而是会单独执行，即隔离性——每个会话之间是相互隔离的 要么所有的命令都执行，要么一条命令都不执行，即原子性。Redis保证当某个连接断开后，之前在该连接上所有QUEUED的命令一个也不会执行 使用事务 **MULTI**标志着一个事务块的开始，随后的命令不会立即执行，而是会被放入一个队列。当遇到 **EXEC**时，队列中的命令会以原子的方式按入队顺序执行，队列中的所有命令构成了一个单一的原子操作。而当遇到 **DISCARD**命令时，事务队列会被清空，队列中的所有命令被丢弃，事务结束，连接回到正常状态，如果某些键处于watched状态，它们将不再被watch。
下面是一个例子，从acount:B划20到acount:A的这个操作是原子的：
&amp;gt; mset account:A 100 account:B 200 OK &amp;gt; multi OK &amp;gt; decrby account:B 20 QUEUED &amp;gt; incrby account:A 20 QUEUED &amp;gt; exec 1) (integer) 180 2) (integer) 120 &amp;gt; mget account:A account:B 1) &amp;#34;120&amp;#34; 2) &amp;#34;180&amp;#34; 从上面这段代码可以发现，**MULTI**后的命令都被QUEUED，执行 **EXEC**会返回一个数组，数组中的元素就是之前入队的命令的执行结果，它们是顺序对应的。
当事务中发生错误 在一个事务内，可能发生以下两类错误：
调用 **EXEC**之前有命令入队失败。多数情况下是由于编程错误(例如语法错误)，也可能是系统错误(例如内存用尽)，也可能是被当前线程 **WATCH**的键在调用 **MULTI**之后被其它线程修改 调用 **EXEC**之后有命令执行失败。例如在特定类型的数据上执行该类型不支持的操作 对于第一种情况，当前事务会被标记为无效状态，错误的命令并不会入队，其后的命令会继续入队，但当调用 **EXEC**时，并不会开启事务，而是会异常中止。当xx命令由于语法错误而入队失败，事务处于无效状态，调用 **EXEC并不会开启事务，而是直接终止，INCR account:B**也没有执行：
&amp;gt; multi OK &amp;gt; xx (error) ERR unknown command `xx`, with args beginning with: &amp;gt; incr account:B QUEUED &amp;gt;exec (error) EXECABORT Transaction discarded because of previous errors.</description></item><item><title>Redis Streams</title><link>https://zhannicholas.github.io/posts/redis/redis_streams/</link><pubDate>Sun, 13 Dec 2020 17:49:38 +0800</pubDate><guid>https://zhannicholas.github.io/posts/redis/redis_streams/</guid><description>作为Redis 5.0中推出的全新数据结构，stream的行为就像append-only log一样，但它由基数树(radix tree)实现。stream由entry构成。它具有很多特性：stream的entry保存了一组field-value对，和hash十分类似。除了field-value对，每个entry都具有唯一ID，默认情况下，这个ID的形式为：&amp;lt;millisecond-timestamp&amp;gt;-&amp;lt;sequence number&amp;gt;。stream支持基于ID的范围查询，若将时间戳作为ID的前缀，便可以实现基于时间的范围查询。entry一旦被创建，其存储的内容就不能被修改，但我们可以从stream中删除某个entry。若要向stream中添加entry，只能通过在stream的末尾追加这个entry的方式进行。最后，stream同时支持阻塞和非阻塞的消费模式，可以被多个不同的消费组消费或处理，这些消费组相当于stream的订阅者。stream和Pub/Sub最大的区别在于：stream会为了后续客户端的消费而在内存中保存数据，Pub/Sub不保存任何消息。
Stream生产者 通常情况下，producer从一个或多个源读取数据，然后将它们写入到stream。
Redis Stream的生产者API Redis Stream Producer API允许producer将任何消息(entry)追加到stream的末尾，整个API只包含一个命令——XADD key ID field value [field value ...]。 **XADD命令用于将一个entry追加到stream，当key不存在时，还会新建一个stream：第一个参数key代表一个特定的stream，ID表示消息的ID，通常情况下我们会使用*来告诉Redis我们希望由Redis来生成这个ID，接下来是entry的内容。XADD**会将新加入stream的消息的ID作为返回值返回。
&amp;gt; xadd numbers * n 0 &amp;#34;1587959118318-0&amp;#34; &amp;gt; xadd numbers * n 1 &amp;#34;1587959128680-0&amp;#34; &amp;gt; type numbers stream 消息ID ID是唯一的，并且每个消息有且只有一个ID，它代表着消息在stream中的位置。也就是说：越接近于stream开头的消息的ID越小，越接近于stream末尾的消息的ID越大。消息的ID是不可变的，一旦被创建，就不能再被修改。
我们可以在一个命令的前面加上一个数字，然后Redis会多次执行这个命令。这能帮助我们更好的观察Redis自动生成消息ID的特点：
&amp;gt; 7 xadd letter_number * a 1 &amp;#34;1587960623524-0&amp;#34; &amp;#34;1587960623525-0&amp;#34; &amp;#34;1587960623525-1&amp;#34; &amp;#34;1587960623526-0&amp;#34; &amp;#34;1587960623526-1&amp;#34; &amp;#34;1587960623527-0&amp;#34; &amp;#34;1587960623527-1&amp;#34; 这里重复执行了7次xadd letter_number * a 1。Redis自动生成的消息ID的格式为：&amp;lt;millisecond-timestamp&amp;gt;-&amp;lt;sequence number&amp;gt;。可以发现：当timestamp相同时，sequence number会不断自增(多个消息可能会在同一个时间出现，用自增保证ID的唯一性)。每到一个新的时刻，sequence number会重置为0。
实际上，ID包括两个数字(64位无符号整数)，数字之间用-分隔。ID是总是自增的，这体现在组成ID的两个数字的自增上。插入一个ID比当前stream中最大entry的ID还小的entry是不被接受的。
&amp;gt; xadd letter_number 1-1 a 1 (error) ERR The ID specified in XADD is equal or smaller than the target stream top item 有时候，我们可能希望使用自己的ID，这个时候我们需要保证自己的ID是自增的，一个有效的ID必须大于0-0。</description></item><item><title>Redis数据结构</title><link>https://zhannicholas.github.io/posts/redis/redis_datastructures/</link><pubDate>Sun, 13 Dec 2020 17:47:33 +0800</pubDate><guid>https://zhannicholas.github.io/posts/redis/redis_datastructures/</guid><description>Redis的键是一个字符串。在Redis中，字符串二进制安全的，也就是说：Redis中的字符串可以是任何二进制序列，即可以是任何类型的数据(比如：一张图片、一个序列化后的Java对象……)。像2、2.3、0xff、空字符串(&amp;quot;&amp;quot;)等任何二进制序列都可以作为Redis中的键。由于键是一个二进制序列，所以键是区分大小写的(a和A是两个不同的键)。当前版本的Redis的键最大支持到512MB(未来这个值可能还会更大)。过大的键会消耗更多的内存，因此选择合适的键很重要。
通常情况下，我们会使用结构良好且有意义的键名，使用冒号(:)作为分隔符。例如：users:1000:friends。
逻辑数据库 Redis中也有数据库(database)的概念，只是是以命名空间(namespacing)的形式体现的。在每一个逻辑数据库(logical database)内，都存在一个键空间(key space)。逻辑数据库通过下标(从0开始)进行区分。一个逻辑数据库内的键名都是唯一的，但同一个键名可以出现在多个不同的逻辑数据库中，逻辑数据库的一个作用就是对键名进行隔离。
逻辑数据库的数量也是有限制的，Redis集群只支持database 0。
获取所有键名 有两个命令可以获取Redis数据库内所有的键名，**KEYS pattern**和 SCAN cursor [MATCH pattern] [COUNT count]。我们可以使用这两个命令来迭代数据库内所有的键，也可以只获取满足给定模式的键。
KEYS命令会一次性迭代完所有的键，在迭代完所有的键之前，会阻塞所有其它的操作。若数据库内键的数量非常大，执行这个命令则会很耗时，因此在生产环境中使用这个命令时要谨慎，由于 **KYES**的使用比 **SCAN**要简单，因此它在调试时还是很有用的。
SCAN命令也会阻塞，但它采取的是增量迭代的方式，一次只迭代少量的键，阻塞时间不会过长，因此在生产环境中使用它是安全的。
删除键 有多种方式可以删除键，每种方式都能保证删除成功，但不同方式的性能不同。
DEL key [key ...]命令会删除给定的键并回收与键相关联的内存，这个删除操作是以阻塞方式进行的。**UNLINK key [key ...]**命令和 DEL命令类似，但它会使用单独的后台线程来回收内存，因此是非阻塞的。
检查键的存在性 当我们执行 **SET命令时，若键不存在，将会创建键并设置值。有时候，我们希望只有当某一个键存在时，才给它设置值。EXISTS key [key ...]**命令可以检测给定的键是否存在，若键存在，则返回1，否则返回0。
键过期 我们可以为某个key设置过期时间(expires)。当达到设置的过期时间时，对应的key就会被自动删除，就像我们显式的执行 DEL 命令一样。过期时间的单位可以是秒，也可以是毫秒，还可以是UNIX时间戳。关于expires的信息都存放在磁盘上，且有备份。这意味着，即使Redis服务器停止运行，过期时间仍然会有效。实际上，Redis保存的是key过期的确切时间，而不是剩余生存时间，虽然参数可以是秒或毫秒。
有三种类型的命令可以管理键的过期时间：
设置过期时间：EXPIRE(单位为秒)、PEXPIRE(单位为毫秒)、EXPIREAT(单位为秒)、PEXPIREAT(单位为毫秒) 查看剩余过期时长：TTL(单位为秒)、PTTL(单位为毫秒) 移除过期时间：PERSIST 下面是一些例子：
&amp;gt; set s1 v1 OK &amp;gt; expire s1 10 // 设置s1于10秒后过期 1 &amp;gt; ttl s1 // 查看s1的剩余生存时间(单位为秒) 7 &amp;gt; pttl s1 // 查看s1的剩余生存时间(单位为毫秒) 3042 &amp;gt; get s1 // 查看s1的值，未经过10秒 &amp;#34;v1&amp;#34; &amp;gt; get s1 // 查看s1的值，超过10秒，s1已被删除 (nil) &amp;gt; set s2 v2 ex 10 // 在设置值的同时指定过期时间为10秒 OK &amp;gt; set s3 v3 px 10000 // 在设置值的同时指定过期时间为10000毫秒 OK 数据类型 Redis支持多种数据结构(类型)。我们可以使用 **TYPE key**命令来查看key对应的数据类型，例如：</description></item><item><title>Redis Publish/Subscribe</title><link>https://zhannicholas.github.io/posts/redis/publish_subscribe/</link><pubDate>Sun, 13 Dec 2020 17:45:33 +0800</pubDate><guid>https://zhannicholas.github.io/posts/redis/publish_subscribe/</guid><description>Redis通过 PUBLISH、**SUBSCRIBE**等命令实现了发布-订阅模式，这个功能提供了两种信息机制：simple syndication和pattern syndication。值得注意的是：发布-订阅不保证完成消息的交付。当消息发布时到某个channel上时，只有那些订阅了该channel并且连接上了的客户端才会收到消息。消息一旦发布，就会被丢弃，只有那些当前订阅了的客户端才会收到该消息。也就是说，客户端只有在消息发布前订阅，才能收到该消息。。
Simple syndication 在simple syndication下，Redis使用 **PUBLISH channel message**发布message到指定channel，然后返回收到该消息的客户端数量。
客户端使用 SUBSCRIBE channel [channel ...]来监听指定的channel，此后客户端不能再发出除 SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE、**PING**和 **QUIT**以外的命令。对于redis-cli来说，一旦处于订阅模式，就不再接收任何命令并且只能通过Ctrl-C来退出。
若客户端不想再监听某个channel上的消息，可以执行 **UNSUBSCRIBE [channel [channel ...]]**来停止对指定channel上消息的订阅。若没有给出channel参数，客户端将停止对之前订阅的所有channel的监听。
下面是一个例子： 首先client-2订阅了ch1上的消息：
client-2:6379&amp;gt; subscribe ch1 Reading messages... (press Ctrl-C to quit) 1) &amp;#34;subscribe&amp;#34; 2) &amp;#34;ch1&amp;#34; 3) (integer) 1 然后client-1往ch1上发布消息：
client-1:6379&amp;gt; publish ch1 &amp;#34;hello&amp;#34; (integer) 1 // 有一个订阅者收到了消息 收到消息的正是client-2，client-2上应该可以看到这样的信息：
client-2:6379&amp;gt; subscribe ch1 Reading messages... (press Ctrl-C to quit) 1) &amp;#34;subscribe&amp;#34; 2) &amp;#34;ch1&amp;#34; 3) (integer) 1 1) &amp;#34;message&amp;#34; 2) &amp;#34;ch1&amp;#34; 3) &amp;#34;hello&amp;#34; 消息的格式 Redis中，channel的订阅者接收到的消息是一个由三个元素组成的数组。其中第一个元素是消息的类型，后两个元素的内容随消息的类型而变化。有三种类型的消息：</description></item><item><title>Redis Lua 脚本</title><link>https://zhannicholas.github.io/posts/redis/lua_scripting/</link><pubDate>Sun, 13 Dec 2020 17:41:46 +0800</pubDate><guid>https://zhannicholas.github.io/posts/redis/lua_scripting/</guid><description>Redis支持在服务端使用Lua解释器执行Lua脚本。Redis本身已经提供了非常多的命令，而Lua脚本可以帮助我们使用Lua提供的语言特性来组织这些命令，以达到更好的效果。总的来说，使用Lua脚本带来的好处有：
降低网络开销。客户端每次只能操作一个键，客户端每发出一个命令，都会引发一个完整请求-响应过程，当需要发送大量指令时，这会引起巨大的网络开销。因为Lua脚本是直接在在Redis服务端执行的，将多个命令放在同一个Lua脚本中执行或在同一个Lua脚本中操作多个键可以减少网络传输次数，进而降低网络开销 原子操作。Redis会将整个Lua脚本作为一个整体以原子的方式执行，就像事务一样 可复用性。Lua脚本就像是数据库中的存储程序一样，支持传入参数，反复使用。Redis还会缓存已执行的脚本，这意味着其它的客户端可以直接使用已缓存的脚本 执行脚本 执行Lua脚本的命令为 **EVAL script numkeys key [key ...] arg [arg ...]**和 EVALSHA sha1 numkeys key [key ...] arg [arg ...]。
**EVAL**具有很多参数：script代表待执行的Lua脚本，numkeys表示键的数量.，接下来是键名(可以通过全局变量KEYS访问)和脚本可能需要用到的参数(可以通过全局变量ARGV访问)。
&amp;gt; hset hash-key f1 hello f2 Redis (integer) 2 &amp;gt; eval &amp;#34;return redis.call(&amp;#39;HGET&amp;#39;, KEYS[1], ARGV[1])&amp;#34; 1 hash-key f2 &amp;#34;Redis&amp;#34; &amp;gt; eval &amp;#34;return redis.call(&amp;#39;HGET&amp;#39;, &amp;#39;hash-key&amp;#39;, &amp;#39;f2&amp;#39;)&amp;#34; 0 &amp;#34;Redis&amp;#34; 在上面这段脚本里，创建了两个预定义的数组：KEYS存放传入所有键名，而ARGV存放传入的所有参数。最后一条命令硬编码参数，虽然执行结果和倒数第二条一致，但灵活性非常低。需要注意的是：Lua中的数组下标是基于1的。
Lua和Redis之间的数据类型转换 Redis to Lua：
Redis Value Lua Value Redis Integer Number Redis bulk reply String Redis multi bulk reply Table (with other types nested) Redis status reply Table with &amp;ldquo;ok&amp;rdquo; field containing status Redis error Table with &amp;ldquo;err&amp;rdquo; field containing error Redis nil bulk reply and nil multi reply False (boolean type) Lua to Redis：</description></item><item><title>Jedis</title><link>https://zhannicholas.github.io/posts/redis/jedis/</link><pubDate>Sun, 13 Dec 2020 17:40:18 +0800</pubDate><guid>https://zhannicholas.github.io/posts/redis/jedis/</guid><description>Jedis 是一个Java编写的Redis客户端，提供了完整的Redis API。Redis客户端通常需要具备三种能力：管理Redis连接、实现Redis序列化协议RESP (REdis Serialization Protocol)和实现可供编程人员调用的Redis API(GET、SET等)。
除了Jedis，还有两个Java编写的Redis客户端非常流行，它们是Lettuce 和Redisson 。
连接到Redis服务 Jedis jedis = new Jedis(&amp;#34;127.0.0.1&amp;#34;, 6379); jedis.set(&amp;#34;hello&amp;#34;, &amp;#34;Redis&amp;#34;); assertThat(result, is(&amp;#34;OK&amp;#34;)); String value = jedis.get(&amp;#34;hello&amp;#34;); assertThat(value, is(&amp;#34;Redis&amp;#34;)); jedis.close(); // 关闭TCP连接，防止发生连接泄漏 Jedis API的使用和redis-cli非常类似，例如redis-cli中的 SET 和 **GET**在Jedis中就是jedis.set(...)和jedis.get(...)。
在多线程环境下使用Jedis Jedis实例会维护一个到Redis的TCP连接，它不是线程安全的。因此，为了避免遇到未知问题，我们不应该让同一个Jedis实例被多个线程共享。为每一个线程都创建一个Jedis实例也不是一个好主意，因为这会创建大量的Socket连接，也可能导致未知问题。为了避免这些问题，我们可以在多线程环境下使用JedisPool，它是一个线程安全的网络连接池。使用JedisPool既可以帮助我们克服非线程安全引发的未知问题，同时，由于复用了连接，应用的性能也会有所提高。为了使用JedisPool，我们需要先初始化它：
JedisPool jedisPool = new JedisPool(new JedisPoolConfig(), &amp;#34;127.0.0.1&amp;#34;, 6379); JedisPool基于Apache Commons Pool 2 实现。JedisPoolConfig也继承于GenericObjectPoolConfig ，它包含了一些非常有用的连接池默认值。我们可以这么使用JedisPool:
try (Jedis jedis = jedisPool.getResource()) { String result = jedis.set(&amp;#34;hello&amp;#34;, &amp;#34;Redis&amp;#34;); assertThat(result, is(&amp;#34;OK&amp;#34;)); String value = jedis.get(&amp;#34;hello&amp;#34;); assertThat(value, is(&amp;#34;Redis&amp;#34;)); } jedisPool.</description></item><item><title>初见Redis</title><link>https://zhannicholas.github.io/posts/redis/redis_at_first_sight/</link><pubDate>Wed, 25 Sep 2019 19:24:06 +0800</pubDate><guid>https://zhannicholas.github.io/posts/redis/redis_at_first_sight/</guid><description>Redis 是一个位于内存中的数据结构存储系统，由 ANSI C 语言编写。可用作数据库、缓存和消息中间件。它支持的数据结构有：string、hash、list、set、sorted set with range quries、bitmap、hyperloglogs、geospatial indexes with radius queries以及stream。Redis支持复制、Lua脚本、基于LRU的键驱逐、事务和不同级别的磁盘持久化，并通过哨兵和Redis集群的自动分区机制来保证高可用。
Redis 是 Remote dictionary server 的缩写，字母意思即远程字典服务。一个 Redis 可以有多个存储数据的字典，客户端可以通过 select 来选择字典（DB）进行存储。
Redis的存储是基于key-value的，但这里的key-value不是简单的key-value，因为value的类型可以有很多种。在我们传统的key-value存储中，key和value都是字符串，而在Redis中，value不仅可以是字符串，还有可能是像列表、集合这样的复杂的数据结构。
本文主要内容包括：Redis的安装、键和几种常见的数据类型的使用，以及和数据生存期相关的一些操作。
安装Redis 参见Redis Quick Start 。
Redis键 Redis的键是一个字符串。在Redis中，字符串二进制安全的，也就是说：Redis中的字符串可以包含任何类型的数据(比如：一张图片、一个序列化后的Java对象……)，这些也可以成为Redis中的键。
注意：空字符串(&amp;quot;&amp;quot;)也是一个有效的键。
数据类型 Strings 字符串(string)是Redis最基本的数据类型，最大不能超过512MB。
Redis提供了20多个操作string类型的命令。下面是一些例子：
&amp;gt;&amp;gt; set s1 &amp;#34;Hello, Redis&amp;#34; // 设置s1的值为&amp;#34;Hello, Redis&amp;#34; OK // 成功返回OK &amp;gt;&amp;gt; get s1 // 获取值 &amp;#34;Hello, Redis&amp;#34; &amp;gt;&amp;gt; setnx s1 &amp;#34;Redis&amp;#34; // 尝试为s1设置新值 0 // s1已有值，不进行操作，返回0 &amp;gt;&amp;gt; get s1 &amp;#34;Hello, Redis&amp;#34; &amp;gt;&amp;gt; set s1 2 // 设置值 OK &amp;gt;&amp;gt; get s1 &amp;#34;2&amp;#34; &amp;gt;&amp;gt; incr s1 // 加1 3 &amp;gt;&amp;gt; incrby s1 10 // 加10 13 &amp;gt;&amp;gt; decr s1 // 减1 12 &amp;gt;&amp;gt; decrby s1 5 // 减5 7 &amp;gt;&amp;gt; incrbyfloat s1 1.</description></item></channel></rss>