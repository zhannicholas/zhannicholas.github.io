<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JakartaEE on 's Digital Garden</title><link>https://zhannicholas.github.io/tags/jakartaee/</link><description>Recent content in JakartaEE on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 13 Dec 2020 18:07:45 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/tags/jakartaee/index.xml" rel="self" type="application/rss+xml"/><item><title>What is Servlet</title><link>https://zhannicholas.github.io/posts/java/jakartaee/what_is_servlet/</link><pubDate>Sun, 13 Dec 2020 18:07:45 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jakartaee/what_is_servlet/</guid><description>A servlet is a Java™ technology-based Web component, managed by a container, that generates dynamic content.
和其它基于Java的组件一样，Servlet也由Java类组成，这些Java类(.class文件)会被编译成字节码，字节码随后会被动态地加载到Web服务器中并运行。Servlet通过Servlet容器实现的request/response模型来与Web客户端进行交互。
request/response模型：可以简单的将这个模型看成是一种客户端与服务端通过交换各自的消息来交互的一个过程。像浏览器这样的客户端发出的消息叫做requests，而服务端响应的消息就叫做responses。
什么是Servlet容器 The servlet container is a part of a Web server or application server that provides the network services over which requests and responses are sent, decodes MIME-based requests, and formats MIME-based responses. A servlet container also contains and manages servlets through their lifecycle.
容器(Container)，又称Servlet引擎(Servlet engine)。它可以是Web服务器内置的，也可以是Web服务器中的插件。对于所有的Servlet容器而言，除了必须支持的HTTP协议以外，还可能支持向HTTPS这种的基于request/response模型的协议。容器必须实现的HTTP协议版本包括HTTP/1.1和HTTP/2，当支持HTTP/2时，容器必须支持h2和h2c两种协议标识符，即所有的Servlet容器必须支持ALPN。
此外，Servlet容器还可能会在Servlet的执行环境中加入安全限制。例如，一些应用服务器可能会限制对**Thread**对象的创建，以避免对容器中的其它组件造成负面影响。
一个例子 下面是一个典型的Servlet事件序列：
客户端(比如浏览器)访问Web服务器并发起一个HTTP请求。 Web服务器接收该HTTP请求并将其转交给Servlet容器。 Servlet容器先根据配置信息决定该要调用哪一个Servlet，然后将表示request和response的对象传递给该Servlet并调用它。 Servlet从request对象中获取到远程用户的身份、请求参数和其它相关数据，然后执行处理逻辑，最后生成响应数据(通过response对象)并发回给客户端。 一旦Servlet完成整个请求处理过程，Servlet容器就会刷新响应，然后将控制权归还给Web服务器。 一个简单的Servlet 下面将编写一个非常简单的Servlet，它将展现编写Servlet的所有基本要求。最终该Servlet会在浏览器中输出一些文本：</description></item><item><title>The Servlet Interface</title><link>https://zhannicholas.github.io/posts/java/jakartaee/the_servlet_interface/</link><pubDate>Sun, 13 Dec 2020 18:04:42 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jakartaee/the_servlet_interface/</guid><description>**Servlet接口是Java Servlet API的核心抽象，所有的Servlet都直接或间接地实现它。GenericServlet**和 **HttpServlet**就是Java Servlet API中的两个 **Servlet**实现类。很多时候，开发人员只需要继承 **HttpServlet**并实现他们自己的服务就行了。
请求处理方法 **Servlet**接口中定义的service方法就是用来处理客户端请求的，Servlet容器每将一个请求路由到一个Servlet实例之后，都会调用这个service方法。为了处理并发请求，开发者编写的Servlet通常要能够处理在特定时间内service方法中有多个线程执行的情况。通常情况下，Web容器就是通过在不同线程上并发地执行service方法来将并发请求交给同一个Servlet处理的。
HTTP请求的处理方法 为了简化HTTP请求的处理过程，抽象类 **HttpServlet**在 **Servlet**的基础上添加了一些额外的方法。这些方法可以自动的被service方法调用，它们是：
处理GET请求的doGet方法； 处理POST请求的doPost方法； 处理PUT请求的doPut方法； 处理DELETE请求的doDelete方法； 处理HEAD请求的doHead方法； 处理OPTIONS请求的doOptions方法； 处理TRACE请求的doTrace方法； 在开发基于HTTP的Servlet时，开发者一般只需要关心doGet和doPost方法即可。
Servlet生命周期 Servlet有一个定义非常良好的生命周期，它定义了Servlet是如何被加载并被实例化、如何初始化、如何处理客户端请求以及如何结束服务的。这个生命周期是通过 **Servlet**接口的init、service和destroy方法来定义的，所有的Servlet都必须直接或间接地实现这几个方法。Servlet的生命周期是由Servlet容器控制的，当一个请求被映射到一个Servlet时，容器会进行以下步骤：
如果容器中没有该Servlet的实例，容器就会：先加载Servlet，然后创建Servlet实例，再调用init方法对Servlet进行初始化。 容器调用Servlet的service方法并传入request和response对象。 当容器需要移除一个Servlet时，它会调用Servlet的destroy方法进行收尾工作。
加载与实例化 Servlet的加载与实例化是由Servlet容器负责的。Servlet的加载与初始化可以发生在Servlet容器启动时，也可以延迟到需要处理请求时才发生。Servlet容器使用Java的类加载机制来加载Servlet，被加载的Servlet可能来自本地文件系统，也可能来自远程文件系统或其它网络服务。当Servlet被加载成功之后，容器就会实例化它以备将来使用。
初始化 当Servlet对象被实例化之后，容器必须在它开始处理客户端请求之前将它初始化。初始化过程可以用来从数据库内读取配置数据，执行一次性活动等等。容器通过 **Servlet**接口的init方法来初始化一个Servlet，init方法 接收一个 **ServletConfig接口的实现类，它允许Servlet从Web应用的配置信息中读取name-value形式的初始化参数。此外，Servlet**还可以通过 **ServletConfig**来访问 ServletConfig（它描述了当前Servlet的运行环境）。
在初始化过程中，Servlet实例可能会抛出一个 **UnavailableException**或 ServletException。这时，这个Servlet实例就不能被放到现役服务中，Servlet容器必须把它释放掉。这个时候，destroy方法并不会被调用，因为这种情况下Servlet的初始化是不成功的。初始化失败的Servlet在之后的某个时间点还可能再次被初始化。
请求处理 在Servlet被正确地初始化之后，Servlet容器就可以用它来处理客户端请求了。每个请求都被表示为一个 **ServletRequest**对象，而请求的响应会被表示成一个 **ServletResponse**对象。这两个对象都会被传递给 **Servlet**接口的service方法作为入参。当处理HTTP请求时，容器会使用 **HttpServletRequest**和 **HttpServletResponse**类型的对象。
当然，容器内处于服务状态的Servlet在整个生存期中一个请求也不处理也是有可能的。
多线程问题 Servlet容器可能将并发的请求移交给Servlet的service方法。为了处理这些请求，Servlet开发者必须仔细处理好service方法内的多个线程。**SingleThreadModel**在Servlet 4.0中已被弃用。
请求处理中的异常 在处理请求时，Servlet可能会抛出 **ServletException或 UnavailableException。ServletException**表示处理过程中发生了一些错误，此时容器需要采取一些操作来清除请求。而 **UnavailableException**表示该Servlet临时或永久不可用。如果不可用是永久的，容器必须将这个Servlet移除，调用它的destroy方法并释放它，容器会为所有因此而拒绝的请求返回SC_NOT_FOUND(404)。如果不可用是临时的，容器会在一定时间内不再路由相关的请求到这个Servlet上，容器会为所有在这段时间内因此而拒绝的请求返回SC_SERVICE_UNAVAILABLE(503)。
异步处理 **AsyncContext**表示的是 **ServletRequest**创建的异步执行上下文。
待完善。
终止服务 当容器决定要移除一个Servlet时，它会调用这个Servlet的destroy方法。Servlet可以在这个方法中释放当前占用的资源、保存当前状态到数据库等等。在调用destroy方法之前，容器会等待service方法内的线程执行结束。当等待时间达到某个阈值时，destroy方法也可能被直接调用。在destroy方法完成后，容器必须释放这个Servlet，以便GC将其回收。</description></item><item><title>About Jakarta EE</title><link>https://zhannicholas.github.io/posts/java/jakartaee/about/</link><pubDate>Sun, 13 Dec 2020 18:03:23 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jakartaee/about/</guid><description>Java EE (Java Platform, Enterprise Edition)是构建在Java SE 之上的一套企业级标准，早期被称为J2EE(Java 2 Platform Enterprise Edition)，现在则被称为Jakarta EE 。
在Java的第一个版本中，Java企业扩展仅仅只是core JDK 的一部分。到了1999年，这些企业扩展被从Java SE中剥离出来，并作为Java 2的一部分，即J2EE(或Java 2 Platform Enterprise Edition )，J2EE这个称呼一致维持到了2006年。在2006年发布的Java 5中，J2EE改名为Java EE，这个名字一直使用到了2017年。2017年发生了一件和Java有关的大事儿：Oracle决定将Java EE捐赠给Eclipse基金会 。虽然如此，但Oracle依旧保留了Java语言的所有权。事实上，由于Oracle拥有&amp;quot;Java&amp;quot;的商标权，按照法律规定，Eclipse基金会不能再使用Java EE这个名字。经过社区投票，基金会最终选取了Jakarta EE作为Java EE的新名字。
简而言之，J2EE的名字在历史上的主要变更如下：
Version Date J2EE 1.2 1999年12月 J2EE 1.3 2001年09月 J2EE 1.4 2003年11月 Java EE 5 2006年05月 Java EE 6 2009年12月 Java EE 7 2013年04月 Java EE 8 2017年08月 Jakarta EE 2018年12月 当前，Java EE的大部分Github仓库 已经归档，取而代之的是Eclipse EE4J 。</description></item></channel></rss>