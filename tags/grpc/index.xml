<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gRPC on 's Digital Garden</title><link>https://zhannicholas.github.io/tags/grpc/</link><description>Recent content in gRPC on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 18 Sep 2021 22:34:56 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/tags/grpc/index.xml" rel="self" type="application/rss+xml"/><item><title>gPRC 与 Protocol Buffers</title><link>https://zhannicholas.github.io/posts/grpc/gprc-and-protocol-buffers/</link><pubDate>Sat, 18 Sep 2021 22:34:56 +0800</pubDate><guid>https://zhannicholas.github.io/posts/grpc/gprc-and-protocol-buffers/</guid><description>最近工作中需要用到 gPRC，赶紧学了一下，顺便做了些笔记。
gPRC 与 Protocol Buffers 经常一起使用，二者的关系非常密切。因为 gPRC 不仅将 Protocol Buffers 作为自己的 IDL（Interface Definition Language），还将其用作底层的消息交换格式。
gRPC A hight performance, open source universal RPC framework.
gPRC 是一个由 Google 出品的 RPC（Remote Procedure Call） 框架。在笔者写这篇文章的时候，gPRC 还是云原生计算基金会（CNCF） 的一个孵化项目。
gRPC 的核心思想和其它的 RPC 框架一样，都是定义一个服务，然后声明可以被远程调用的方法以及方法的参数和返回类型。服务端实现定义的接口并处理客户端的调用，而客户端则有一个桩对象（stub），它提供了与服务端相同的方法。
gRPC 调用过程 gRPC 的使用者通常会在服务端实现 .proto 文件中描述的服务 API，然后在客户端进行 API 的调用。每一个 API 都涉及服务端和客户端两方面，服务端负责实现，而客户端进行调用，它们是一一对应的。
服务端不仅会实现 .proto 所描述的服务中声明的方法，还会运行一个处理客户端调用的服务器。gRPC 会解码传入请求，执行服务方法，并编码服务响应。而在客户端这一侧，会有一个实现了相同服务方法本地对象（一般叫 stub，有些语言也称 client）。客户端会直接调用这个本地对象上的方法，使用恰当的 Protocol Buffers 消息类型包裹方法参数。gRPC 会将请求发送给服务端，并获取服务端的响应数据。
下面这张图来自 gRPC 官网，它不仅展示出了 gRPC 中客户端与服务端交互的过程，还暗示了 gRPC 是跨语言的：
当下分布式系统和微服务架构非常流行，RPC 的这一大特点使得我们创建分布式应用和服务更加简单。
定义服务 默认情况下，gRPC 使用 Protocol Buffers 描述服务接口和消息负载（message payload）的结构。我们也可以按照实际需要，选择其它的语言来描述接口和消息的结构。</description></item></channel></rss>