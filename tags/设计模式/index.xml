<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式 on 's Digital Garden</title><link>https://zhannicholas.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 设计模式 on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 01 Oct 2018 13:28:15 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>《设计模式的艺术》读书笔记</title><link>https://zhannicholas.github.io/library/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/</link><pubDate>Mon, 01 Oct 2018 13:28:15 +0800</pubDate><guid>https://zhannicholas.github.io/library/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/</guid><description>单例模式 单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类就是单例类。
从单例模式的定义来看，它有3个要点：
它只有唯一一个实例； 它必须自行创建这个实例； 它必须向整个系统提供这个实例； 基本实现方案 将构造函数设为私有，确保外界无法通过 new 创建该对象； 提供公有的静态方法，返回单例类的唯一实例，供外界访问； 创建唯一的实例，并通过公有的静态方法返回； 单例模式的结构图如下：
根据这个图，可以很容易写出对应的代码：
// 单例类 public class Singleton { // 私有静态成员变量 private static Singleton instance = null; // 私有构造函数 private Singleton(){} // 公有静态成员方法，返回单例 public static Singleton getInstance(){ if(instance == null) instance = new Singleton(); return instance; } } 饿汉式单例类(Eager Singleton) 饿汉式单例类的结构图如下：
从图中可以看出，当类 加载 的时候，静态变量instance就会被初始化，此时会调用私有的构造函数创建类的唯一实例。代码如下：
// 饿汉式单例类 public class EagerSingleton { private static final EagerSingleton instance = new EagerSingleton(); private EagerSingleton(){} public static EagerSingleton getInstance(){ return instance; } } 懒汉式单例类(Lazy Singleton) 懒汉式单例类的结构图如下：</description></item></channel></rss>