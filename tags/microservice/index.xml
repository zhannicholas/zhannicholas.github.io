<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Microservice on</title><link>https://zhannicholas.github.io/tags/microservice/</link><description>Recent content in Microservice on</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 04 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://zhannicholas.github.io/tags/microservice/index.xml" rel="self" type="application/rss+xml"/><item><title>Build Microservices, 2nd Edition</title><link>https://zhannicholas.github.io/pages/build-microservices-2nd-edition/</link><pubDate>Tue, 04 Apr 2023 00:00:00 +0000</pubDate><guid>https://zhannicholas.github.io/pages/build-microservices-2nd-edition/</guid><description>This in my reading notes of Build Microservices, 2nd Edition .
Chapter 1. What Are Microservices Microservices are independently releasable services that are modeled around a business domain.
Microservices embrace the concept of information hiding. Information hiding means hiding as much information as possible inside a component and exposing as little as possible via external interfaces.
Key Concepts of Microservices Independent Deployability Independent deployability is the idea that we can make a change to a microservice, deploy it, and release that change to our users, without having to deploy any other microservices.</description></item><item><title>Mastering API Architecture</title><link>https://zhannicholas.github.io/pages/mastering-api-architecture/</link><pubDate>Tue, 30 Aug 2022 00:00:00 +0000</pubDate><guid>https://zhannicholas.github.io/pages/mastering-api-architecture/</guid><description>This is my reading notes of Mastering API Architecture (oreilly.com) . Introduction Broadly speaking, APIs can be broken into two general categories depending on whether the API invocation is in process or out of process. The process being referred to here is an operating system (OS) process. In process means the call is handled by the same process from which the call was made, such as a Java method invocation</description></item><item><title>The RED method</title><link>https://zhannicholas.github.io/pages/the-red-method/</link><pubDate>Tue, 30 Aug 2022 00:00:00 +0000</pubDate><guid>https://zhannicholas.github.io/pages/the-red-method/</guid><description>The RED Method: key metrics for microservices architecture (weave.works) .
The RED Method refers to the three key metrics you should measure for every microservice in your architecture. Those metrics are:
(Request) Rate - the number of requests, per second, you services are serving.
(Request) Errors - the number of failed requests per second.
(Request) Duration - distributions of the amount of time each request takes.
the RED method is 100% based on Google SRE.</description></item><item><title>The USE method</title><link>https://zhannicholas.github.io/pages/the-use-method/</link><pubDate>Tue, 30 Aug 2022 00:00:00 +0000</pubDate><guid>https://zhannicholas.github.io/pages/the-use-method/</guid><description>The USE Method (brendangregg.com) .
id:: 630eb70d-91e4-4f73-bde6-bdcacae9d3c6 The Utilization Saturation and Errors (USE) Method is a methodology for analyzing the performance of any system. It directs the construction of a checklist, which for server analysis can be used for quickly identifying resource bottlenecks or errors. It begins by posing questions, and then seeks answers, instead of beginning with given metrics (partial answers) and trying to work backwards. The USE Method is based on three metric types and a strategy for approaching a complex system.</description></item><item><title>Design Data Intensive Applications</title><link>https://zhannicholas.github.io/pages/design-data-intensive-applications/</link><pubDate>Mon, 15 Aug 2022 00:00:00 +0000</pubDate><guid>https://zhannicholas.github.io/pages/design-data-intensive-applications/</guid><description>This is my reading notes of Design Data Intensive Applications . Preface if data (quantity, complexity, change speed, etc) is an application&amp;rsquo;s primary challenge, then we call the application data-intensive. As opposed to compute-intensive, where CPU cycles are the bottleneck. When we think about data systems, not just think how they work, but also why they work that way, and what questions we need to ask. Reference materials: ddia-references .</description></item></channel></rss>