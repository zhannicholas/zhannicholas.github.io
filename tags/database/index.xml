<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Database on 's Digital Garden</title><link>https://zhannicholas.github.io/tags/database/</link><description>Recent content in Database on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 29 Jul 2021 16:16:11 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/tags/database/index.xml" rel="self" type="application/rss+xml"/><item><title>数据库规范化</title><link>https://zhannicholas.github.io/posts/databases/database_normalization/</link><pubDate>Thu, 29 Jul 2021 16:16:11 +0800</pubDate><guid>https://zhannicholas.github.io/posts/databases/database_normalization/</guid><description>在关系数据库设计中，数据库规范化（Database normalization） 是一个非常重要的概念。一般而言，关系数据库设计的目标是生成一组关系模式，使我们存储数据时避免不必要的冗余，同时让我们可以方便地获取数据。规范化就是组织数据库内数据的一个过程，包括创建数据表和建立这些表之间的关系。而在建立表间关系时，我们既要保护数据的完整性，又要消除冗余数据。冗余数据不仅会浪费磁盘空间，还会增加我们维护的成本。
相关术语 关系数据库设计中涉及很多专业术语，在进入到主要内容之前，我想先介绍下这些术语，确保我们能够在术语的使用上达成共识。
数据库表（Table）：在关系数据库中，数据库表 是一个逻辑概念，代表以表格的形式进行组织的一组相关数据构成的集合。它由行和列组成。 行（Row）：数据库表中的每一行 （或每一条 记录（Record））都表示一组相关数据，表中的所有行的结构都是相同的。行又称 元组（Tuple）。 列（Column）：在关系数据库中，列 是一组特定类型数据构成的集合，集合中的每一项数据（字段）都分散在每一行中。如果一个表有 N 列，那么表中的每一条记录就会有 N 个字段。列又称 属性（Attribute）。 举个例子，我们有一个学生表 student(stu_id, name, gender)，在下面的 SQL 实现中：
CREATE TABLE student( stu_id INTEGER NOT NULL, name VARCHAR(50) NOT NULL, gender INTEGER NOT NULL, PRIMARY KEY (id) ); INSERT INTO student VALUES(1, &amp;#34;Mike&amp;#34;, 1); create TABLE student(...); 就代表一个表，stu_id INTEGER NOT NULL 就是表中的一列，INSERT INTO student VALUES(1, &amp;quot;Mike&amp;quot;, 1); 就是我们插入表中的一行数据。简单来说，表关注的是数据的组织形式，行关注的是数据的相关性，列关注的是数据的类型。
数据库中的键 键（Key）是数据库表结构的重要组成部分，通常由表中一个或多个字段构成，用来唯一标识表中的一条记录。此外，键还被用来提高数据的完整性，建立表与表之间的关系。在关系数据模型中，键主要有三种：候选键、主键和外键。
超键（Superkey）：超键 是一组能唯一标识出表中的每一行记录的属性集合。 候选键（Candidate key）：若超键不包含多余的属性（即最小超键），那么这个超键就是候选键 。候选键是超键的子集，每个表都必须有至少一个候选键。例如，在学生表 student(stu_id, name, gender) 中，若 stu_id 和 name 都可以唯一确定出一名学生，那么 stu_id 和 name 都是候选键。组成候选键中的属性叫主属性（prime attributes），不包含在候选键中的属性就是非主属性。 主键（Primary key）：既然候选键可以唯一标识出表中的每一行记录，那么我们就可以从候选键中选取一个作为主键 ，剩下的那些候选键就被称为替代键（Alternative key）。 外键（Foreign key）：若表 A 中的属性集 S 不是表 A 的主键，但 S 是表 B 的主键，则 S 就是表 A 中指向表 B 的外键 。 范式 为了保证数据库的规范化，人们开发出了一系列的设计准则。这些准则就是我们常说的 范式（normal form）。范式也分为很多等级，按照数据的规范化程度，从低到高依次有：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、BC 范式（BCNF）、第四范式（4NF）、第五范式（5NF）。</description></item><item><title>数据库事务</title><link>https://zhannicholas.github.io/posts/databases/database_transactions/</link><pubDate>Sun, 13 Dec 2020 17:35:30 +0800</pubDate><guid>https://zhannicholas.github.io/posts/databases/database_transactions/</guid><description>本文中绝大部分内容和图片都来自 High Performance Java Persistence: Get the most out of your persistence layer。
事务（Transaction） 是由一组读写操作组成的一个不可分割的执行单元，这组操作要么全部成功，要么全部失败。根据定义，一个事务必须是原子的（atomic）、一致的（consistent）、隔离的（isolated）和持久的（durable），我们通常把这四大特性称为 ACID。
原子性 多个操作可以构成一个逻辑工作单元。当且仅当工作单元内的所有操作都成功，这个工作单元才成功，若有操作执行失败，则必须回滚所有已经执行的操作并恢复到未执行时的状态，这就是事务的 原子性（Atomicity）。简而言之，原子性就是“all-or-nothing”。
一致性 一致性和事务状态的改变紧密相关的，当事务涉及修改操作时，可以将其看作是状态迁移，数据库会从一个有效状态迁移到另一个有效状态。一致性(Consistency） 就是指系统从一个正确的状态迁移到另一个正确的状态。
那么该如何理解“正确的状态”呢？我们在设计数据库时，通常会规定字段的类型、长度以及是否为空等，这些就是我们定义的规则。此外，我们可能还会给列加上一些约束（constraint），比如主键约束、外键约束、唯一约束和各种自定义约束。只有当数据满足所有的规则和约束时，它才是 有效的，它的状态才是正确的。一致性保证只有有效的数据才会被写入数据库中，若数据在事务执行后处于无效状态（即违反规则或约束），整个事务都会回滚，所有的修改都会被撤销，数据库会回到之前的状态。
一致性是维护数据完整性（integrity）的关键。
隔离性 事务的 隔离性(Isolation） 定义的是一个事务产生的影响对其它事务的可见程度。为了提高吞吐量，数据库系统通常会允许多个连接对数据进行并发访问。为了保证数据的完整性（integrity），数据库系统必须对这些并发的读写操作进行控制。
若几个事务不管以何种顺序执行，最终系统的状态都是一样的，则这几个事务是 可串行化的（serilizable）。如果几个事务并发执行，即使每个事务都能确保一致性和原子性，它们的操作也可能会以我们意料之外的某种顺序交叉执行，最终导致不一致状态。 只有当这些事务是可串行化的，最终的结果才会一致。可串行化是最高的隔离级别，但是此时数据库的性能可能会很低，因为事务都是串行的了，并发的优势荡然无存。
数据库中允许多个不同的隔离级别，这些隔离级别实际上是在性能与数据完整性之间做权衡的结果。隔离级别越低，并发度越高，数据的完整性就越差，反之，隔离级别越高，并发度越低，数据的完整性就越好。可串行化是唯一一个没有损坏数据完整性的隔离级别。
并发控制 并发访问很容易出现数据冲突，通常有两种解决数据冲突的基本策略：
冲突避免：使用锁控制共享资源，比如两阶段锁（2PL, two-phase locking） 冲突检测：并发性更好，但可能导致数据异常，比如多版本并发控制（MVCC, Multi-Version Concurrency Control） 两阶段锁 为了减少访问共享资源时发生的冲突，关系型数据库支持多粒度锁。数据库对象天生就是层次结构的，一个逻辑表空间可能被映射到多个数据库文件，而一个数据库文件又由多个数据页构成，每页又包含很多行…… 因此，不同的数据库对象都可以获得锁。
低级别的锁（比如：行级锁）粒度较小，减小了竞争的可能，可以提供更好的并发控制。然而，每个锁都是会消耗资源的，维持大量的低级别锁，也会带来可观的资源开销。因此，数据库可能会决定用一个稍微高级别的锁代替这些低级别的锁，这就是锁升级。这就是可并发性和资源消耗之间的一个权衡点。
不同数据库的锁都有自己的层级结构，最常见的锁有两种：
共享锁（读锁）：加锁后，只允许并发读，不允许写 互斥锁（写锁）：加锁后，既不允许写也不允许读 两阶段锁保证了可串行性，协议要求每个事务分为两个阶段：
增长阶段：只可获取锁，不可释放锁 缩减阶段：只可释放锁，不可获取锁 最初，事务处于增长阶段，事务可以根据需要获取锁。一旦事务开始释放锁，便进入缩减阶段，并且不能再发出加锁请求。 多版本并发控制 最初，所有的数据库系统都采用两阶段锁实现可串行化的事务。后来，很多数据库厂商改用了多版本并发控制(MVCC）。
尽管锁可以提供可串行化的事务调度，但是锁竞争还是会对事务的响应时间和可扩展性造成影响。为了克服这个缺点，数据库厂商们选择了乐观并发控制机制。如果说两阶段锁使用的是冲突避免策略，那么 MVVC 使用的就是冲突检测策略。
为了防止阻塞，数据库进行版本控制，然后可以重建数据库记录的早期版本，未提交的改变可能对后来的用户不可见。没有了锁的协助，可串行化调度的实现变得更加困难，数据库引擎必须分析当前的交叉操作并检测影响串行化的异常操作。
MVCC 是通过保存数据在某个时间点的快照来实现的。也就是说，不管执行多长时间，每个事务看到的数据都是一致的。事务开始时间的不同，即使是同一时刻的同一张表，不同事物看到的数据也可能是不一样的。
数据库中允许多个不同的隔离级别，这些隔离级别实际上是在性能与数据完整性之间做权衡的结果。隔离级别越低，并发度越高，数据的完整性就越差，反之，隔离级别越高，并发度越低，数据的完整性就越好。可串行化是唯一一个没有损坏数据完整性的隔离级别。
数据库异象 严格保证数据完整性的代价可能会非常高，因此有必要降低对事务串行化的保证程度，使用多个隔离级别，但这会导致数据库异象（Phenomena）的出现。
SQL-92 标准提出了三种异象：
脏读（dirty read） 不可重复读（non-repeatable read，也叫 fuzzy read） 幻读（phantom read） 现实中，还有其它的异象：</description></item></channel></rss>