<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Shell on 's Digital Garden</title><link>https://zhannicholas.github.io/tags/shell/</link><description>Recent content in Shell on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 27 Oct 2021 22:26:55 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/tags/shell/index.xml" rel="self" type="application/rss+xml"/><item><title>Shell 脚本：I/O 重定向</title><link>https://zhannicholas.github.io/posts/linux/shell_scripting_io_redirection/</link><pubDate>Wed, 27 Oct 2021 22:26:55 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/shell_scripting_io_redirection/</guid><description>文件输入和输出是通过整数句柄（integer handle）实现的——每个打开的文件都会被赋予一个数字，这个数字就是文件描述符（file descriptor）。
最常见的文件描述符是标准输入（stdin）、标准输出（stdout）和标准错误（stderr），它们的文件描述符数字分别是 0、1、2。这些数字和相应的设备都是系统保留的，我们可以通过命令 ls -l /dev/std* 查看。
~$ ls -l /dev/std* lrwxrwxrwx 1 root root 15 Oct 16 18:47 /dev/stderr -&amp;gt; /proc/self/fd/2 lrwxrwxrwx 1 root root 15 Oct 16 18:47 /dev/stdin -&amp;gt; /proc/self/fd/0 lrwxrwxrwx 1 root root 15 Oct 16 18:47 /dev/stdout -&amp;gt; /proc/self/fd/1 每个进程看到的 /proc/self 目录下的东西都不一样，因为 /proc/self 实际上是一个指向 /proc/&amp;lt;process_ID&amp;gt; 的符号链接。
输出重定向 COMMAND_OUTPUT &amp;gt;：重定向输出到一个文件。如果文件不存在，则创建并写入，否则覆盖原文件 : &amp;gt; filename：删除（truncate）文件的内容，如果文件不存在，则创建它。: 是一个占位符，代表无。 &amp;gt; filename：和 : &amp;gt; filename 类似，但是在某些 shell 下工作不正常 COMMAND_OUTPUT &amp;gt;&amp;gt;：重定向输出到一个文件，已追加的方式写入 1&amp;gt;filename：重定向标准输出到文件，以覆盖的方式写入 1&amp;gt;&amp;gt;filename：重定向标准输出到文件，以追加的方式写入 2&amp;gt;filename：重定向标准错误到文件，以覆盖的方式写入 2&amp;gt;&amp;gt;filename：重定向标准错误到文件，以追加的方式写入 &amp;amp;&amp;gt;filename：重定向标准输出和标准错误到文件 M&amp;gt;N：重定向文件描述符 M（如果未给出，则默认为 1）对应的文件到文件 N 。注意：M 是一个文件描述符，N 是一个文件。 M&amp;gt;&amp;amp;N：定向文件描述符 M（如果未给出，则默认为 1）对应的文件到文件描述符 N 对应的文件。注意：这里 M 和 N 都是文件描述符 2&amp;gt;&amp;amp;1：重定向标准错误到标准输出 i&amp;gt;&amp;amp;j：重定向文件描述符 i 到 j &amp;gt;&amp;amp;j：重定向标准输出到文件描述符 j 输入重定向 0&amp;lt; filename：从文件获取输入 [j]&amp;lt;&amp;gt;filename：打开文件 filename 进行读写，若该文件不存在则创建它。如果文件描述符 j 未声明，则默认为 0 关闭文件描述符 n&amp;lt;&amp;amp;-：关闭输入文件描述符 n 0&amp;lt;&amp;amp;- 和 &amp;lt;&amp;amp;-：关闭标准输入 n&amp;gt;&amp;amp;-：关闭输出文件描述符 n 1&amp;gt;&amp;amp;- 和 &amp;gt;&amp;amp;-：关闭标准输出 Here documents here document 是一个有着特殊用途的代码块，它告诉 shell 从当前位置读取输入，直到遇到结束字符串。然后，读取到的内容会被用作命令的标准输入。语法如下：</description></item><item><title>Shell 脚本：正则表达式</title><link>https://zhannicholas.github.io/posts/linux/shell_scripting_regular_expressions/</link><pubDate>Wed, 27 Oct 2021 21:10:27 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/shell_scripting_regular_expressions/</guid><description>正则表达式（regular expression, RE）在 Shell 中的应用非常广泛，我们常用的 find、grep、sed、awk 等命令都涉及到正则表达式……
在 Shell 中，表达式就是一个字符串。字符串由字符组成，其中有些字符除了字面含义之外还有特殊含义，这些具有特殊含义的字符就是元字符（metacharacter）。
正则表达式主要用于搜索文本和操作字符串，它包含以下内容：
字符集（character set）。字符集内所有的字符都只具有字面含义，不包括元字符 锚点（anchor）。锚点标识着正则表达式要匹配的文本中的位置，比如 ^ 和 $ 修饰符（modifier）。修饰符的作用是扩展或者缩小正则表达式要匹配的文本的范围，包括星号（*）、方括号（[）和反斜杠（/） 标准正则表达式中的特殊字符 *：匹配前一个字符出现任意次数，包括 0 次 .：匹配除换行符（\n）之外的任何单字符 ^：匹配字符串的开始位置 $：匹配字符串的结束位置 [...]：封装正则表达式中用到的一组字符 \：对特殊字符进行转义，转移后的特殊字符只具备字面含义 \&amp;lt;...\&amp;gt;：标记单词边界 扩展正则表达式中的特殊字符 扩展正则表达式给标准正则表达式中加入了新的元字符，主要用在 egrep、awk 和 Perl 中。
?：匹配前一个字符出现零次或一次 +：匹配前面的子表达式出现一次或多次 \{\}：限定前面的子表达式出现的次数 ()：封装一组正则表达式 |：从一组选择中选择一个，即或的含义 Globbing Bash 本身并不能识别正则表达式，解释正则表达式的是一些像 sed 和 awk 这样的命令和工具。Shell 展开中有一种类型叫文件名展开（filename expansion），但展开的事情并不是 Bash 自己完成的，而是由一个叫做 globbing 的进程完成的。但是 globbing 本身并不能使用标准的正则表达式，它只能识别一些特殊字符（比如 *、?、[]）。这些特殊字符一般称为通配符（wildcards），也叫 globbing 或 pattern matching。需要注意的是：* 并不会匹配以 . 开头的文件名。
参考资料 Bash Guide for Beginners . Advanced Bash-Scripting Guide .</description></item><item><title>Shell 脚本：shell 展开</title><link>https://zhannicholas.github.io/posts/linux/shell_scripting_shell_expansion/</link><pubDate>Sat, 23 Oct 2021 17:15:13 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/shell_scripting_shell_expansion/</guid><description>Bash 和其它 shell 做的工作远不止执行命令那么简单。以下提到的各种展开（expansion）操作发生在 Bash 执行命令之前。准确来说，是在重定向之前，重定向操作完成之后才会真正执行命令。
若命令中存在重定向操作，则 Shell 会在执行命令之前进行处理。管道（|）就是一个很好的例子，Shell 会透明地将上一条命令的 stdout 重定向到下一条命令的 stdin。而与这个重定向操作有关的两条命令根本不知道自己在和谁通信。
在 shell 将读取的命令分割成符号（token）之后，这些符号（或单词）会被展开或解析。Shell 会按照顺序执行八种类型的展开：
Brace expansion Tilde expansion Shell parameter and variable expansion Command substitution Arithmetic expansion Process substitution Word splitting File name expansion 大括号展开 大括号展开的形式为：一个可选的前导符（PREAMBLE）、一组位于一对大括号之间的由逗号分隔的字符串和一个可选的跋（POSTSCRIPT）。例如：
~$ echo sp{el,il,al}l spell spill spall 波浪号展开 如果一个单词以没有被引起来的波浪号（~）开始，则在第一个没有被引起来的斜杠（若没有斜杠，则一直到最后一个字符）之前的字符将被视作波浪号前缀（tidle-prefix）。如果波浪号前缀中没有字符被引起来，那么波浪号前缀中的这些字符就会被当作一个可能的登录用户名。如果这个登录用户名是 null 字符串，则波浪号被替换为 shell 变量 HOME。如果 HOME 变量没有被设置，则替换为执行这个 shell 的用户的主目录。 如果波浪号前缀是”~+“，那么它会被替换为变量 PWD 的值。如果波浪号前缀是”~-“，那么它会被替换为变量 OLDPWD 的值。
参数或变量展开 美元符号（$）用于参数展开、命令替换或算术展开。被展开的参数名或符号可能被包裹在大括号中。 最基本的参数展开的形式是${PARAMETER}。如果我们想在某个变量不存在时创建这个变量，则可以使用${VAR:=value}。
命令替换 命令替换（command substitution）允许我们用命令的输出来替换命令本身，它有两种形式：
$(command) `command` 其中前者工作得更好，是用来取代后者的。</description></item><item><title>Shell 脚本：条件分支与循环</title><link>https://zhannicholas.github.io/posts/linux/shell_scripting_conditional_statements_and_loops/</link><pubDate>Thu, 21 Oct 2021 23:05:45 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/shell_scripting_conditional_statements_and_loops/</guid><description>和其它编程语言类似，bash 也给我们提供了条件语句（conditional statements）。
条件分支 if 在 shell 中，if/then 的语法为：if TEST-COMMANDS; then CONSEQUENT-CONMMANDS; fi。
TEST-COMMANDS 列表执行后，如果它的返回状态是 0，就执行 CONSEQUENT-COMMANDS 列表，其中最后一条命令的退出状态就是整个 if 表达式的返回状态。
在 UNIX/Linux 中，通常用 0 表示成功，非零表示失败。
if/then/else If/then/else 的语法为：if TEST-COMMANDS; then CONSEQUENT-CONMMANDS; else ALTERNATE-CONSEQUENT-COMMANDS; fi
if/then/elif/else if 表达式的完整的语法为：if TEST-COMMANDS; then CONSEQUENT-CONMMANDS; elif MORE-TEST-COMMANDS; then MORE-CONSEQUENT-COMMANDS; else ALTERNATE-CONSEQUENT-COMMANDS; fi
test test 是一个 bash 内置的命令，用于检查文件的类型和进行值的比较。特殊字符 [ 是 test 的同义词。
[] 与 [[]] 的区别在于：[[]]（extended test command）比 [] 更强，它会阻止 shell 进行变量名的分词操作、阻止路径名展开。[ 和 [[ 的类型也不同：
~$ type [ [ is a shell builtin ~$ type [[ [[ is a shell keyword 还有更加有趣的：</description></item><item><title>Shell 脚本：变量</title><link>https://zhannicholas.github.io/posts/linux/shell_scripting_variables/</link><pubDate>Wed, 20 Oct 2021 21:26:46 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/shell_scripting_variables/</guid><description>Shell 脚本用变量（variable）来表示数据，变量仅仅只是一个标签（label），它实际上是一个引用（reference）或指针（pointer），指向着与变量相关联的实际数据所存放的内存地址。 变量的名字就是变量的值的占位符（placehoder），变量的值（value）持有着数据。引用（reference）或检索（retrive）变量的值的操作被称为变量替换（variable substitution）。
变量的名字和值是完全不同的，如果 variable1 是一个变量的名字，那么 $variable1（$variable1 是 ${variable1} 的简单形式）就是对该变量值的引用。$ 符号在这里的作用就是进行变量替换。
按照作用域的不同，变量分为全局变量（global variables）和局部变量（local variables）
全局变量也就是我们通常说的环境变量（environment variables），对所有的 shell 都有效。查看环境变量的命令：env 或 printenv。 局部变量只对当前的 shell 有效。使用 shell 内置的 set 命令（不带任何选项参数）就可以输出所有变量（包括环境变量）和一系列的函数。 创建变量 变量名是大小写敏感的，一般用大写命名全局变量，用小写命名局部变量。变量名可以包含数字，但是不能以数字开头。定义变量的语法为：VARNAME=value。
$ variable1=123 $ echo variable1 variable1 $ echo $variable1 123 $ echo ${variable1} 123 我们经常使用 echo 命令输出某个变量的值。你可能会认为 echo 会计算出变量 variable1 的值，然后将值输出。但事实可不是这样，echo 并不知道变量的值是多少！echo 只负责打印我们传递给它的内容，也就是说，我们传什么给它，它就打印什么。而 shell 会在运行 echo 之前计算出 $variable1 的值，并将结果传给 echo。若 variable1=123，则当我们运行 echo $variable1 时，实际执行的命令是 echo 123。
与我们常用的编程语言不同，shell 中变量定义中的 等号两侧是不能有空格的，否则会出错。这与 shell 对命令的解释有关，例如：</description></item><item><title>Shell 脚本</title><link>https://zhannicholas.github.io/posts/linux/shell_scripting_introduction/</link><pubDate>Wed, 20 Oct 2021 20:45:55 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/shell_scripting_introduction/</guid><description>接下来将会有一系列与 Shell 脚本相关的笔记文章。在之前的工作中，作为一个 Java Boy，我几乎不需要自己编写 Shell 脚本，所以大学学过的 Shell 脚本编程基本忘完（实际上我并没有系统的学过它😂），工作中碰到相关东西时也是 Google 一下就搞定了。但是，现在的工作要求我能够编写 Shell 脚本实现一些自动化操作，所以我决定系统地学习一下 Shell 脚本编程的相关知识。主要参考的学习资料是 The Linux Documentation Project 网站上推荐的两本在线书籍：Bash Guide for Beginners 和 Advanced Bash-Scripting Guide 。前者适合入门，后者适合精进，感谢作者的无私分享。
Shell Shell 既是一个命令解释器（command interpreter），又是一门编程语言。Shell 脚本（shell scripts）是用 shell 编程语言编写的程序，它可以将系统调用、各种工具和已编译的二进制文件粘合在一起，形成新的应用。
Shell 脚本是解释执行的，shell 从脚本中逐行读取命令，然后在系统中昂搜索这些命令并执行。
Shell 有很多种，比如 sh（Bourne Shell）、bash（Bourne Again shell）、csh（C shell）、tcsh（TENEX C shell）、ksh（Korn shell）、tmux 等
查看系统内已经有的 shell：cat /etc/shells。 查看当前用户默认的 shell：cat /etc/passwd | grep $USER | awk 'BEGIN { FS=&amp;quot;:&amp;quot; } { print $7 }。</description></item></channel></rss>