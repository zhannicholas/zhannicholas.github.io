<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Spring Boot on 's Digital Garden</title><link>https://zhannicholas.github.io/tags/spring-boot/</link><description>Recent content in Spring Boot on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 27 Aug 2021 20:36:10 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/tags/spring-boot/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring Boot 中的配置体系</title><link>https://zhannicholas.github.io/posts/java/spring/configurations-in-spring-boot/</link><pubDate>Fri, 27 Aug 2021 20:36:10 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/spring/configurations-in-spring-boot/</guid><description>开发的同学可能都遇到过一个 Spring Boot 应用要在多个环境上部署，而每个环境的配置都不同的情况。比如，开发环境用一套配置，测试环境用另一套配置，生产环境又是一套新配置。如果我们把配置放在同一个地方，然后每次都根据不同的环境进行修改，可能要不了多久，我们的头就大了。因为，我们可能一不小心把开发环境的配置放到测试环境中去了……
为了方便我们在不同环境中运行应用程序，Spring Boot 允许我们将配置信息外部化 。Spring Boot 支持多种外部化的配置源，包括 Java 的 properties 文件、YAML 文件、环境变量和命令行参数。
配置源 既然配置可以来自很多不同的地方，那么就有可能出现同一个配置项在多个配置源中出现的情况。所以 Spring Boot 有一个配置值覆盖规则，优先级高的配置会覆盖优先级低的，优先级从低到高依次为：
默认属性（即通过 SpringApplication.setDefaultProperties 设置的属性） @Configuration 类上的 @PropertySource 注解 配置数据（比如 application.properties）。配置数据文件的优先级如下，当.properties 文件与 .yml 文件同时出现时，前者的优先级会高于后者： Jar 包内的 application.properties 和 application.yml Jar 包内特定 Profile 的 application-{profile}.properties 和 application-{profile}.yml Jar 包外的 application.properties 和 application.yml Jar 包外特定 Profile 的 application-{profile}.properties 和 application-{profile}.yml 由 RandomValuePropertySource 配置的 random.* 属性值 操作系统环境变量 Java 系统属性（System.getProperties()） 来自 java:comp/env 的 JNDI 属性 ServletContext 的初始化参数 ServletConfig 的初始化参数 SPRING_APPLICATION_JSON（环境变量或系统属性中的单行 JSON） 中的属性值 命令行参数 测试上的 properties 属性。在 @SpringBootTest 和其它测试相关注解上有用 测试上的 @TestPropertySource 注解 当 devtools 激活时，$HOME/.</description></item></channel></rss>