<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>算法导论 on Nicholas Zhan</title><link>https://zhannicholas.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</link><description>Recent content in 算法导论 on Nicholas Zhan</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 11 Jul 2018 12:46:30 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/index.xml" rel="self" type="application/rss+xml"/><item><title>产生均匀随机排列的两种方法</title><link>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/two-ways-to-produce-a-uniform-random-permutation/</link><pubDate>Wed, 11 Jul 2018 12:46:30 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/two-ways-to-produce-a-uniform-random-permutation/</guid><description>许多随机算法通过排列给定的输入数组来使输入随机化。这里的目标是构造数组 A 的一个随机排列。 方法一：排序 为数组的每一个元素 A[i] 分配一个随机的优先级</description></item><item><title>通过偏概率0/1生成器，得到无偏概率0/1生成器</title><link>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/%E9%80%9A%E8%BF%8701%E6%9C%89%E5%81%8F%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%97%A0%E5%81%8F%E6%A6%82%E7%8E%87/</link><pubDate>Wed, 11 Jul 2018 09:51:21 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/%E9%80%9A%E8%BF%8701%E6%9C%89%E5%81%8F%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%97%A0%E5%81%8F%E6%A6%82%E7%8E%87/</guid><description>问题描述 这是《算法导论》的习题5.1-3： 假设你希望以各1/2的概率输出0和1。你可以自由使用一个输出0或1的过程BIASED-RANDOM</description></item><item><title>矩阵乘法</title><link>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/matrix-multiplication/</link><pubDate>Mon, 02 Jul 2018 08:44:56 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/matrix-multiplication/</guid><description>矩阵乘法 矩阵相乘只有在第一个矩阵的列数（column）和第二个矩阵的行数（row）相同时才有定义。若 A 为 m x n 矩阵，B为 n x p 矩阵，则他们的</description></item><item><title>最大子数组问题</title><link>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/maximum-sub-array-problem/</link><pubDate>Fri, 29 Jun 2018 10:44:26 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/maximum-sub-array-problem/</guid><description>问题 有一个数组A，寻找一个 A[] 的子数组 B[] ， 使得B的元素和大于A的任何一个子数组。比如A = [13, -3, 25, 20, -4, -20, -25, 18, 20, -5, 16, -5, -22, 18, -6, 8], 我们要求的 B[] 就是：[1</description></item></channel></rss>