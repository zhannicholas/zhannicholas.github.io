<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on 's Digital Garden</title><link>https://zhannicholas.github.io/tags/rust/</link><description>Recent content in Rust on 's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 29 Sep 2021 20:55:48 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust 基础：错误处理</title><link>https://zhannicholas.github.io/posts/rust/rust_basics_error_handling/</link><pubDate>Wed, 29 Sep 2021 20:55:48 +0800</pubDate><guid>https://zhannicholas.github.io/posts/rust/rust_basics_error_handling/</guid><description>任何软件都不可避免地出现各种或大或小的 Bug，软件设计的一大目标就是软件的健壮性，而错误处理就是提高软件健壮性的一大利器。作为一门对安全比较执着的编程语言，Rust 给我们开发者提供了很多处理错误的功能特性。
Rust 中的错误（error）分为两种：可恢复错误（recoverable error）和不可恢复错误（unrecoverable error）。在 Java 中，不仅有错误（error），还有异常（exception），但 Rust 中是没有异常的。对于可恢复错误，Rust 给我们提供了 Result&amp;lt;T, E&amp;gt; 这种数据类型，供我们作进一步决定。而对于不可恢复错误，Rust 给我们提供了一个叫做 panic! 的宏，panic! 会在程序遭遇不可恢复错误时立即停止程序的执行。
不可恢复错误与 panic! 有时候，你碰到的错误（比如数组下标越界）会让你束手无策。这时，你可以使用 Rust 提供的 panic! 宏直接终止程序，防止更坏的事情发生。当 panic! 执行时，Rust 程序默认会先打印出失败信息，解退（unwinding） 并清理栈，然后退出。解退是一种比较优雅退出方式，与之相对的是直接终止（abort）。二者的区别在于，解退会清理数据，归还内存，而直接终止就不会清理数据，回收内存的工作交给了操作系统。
先来看一个简单的 panic!：
fn main() { panic!(&amp;#34;crash and burn&amp;#34;); } 这个程序一运行，就会出现错误信息：
&amp;gt; cargo run Compiling error_handling v0.1.0 (F:\Code\Rust\rust-study\error_handling) Finished dev [unoptimized + debuginfo] target(s) in 3.19s Running `target\debug\error_handling.exe` thread &amp;#39;main&amp;#39; panicked at &amp;#39;crash and burn&amp;#39;, src\main.rs:2:5 note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace error: process didn&amp;#39;t exit successfully: `target\debug\error_handling.</description></item><item><title>Rust 基础：枚举与模式匹配</title><link>https://zhannicholas.github.io/posts/rust/rust_basics_enums_and_patterns_matching/</link><pubDate>Mon, 27 Sep 2021 19:04:33 +0800</pubDate><guid>https://zhannicholas.github.io/posts/rust/rust_basics_enums_and_patterns_matching/</guid><description>枚举（enum or enumeration） 是一种允许我们列举出所有可能的值的数据类型，每一个可能的值都是一个 variant。举个简单的例子，常见的 IP 地址有 IPv4 和 IPv6 两种，这时就可以定义一个表示 IP 地址类型的枚举类。
枚举的定义 我们先来定义一个表示 IP 地址类型的枚举类：
enum IpAddrKind { V4, V6, } 现在我们可以使用刚定义的 IpAddrKind 了。在 Rust 中，枚举类型实例的通过 :: 操作符创建的，:: 的左边是命名空间（枚举类型），右边是枚举类型中的可能值（variant）。例如：
let four = IpAddrKind::V4; let six = IpAddrKind::V6; 在 Rust 中，枚举类型中所有 variant 的类型都是相同的，这一点与其它编程语言有些不同。例如 IpAddrKind::V4 和 IpAddrKind::V6 的类型都是 IpAddrKind。现在的 IpAddrKind 只有类型的含义，并不能存储任何 IP 地址数据，我们把它稍微改造一下：
enum IpAddrKind { V4(String), V6(String), } let home = IpAddrKind::V4(String::from(&amp;#34;127.0.0.1&amp;#34;)); let loopback = IpAddrKind::V6(String::from(&amp;#34;::1&amp;#34;)); 现在，IpAddrKind 都能存储地址数据了。不过它还可以变得更加高级，IPv4 的地址可以用四个 0~255 之间的整数表示：</description></item><item><title>Rust 基础：结构体</title><link>https://zhannicholas.github.io/posts/rust/rust_basics_struct/</link><pubDate>Sun, 26 Sep 2021 20:29:14 +0800</pubDate><guid>https://zhannicholas.github.io/posts/rust/rust_basics_struct/</guid><description>在 Rust 中，结构体（struct or structure） 是一种可自定义的数据类型，允许我们将一组相关数据组织在一起，形成一个有意义的整体。Rust 中的结构体和 C 语言中的结构体或 Java 中对象的数据属性类似。
结构体的定义 虽然 Rust 中的元组（tuple）也可以将一组相关数据组织在一起，但是元组中的各个数据项的含义却不那么直观，因为我们在访问元组中的元素时需要使用下标，而下标是没有任何特定的业务含义的。相比之下，结构体则更要灵活一些，它允许我们给结构体中的每个数据指定一个名字（这有点像键值对了）。
Rust 使用关键字 struct 定义结构体，下面是一个例子：
struct User { username: String, email: String, sign_in_count: u64, active: bool, } 结构体 User 的定义主要由三部分组成：
struct 关键字 结构体的名字，这里是 User 结构体的字段（field）定义，每个字段定义从左到右分别是字段的名字（比如 username）、冒号（:）和字段类型（比如 String），不同字段定义之间用逗号（,）隔开。最后一个逗号是可选的 需要注意的是：结构体的定义末尾不能加分号（;），否则编译器会抛出类似于下面这样的错误：
error: expected item, found `;` --&amp;gt; src\main.rs:6:2 6 | }; | ^ help: remove this semicolon | = help: braced struct declarations are not followed by a semicolon 结构体字段的访问与更新 结构体定义好了，接下来就是使用它。为了使用 User 结构体，我们需要创建一个 User 的实例（instance）：</description></item><item><title>Rust 基础：所有权</title><link>https://zhannicholas.github.io/posts/rust/rust_basics_ownership/</link><pubDate>Sat, 25 Sep 2021 10:51:29 +0800</pubDate><guid>https://zhannicholas.github.io/posts/rust/rust_basics_ownership/</guid><description>所有权（ownership） 是 Rust 独一无二的功能，也是 Rust 中的核心功能之一。Rust 不需要开发者手动回收内存，也没有垃圾收集器，但它还能保证内存安全，这就是所有权的强大之处。
在 Rust 中，内存的管理是通过所有权系统（ownership system）进行的，编译器会在编译时根据一系列的规则进行检查。更加令人赞叹的是，所有权系统中的任何功能都不会减慢程序的运行速度！
栈与堆 在开始学习所有权这个概念之前，我们有必要先回顾一下数据在内存中的存放形式。在 Rust 中，数据被存放在栈（stack）或堆（heap）中。
栈与堆组织数据的方式不同。在栈中，数据时先入后出（FILO）的，即最后存入的数据最先被使用。而在堆中，数据的使用就没有顺序要求，数据在堆中的组织情况比栈中要差很多。此外，存放在栈中的数据占用的空间必须是 编译期间已知且固定的，对于那些大小不固定或编译时无法知道大小的数据，应当被存放在堆上。在我们往堆中存数据时，内存分配器会从堆中找出一块大小合适的内存空间，标记其已使用，然后返回给我们一个指向分配地址的指针，后续我们就可以使用这个指针访问堆中的数据。这个指针会被存储在栈上，因为它的大小是固定且已知的。
将数据存储在栈上的速度要快于存储在堆上的速度。因为当数据被放在栈上时，内存分配器不需要为新数据找出一块空闲空间，数据总是被放在栈顶。如果数据要被放到堆上，内存分配器不仅需要从堆中找出一块合适的空闲空间，还需要防止这块空间被其它数据抢占。类似地，访问栈上数据的速度要快于访问堆上数据的速度。因为堆上的数据需要通过栈上的指针才能定位到，这比栈上的数据多了一次内存访问。
当我们调用一个函数时，传递给函数的值（或指向堆中数据的指针）和函数中的局部变量都是存放在栈上的。当函数调用结束后，这些值都会从栈中弹出。
讲了这么多，现在该所有权出场了。所有权负责 跟踪哪部分代码正在使用堆中的哪部分数据，最大限度地减少堆中的重复数据，清理堆中未使用的数据，防止内存空间被耗尽。简单来说，所有权管理着堆中的数据。
那么，Rust 中的哪些数据会被分配在堆上呢？答案是那些大小在编译期间不可知或者大小不固定的数据，比如字符串类型（String）。标量类型（整型、浮点型、布尔类型和字符类型）或复合类型（元组和数组）的数据都是存放在栈上的，作用域结束时就会被从栈上弹出。
需要注意的是：字符串类型（String）和字符串字面量（string literal）是不同的。字符串字面量（比如 let s = &amp;quot;hello, world&amp;quot;;）是代码中硬编码的（编译时大小已知）、不可变的，而字符串类型的数据被存储在堆上，字符串类型的数据是可变的。我们可以使用 String 的 from 函数从字符串字面量创建一个 String 类型的变量，比如：
fn main() { let mut s = String::from(&amp;#34;hello&amp;#34;); s.push_str(&amp;#34;, world!&amp;#34;); // push_str() appends a literal to a String println!(&amp;#34;{}&amp;#34;, s); // This will print `hello, world!` } 所有权规则 所有权的规则如下，它们不可被违反：
Rust 中的每个值都有一个变量，这个变量就是这个值的 所有者（owner） 每个值在同一时刻有且只有一个所有者 当所有者（变量）超出作用域（scope），值就会被丢弃（drop），值占据的内存被归还 变量在进入作用域后开始生效，此后，变量在超出作用域之前一直都是有效的。举个例子：</description></item><item><title>Rust 基础：控制流</title><link>https://zhannicholas.github.io/posts/rust/rust_basics_control_flow/</link><pubDate>Sun, 05 Sep 2021 08:28:14 +0800</pubDate><guid>https://zhannicholas.github.io/posts/rust/rust_basics_control_flow/</guid><description>几乎所有的编程语言中都有控制流（control flow）的概念，控制流即根据条件的成立与否决定代码的执行逻辑。在 Rust 中，控制流分为 if 表达式和循环。
if 表达式 一个简单的 if if 表达式告诉程序：如果条件成立，则执行某段代码，否则不执行那段代码。举个例子：
fn main() { let condition = true; if condition { println!(&amp;#34;The condition was true.&amp;#34;) } } 使用 cargo run 运行这段代码，程序的输出结果是：
The condition was true. 但如果你将 let condition = true; 替换成 let condition = false;，就不会看到任何输出。
在 Rust 中，所以的 if 表达式都以关键字 if 开头，随后是一个 bool 类型的条件，条件满足时执行的代码放在条件后面的尖括号里。Rust 要求条件的数据类型必须是布尔类型，因为 Rust 不会自动进行非布尔类型到布尔类型的值转换。所以，以下代码是不会通过编译的：
fn main() { let number = 1; if number { println!(&amp;#34;The value of number is: {}&amp;#34;, number); } } 使用 else 我们也可以给 if 表达式加一个可选的 else 表达式，用来告知程序当条件不满足的时候应该执行何种操作。例如：</description></item><item><title>Rust 基础：函数</title><link>https://zhannicholas.github.io/posts/rust/rust_basics_functions/</link><pubDate>Sat, 04 Sep 2021 15:34:41 +0800</pubDate><guid>https://zhannicholas.github.io/posts/rust/rust_basics_functions/</guid><description>在 Rust 中，函数无处不在。我们学习“Hello, world!”时接触到的 main 函数就是 Rust 中最重要的函数。我们也知道，声明 main 函数的时候需要用到关键字 fn。实际上，Rust 中的所有函数都是通过 fn 声明的。
在正式学习函数之前，有必要先了解一下 Rust 中的函数与变量命名风格。不同于 Java 中的驼峰命名（camel case），Rust 中推崇使用蛇形命名（snake case）。在蛇形命名中，所有字母都是小写的，单词之间使用下划线（_）分隔，比如 hello_world。
一个简单的函数 下面代码展示了一个简单地无参函数的使用：
fn main() { println!(&amp;#34;Hello, world!&amp;#34;); another_function(); } fn another_function() { println!(&amp;#34;Another function.&amp;#34;); } 使用 cargo run 运行程序，结果如下：
Hello, world! Another function. 代码中定义的 another_function 的定义出现在 main 函数之后，它还可以出现在 main 函数之前。其实，Rust 并不关心我们在何处定义函数，只要它能找到就行。
再来看一下 another_function 的组成：首先是 fn 关键字，往后是函数名，函数名后跟了一对圆括号，最后则是有尖括号包裹的函数体。因为 another_function 不需要任何参数，所以圆括号内没有任何内容。
函数参数 Rust 中的函数是可以有参数的，我们只需要把参数信息放到函数名后面的圆括号中，就可以在函数体中使用它们了。例如，我们可以对 another_function 稍加改造，把它变成一个有参函数：
fn main() { another_function(5); } fn another_function(x: i32) { println!</description></item><item><title>Rust 基础：变量与数据类型</title><link>https://zhannicholas.github.io/posts/rust/rust_basics_variables_and_data_types/</link><pubDate>Fri, 03 Sep 2021 21:32:35 +0800</pubDate><guid>https://zhannicholas.github.io/posts/rust/rust_basics_variables_and_data_types/</guid><description>变量 变量与可变性 在 Rust 中，变量（variables）有两种：
不可变变量：一经赋值，就不再允许对变量的值进行修改 可变变量：可可对变量的值进行多次修改 在 Rust 中，我们使用 let 关键字声明一个变量，例如：let x = 1。默认情况下，let 声明的变量是 不可变的。如果代码里面出现不可变变量被多次赋值的情况，则代码是不会编译通过的。例如：
fn main() { let x = 5; println!(&amp;#34;The value of x is: {}&amp;#34;, x); x = 6; println!(&amp;#34;The value of x is: {}&amp;#34;, x); } 如果使用 cargo run 运行这段代码，则会出现以下错误：
&amp;gt; cargo run Compiling variables v0.1.0 (F:\Code\Rust\rust-study\variables) error[E0384]: cannot assign twice to immutable variable `x` --&amp;gt; src\main.rs:4:5 | 2 | let x = 5; | - | | | first assignment to `x` | help: consider making this binding mutable: `mut x` 3 | println!</description></item><item><title>Hello, Rust!</title><link>https://zhannicholas.github.io/posts/rust/hello_rust/</link><pubDate>Thu, 02 Sep 2021 19:45:08 +0800</pubDate><guid>https://zhannicholas.github.io/posts/rust/hello_rust/</guid><description>年初学过几天 Rust，走马观花，很快就忘完了。现在有了些空闲时间，准备重新好好地把 Rust 学一遍，为后续操作系统的深入学习做好铺垫。在此之前，我主要写 Java，几乎所有的 Java 开发者都有过内存溢出（OOM）或内存泄露的噩梦。为了避免各种内存问题，Java 开发者通常需要熟悉垃圾回收，以及如何进行垃圾收集器的调优。当我第一次遇到 Rust 的时候，就被 Rust 惊人的运行速度和极高的内存利用率所吸引，这门语言居然没有运行时（runtime）和垃圾回收器（garbage collector），多么地神奇！
安装 Rust 学习一门编程语言的最佳方式就是实践。在实践之前，我们需要准备好相应的开发环境。Rust 推荐我们使用 &amp;lt;code&amp;gt;rustup&amp;lt;/code&amp;gt; 安装 Rust。rustup 是一个命令行工具，用于管理 Rust 版本和相关的其它工具。在 Windows 平台上，我只需要先下载 rustup，运行它，然后根据提示一步一步操作即可。除了 rustup，还有很多其它的安装方法，具体可以参考官方文档 。
安装完成后，我们可以通过 rustc --version 检查是否安装成功。若控制台输出了 rustc x.y.z (abcabcabc yyyy-mm-dd) 形式的版本号，则表示安装成功。
rustup rustup 是一个很有用的工具，它给我们提供了很多实用的功能。
更新 Rust 到最新版本：rustup update 卸载 Rust 和 rustup：rustup self uninstall 查看 Rust 的本地文档：rustup doc Hello, world! 从大学的 C/C++，到后来的 Java、Python，我们学习一门新的编程语言几乎都是从“Hello, world!”开始。下面来写一个 Rust 版本的“Hello, world!”。
为了组织好代码，我们通常会将不同的代码放到不同的文件夹中。先给“Hello, world!”创建一个文件夹 hello_world：
&amp;gt; mkdir hello_world &amp;gt; cd hello_world 现在，创建 Rust 的源代码文件，这里我管它叫 hello_world.</description></item></channel></rss>