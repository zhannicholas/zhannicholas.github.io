<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on NZ's Digital Garden</title><link>https://zhannicholas.github.io/tags/rust/</link><description>Recent content in Rust on NZ's Digital Garden</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 04 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://zhannicholas.github.io/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Programming Rust, 2nd Edition - Crates and Modules</title><link>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-crates-and-modules/</link><pubDate>Tue, 04 Apr 2023 00:00:00 +0000</pubDate><guid>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-crates-and-modules/</guid><description>Crates Rust programs are made of crates. Each crate is a complete, cohesive unit: all the source code for a single library or executable, plus any associated tests, examples, tools, configuration, and other junk
The easiest way to see what crates are and how they work together is to use cargo build with the --verbose flag to build an existing project that has some dependencies.
A project&amp;rsquo;s dependencies are declared in Cargo.</description></item><item><title>Programming Rust, 2nd Edition - Enums and Patterns</title><link>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-enums-and-patterns/</link><pubDate>Tue, 04 Apr 2023 00:00:00 +0000</pubDate><guid>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-enums-and-patterns/</guid><description>Enums A Rust enum can contain not only type, but also data, even data of varying types.
The values in a Rust enum are called variants or constructors.
In all, Rust has three kinds of enum variant:
Variants with no data correspond to unit-like structs. Tuple variants look and function just like tuple structs.
Struct variants have curly braces and named fields.
A single enum can have variants of all three kinds.</description></item><item><title>Programming Rust, 2nd Edition - Error Handling</title><link>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-error-handling/</link><pubDate>Tue, 04 Apr 2023 00:00:00 +0000</pubDate><guid>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-error-handling/</guid><description>Rust has two kinds of error handling: panic and Results.
Ordinary errors are handled using the Result type. Result s typically represent problems caused by things outside the program. Panic is for the other kind of error, the kind that should never happen.
Panic A program panics when it encounters something so messed up that there must be a bug in the program itself.
There’s a macro panic!() , for cases where your own code discovers that it has gone wrong, and you therefore need to trigger a panic directly.</description></item><item><title>Programming Rust, 2nd Edition - Expressions</title><link>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-expressions/</link><pubDate>Tue, 04 Apr 2023 00:00:00 +0000</pubDate><guid>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-expressions/</guid><description>Most things in Rust are expressions. expressions are the building blocks that make up the body of Rust functions and thus the majority of Rust code.
Expressions have values. Statements don’t.
Precedence and Associativity Like most programming languages, Rust has operator precedence to determine the order of operations when an expression contains multiple adjacent operators.
The following table summarizes Rust expression syntax. In the table, operators are listed in order of precedence, from highest to lowest.</description></item><item><title>Programming Rust, 2nd Edition - Fundamental Types</title><link>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-fundamental-types/</link><pubDate>Tue, 04 Apr 2023 00:00:00 +0000</pubDate><guid>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-fundamental-types/</guid><description>Example of types in Rust Type Description Values i8 , i16 , i32 , i64 , i128 , u8 , u16 , u32 , u64 , u128 Signed and unsigned integers, of given bit width 42 , -5i8 , 0x400u16 , 0o100i16 , 20_922_789_888_000u64 , b'*' ( u8 byte literal) isize , usize Signed and unsigned integers, the same size as an address on the machine (32 or 64 bits)</description></item><item><title>Programming Rust, 2nd Edition - Operator Overloading</title><link>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-operator-overloading/</link><pubDate>Tue, 04 Apr 2023 00:00:00 +0000</pubDate><guid>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-operator-overloading/</guid><description>Rust supports Operator Overloading, what we need to to is implementing a few traits according to our requirements. Summary of traits for operator overloading:
Category Trait Operator(Expression) Equivalent expression Unary operators std::ops::Neg -x x.neg() std::ops::Not !x x.not() Arithmetic operators std::ops::Add x + y x.add(y) std::ops::Sub x - y x.sub(y) std::ops::Mul x * y x.mul(y) std::ops::Div x / y x.div(y) std::ops::Rem x % y x.rem(y) Bitwise operators std::ops::BitAnd x &amp;amp; y x.</description></item><item><title>Programming Rust, 2nd Edition - Ownership and Moving</title><link>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-ownership-and-moving/</link><pubDate>Tue, 04 Apr 2023 00:00:00 +0000</pubDate><guid>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-ownership-and-moving/</guid><description>When it comes to managing memory, there are two characteristics we’d like from our programing languages:
We ʼ d like memory to be freed promptly, at a time of our choosing. This gives us control over the program’s memory consumption.
We never want to use a pointer to an object after it’s been freed. This would be undefined behavior, leading to crashes and security holes.
Ownership In Rust, the concept of ownership is built into the language itself and enforced by compile-time checks.</description></item><item><title>Programming Rust, 2nd Edition - References</title><link>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-references/</link><pubDate>Tue, 04 Apr 2023 00:00:00 +0000</pubDate><guid>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-references/</guid><description>Rust has non-owning pointer types called references, which have no effect on their referents’ lifetimes.
You must make it apparent in your code that no reference can possibly outlive the value it points to. To emphasize this, Rust refers to creating a reference to some value as borrowing the value: what you have borrowed, you must eventually return to its owner.
Reference to Values A reference lets you access a value without affecting its ownership.</description></item><item><title>Programming Rust, 2nd Edition - Structs</title><link>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-structs/</link><pubDate>Tue, 04 Apr 2023 00:00:00 +0000</pubDate><guid>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-structs/</guid><description>Rust structs, sometimes called structures, assemble several values of assorted types together into a single value so you can deal with them as a unit. Given a struct, you can read and modify its individual components. And a struct can have methods associated with it that operate on its components.
Rust has three kinds of struct types, named-field, tuple-like, and unit-like, which differ in how you refer to their components:</description></item><item><title>Programming Rust, 2nd Edition - Traits and Generics</title><link>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-traits-and-generics/</link><pubDate>Tue, 04 Apr 2023 00:00:00 +0000</pubDate><guid>https://zhannicholas.github.io/pages/programming-rust-2nd-edition-traits-and-generics/</guid><description>Rust supports polymorphism with two related features: traits and generics.
Traits are Rust’s take on interfaces or abstract base classes. A generic function or type can be used with values of many different types.
Generics and traits are closely related: generic functions use traits in bounds to spell out what types of arguments they can be applied to.
Using Traits A trait is a feature that any given type may or may not support.</description></item></channel></rss>