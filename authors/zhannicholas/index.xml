<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>zhannicholas on Nicholas Zhan</title><link>https://zhannicholas.github.io/authors/zhannicholas/</link><description>Recent content in zhannicholas on Nicholas Zhan</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 27 Apr 2021 20:38:39 +0800</lastBuildDate><atom:link href="https://zhannicholas.github.io/authors/zhannicholas/index.xml" rel="self" type="application/rss+xml"/><item><title>线程安全性</title><link>https://zhannicholas.github.io/posts/java/concurrency/thread_safety/</link><pubDate>Tue, 27 Apr 2021 20:38:39 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/concurrency/thread_safety/</guid><description>我们在工作中经常听人提起线程安全，但线程安全似乎没有一个明确的定义。Java Concurrency in Practice 这本 Java 并发宝典是这样解释线程安全的： 当多个线程访问某个类时</description></item><item><title>生产者消费者模式</title><link>https://zhannicholas.github.io/posts/java/concurrency/producer_consumer_pattern/</link><pubDate>Mon, 26 Apr 2021 22:44:40 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/concurrency/producer_consumer_pattern/</guid><description>生产者/消费者模式（Producer/Consumer Pattern）是一种非常常见的程序设计模式，广泛用于消息队列、解耦等场景中。简单来说</description></item><item><title>Java 对象的一生</title><link>https://zhannicholas.github.io/posts/java/jvm/java_object_lifecycle/</link><pubDate>Wed, 21 Apr 2021 23:30:52 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jvm/java_object_lifecycle/</guid><description>The Truth About Garbage Collection 这篇文章挺好的，本文的很多内容也是基于这篇文章而来。 Java 是一门面向对象的编程语言，在程序的运行过程中，不断有新的对象被创建出来，也不</description></item><item><title>Java 中的引用与对象可达性</title><link>https://zhannicholas.github.io/posts/java/java_lang/references_and_reachability_in_java/</link><pubDate>Tue, 20 Apr 2021 21:40:00 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/java_lang/references_and_reachability_in_java/</guid><description>JDK 1.2 之后，Java 将引用分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Refere</description></item><item><title>JDBC</title><link>https://zhannicholas.github.io/posts/java/jdbc/jdbc/</link><pubDate>Sun, 18 Apr 2021 23:00:39 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jdbc/jdbc/</guid><description>JDBC（Java DataBase Connectivity）是 Java 程序与关系型数据库交互的统一 API，它由两部分 API 组成： 面向 Java 开发者的 Java API，这一部分 API 独</description></item><item><title>Mybatis</title><link>https://zhannicholas.github.io/notebook/mybatis/</link><pubDate>Mon, 22 Mar 2021 23:58:56 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/mybatis/</guid><description>之所以放在 Notebook 中，是因为本文的绝大部分内容来自某网课，做笔记备忘，便于以后碰到相关问题更快地定位和排查问题。 MyBatis 三层架构 MyBatis 的整体架构分为三层，分</description></item><item><title>内存虚拟化</title><link>https://zhannicholas.github.io/notebook/reading_notes/ostep/virtualization-memory/</link><pubDate>Fri, 19 Mar 2021 22:36:40 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/ostep/virtualization-memory/</guid><description>地址空间 操作系统为用户提供了一个易于使用的物理内存抽象，这个抽象叫做 地址空间（address space）。在系统中，地址空间是运行的程序看到</description></item><item><title>CPU 虚拟化</title><link>https://zhannicholas.github.io/notebook/reading_notes/ostep/virtualization-cpu/</link><pubDate>Mon, 15 Mar 2021 21:28:39 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/ostep/virtualization-cpu/</guid><description>进程 进程即运行中的程序。程序本身是没有生命周期的，它只是存在磁盘上的一些指令（也可能是一些静态数据）。事实表明，人们通常希望同时运行多个程序</description></item><item><title>Introduction to Operating Systems</title><link>https://zhannicholas.github.io/notebook/reading_notes/ostep/introduction_to_operating_systems/</link><pubDate>Sun, 14 Mar 2021 23:03:01 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/ostep/introduction_to_operating_systems/</guid><description>程序运行时会发生什么？ 一个正在运行的程序会做一件非常简单的事情：执行指令。处理器从内存中取出（fetch）一条指令，对其进行解码（decod</description></item><item><title>超级搜索术</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%B6%85%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%9C%AF/</link><pubDate>Mon, 08 Mar 2021 23:09:31 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%B6%85%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%9C%AF/</guid><description>人生中 99% 的问题早已有答案，你只要搜索就好。只要你去搜索，就能一直站在巨人的肩膀上去寻求新突破，做出微创新。 ——朱丹 前言 朱丹老师的《超级搜索术</description></item><item><title>Building Abstractions with Functions</title><link>https://zhannicholas.github.io/notebook/reading_notes/sicp_in_python/building_abstractions_with_functions/</link><pubDate>Sun, 13 Dec 2020 20:16:09 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/sicp_in_python/building_abstractions_with_functions/</guid><description>1.1 Introduction The nature of computers is described in Stanford&amp;rsquo;s introductory course as: The fundamental equation of computers is: computer = powerful + stupid. Computers are very powerful, looking at volumes of data very quickly. Computers can perform billions of operations per second, where each operation is pretty simple. Computers are also shockingly stupid and fragile. The operations that they can do are extremely rigid, simple, and mechanical. The computer</description></item><item><title>自旋锁</title><link>https://zhannicholas.github.io/notebook/reading_notes/the_art_of_multiprocessor_programming/spinlock/</link><pubDate>Sun, 13 Dec 2020 20:13:13 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/the_art_of_multiprocessor_programming/spinlock/</guid><description>任何互斥协议都会面临一个问题：当无法获得锁时，该怎么做？有两种方案：一种是继续进行尝试，这种锁称为 自旋锁（spin lock），反复检测锁的这</description></item><item><title>Amdahl定律</title><link>https://zhannicholas.github.io/notebook/reading_notes/the_art_of_multiprocessor_programming/amdahls_law/</link><pubDate>Sun, 13 Dec 2020 20:11:57 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/the_art_of_multiprocessor_programming/amdahls_law/</guid><description>加速比 : 对于某一项工作，加速比指的是一个处理器完成该工作所用的时间与采用n个处理器并行完成该工作所用时间的比值。 Amdahl定律给出了n个处</description></item><item><title>将Tomcat源码导入IDEA</title><link>https://zhannicholas.github.io/posts/getting_started/import_tomcat_source_code_into_intellij/</link><pubDate>Sun, 13 Dec 2020 20:06:09 +0800</pubDate><guid>https://zhannicholas.github.io/posts/getting_started/import_tomcat_source_code_into_intellij/</guid><description>这里记录了将Tomcat源码导入IDEA并启动容器的过程。 准备环境 为了将Tomcat的源码导入IDEA，我们需要先准备好JDK、Intell</description></item><item><title>Security</title><link>https://zhannicholas.github.io/notebook/reading_notes/modern_operating_systems/security/</link><pubDate>Sun, 13 Dec 2020 19:59:39 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/modern_operating_systems/security/</guid><description>安全环境 威胁 信息系统的安全性目标通常可以分解为三个部分: 机密性(confidentiality)：是机密的数据处于保密状态。系统应该保证数据</description></item><item><title>多处理机系统</title><link>https://zhannicholas.github.io/notebook/reading_notes/modern_operating_systems/multiple_processor_systems/</link><pubDate>Sun, 13 Dec 2020 19:56:36 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/modern_operating_systems/multiple_processor_systems/</guid><description>从计算机诞生之日起，人们就无休止地追求着更强大地计算能力。过去地解决方案是使时钟走得更快，但是现在时钟速度已经很难再进一步提升了。计算机虽然</description></item><item><title>Design concepts for engineers</title><link>https://zhannicholas.github.io/notebook/reading_notes/design_concepts_for_engineers/</link><pubDate>Sun, 13 Dec 2020 19:52:15 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/design_concepts_for_engineers/</guid><description>Taken from Design Concepts for Engineers (Fifth Edition) 2020.11.22 第1章 工程是什么 作为一名有抱负的工程师，你有很多需要学习的东西。你必须掌握工程的基础知识：数学、物理、化学和生物。你必须学</description></item><item><title>虚拟机</title><link>https://zhannicholas.github.io/posts/operating_systems/virtualization/virtual_machines/</link><pubDate>Sun, 13 Dec 2020 19:45:38 +0800</pubDate><guid>https://zhannicholas.github.io/posts/operating_systems/virtualization/virtual_machines/</guid><description>虚拟化的主要思想是 虚拟机监视程序(Virtual Machine Monitor, VMM) 在同一物理机上创建出有多台(虚拟)机器的假象，VMM又称虚拟机管理程序(hypervi</description></item><item><title>虚拟化</title><link>https://zhannicholas.github.io/posts/operating_systems/virtualization/virtualization/</link><pubDate>Sun, 13 Dec 2020 19:44:17 +0800</pubDate><guid>https://zhannicholas.github.io/posts/operating_systems/virtualization/virtualization/</guid><description>虚拟化技术允许在一台物理机上创建多台虚拟机器。这些虚拟机器本身并不拥有物理资源，但它们却可以像普通的机器一样完成任务，每台虚拟器都不知道其它</description></item><item><title>进程与线程</title><link>https://zhannicholas.github.io/posts/operating_systems/processes_management/processes_and_threads/</link><pubDate>Sun, 13 Dec 2020 19:36:01 +0800</pubDate><guid>https://zhannicholas.github.io/posts/operating_systems/processes_management/processes_and_threads/</guid><description>操作系统中最核心的概念是进程：这是对正在运行的程序的一个抽象。线程和进程类似，不过它更轻量。 进程 **进程(process)**是对正在运行的</description></item><item><title>死锁</title><link>https://zhannicholas.github.io/posts/operating_systems/processes_management/deadlocks/</link><pubDate>Sun, 13 Dec 2020 19:18:38 +0800</pubDate><guid>https://zhannicholas.github.io/posts/operating_systems/processes_management/deadlocks/</guid><description>在多道程序设计环境中，多个线程可能会争夺有限的资源。线程先请求资源，若请求不能被立即满足，线程就会进入等待状态。有时候，两个线程各自持有不同</description></item><item><title>主存</title><link>https://zhannicholas.github.io/posts/operating_systems/memory_management/main_memory/</link><pubDate>Sun, 13 Dec 2020 19:01:49 +0800</pubDate><guid>https://zhannicholas.github.io/posts/operating_systems/memory_management/main_memory/</guid><description>物理地址与虚拟地址 Computer Systems: A Programmer&amp;rsquo;s Perspective 一书中是这么描述物理地址的：计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组，每个字节都有一个唯</description></item><item><title>Operating Systems</title><link>https://zhannicholas.github.io/posts/operating_systems/operating_systems/</link><pubDate>Sun, 13 Dec 2020 18:57:36 +0800</pubDate><guid>https://zhannicholas.github.io/posts/operating_systems/operating_systems/</guid><description>计算机系统由硬件系统和软件系统两大部分组成。硬件包括处理器、主存、磁盘、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备等。操作系</description></item><item><title>HotSpot VM中的内存管理(J2SE 5.0)</title><link>https://zhannicholas.github.io/posts/java/jvm/memory_management_in_javase5/</link><pubDate>Sun, 13 Dec 2020 18:44:54 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jvm/memory_management_in_javase5/</guid><description>这篇笔记的主要内容来自Memory Management in the Java HotSpot VM。其主要讲的是J2SE 5.0中HotSpot VM的内存管理，文章中描述了J2SE5.0中的垃</description></item><item><title>HotSpot引擎架构</title><link>https://zhannicholas.github.io/posts/java/jvm/hotspot_engine_architecture/</link><pubDate>Sun, 13 Dec 2020 18:43:36 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jvm/hotspot_engine_architecture/</guid><description>这篇笔记主要来自于The Java HotSpot Performance Engine Architecture，感觉主要是在讲JDK8中的HotSpot VM。 Java HotSpot VM原来是Sun公司为Java平</description></item><item><title>垃圾回收调优指南(Java SE 8)</title><link>https://zhannicholas.github.io/posts/java/jvm/garbage_collection_tuning_guide_in_javase8/</link><pubDate>Sun, 13 Dec 2020 18:40:26 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jvm/garbage_collection_tuning_guide_in_javase8/</guid><description>这篇笔记地主要内容来自Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide。文章中介绍了一些调优目标以及HotSpot VM在JDK 8中提供的一些垃圾收集器，</description></item><item><title>Java线程池</title><link>https://zhannicholas.github.io/posts/java/concurrency/thread_pool/</link><pubDate>Sun, 13 Dec 2020 18:35:11 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/concurrency/thread_pool/</guid><description>线程池是管理一组同构工作线程的资源池，内部主要分为四部分： 线程池管理器：负责线程池的创建、销毁、添加任务等管理工作。 工作队列（Work Que</description></item><item><title>Thread</title><link>https://zhannicholas.github.io/posts/java/concurrency/thread/</link><pubDate>Sun, 13 Dec 2020 18:32:20 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/concurrency/thread/</guid><description>进程（process）是资源分配的基本单元，而线程（thread）是程序执行的基本单元。一个进程可以包含多个线程，多个线程之间共享进程的资源</description></item><item><title>同步</title><link>https://zhannicholas.github.io/posts/java/concurrency/synchronization/</link><pubDate>Sun, 13 Dec 2020 18:31:16 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/concurrency/synchronization/</guid><description>Java语言提供了多种线程间通信机制（同步、while轮询、等待/通知、管道等等），其中最基础的通信方式就是 同步（synchronizati</description></item><item><title>Locks</title><link>https://zhannicholas.github.io/posts/java/concurrency/locks/</link><pubDate>Sun, 13 Dec 2020 18:29:44 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/concurrency/locks/</guid><description>文章中涉及的源代码摘自 OpenJdk 11。 乐观锁与悲观锁 乐观锁与悲观锁是一种广义上的概念，体现了我们看待线程同步的不同角度。 乐观锁 乐观锁采用的思想是：冲</description></item><item><title>Java 代理</title><link>https://zhannicholas.github.io/posts/java/java_lang/proxy/</link><pubDate>Sun, 13 Dec 2020 18:25:38 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/java_lang/proxy/</guid><description>Wikipedia 中是这样描述 Proxy 的： A proxy, in its most general form, is a class functioning as an interface to something else. The proxy could interface to anything: a network connection, a large object in memory, a file, or some other resource that is expensive or impossible to duplicate. In short, a proxy is a wrapper or agent object that is being called by the</description></item><item><title>反射</title><link>https://zhannicholas.github.io/posts/java/java_lang/reflection/</link><pubDate>Sun, 13 Dec 2020 18:22:56 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/java_lang/reflection/</guid><description>反射(Reflection) 是Java语言的一大特性，它允许Java程序在运行过程中获取自身的相关信息，还能改变程序的内部属性。我们可以使用</description></item><item><title>Cloning Objects</title><link>https://zhannicholas.github.io/posts/java/java_lang/cloning_objects/</link><pubDate>Sun, 13 Dec 2020 18:19:11 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/java_lang/cloning_objects/</guid><description>通过克隆（Clone），我们可以快速构建出一个已有对象的副本。 浅克隆 VS 深克隆 浅克隆（Shadow Clone） 或 浅复制（Shallow Copy</description></item><item><title>Nested Classes</title><link>https://zhannicholas.github.io/posts/java/java_lang/nested_classes/</link><pubDate>Sun, 13 Dec 2020 18:18:04 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/java_lang/nested_classes/</guid><description>Java允许我们在一个类中定义另一个类，后者被称为嵌套类（nested class）。嵌套类可以分为两种： 静态内部类（static nested class</description></item><item><title>What is Servlet</title><link>https://zhannicholas.github.io/posts/java/jakartaee/what_is_servlet/</link><pubDate>Sun, 13 Dec 2020 18:07:45 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jakartaee/what_is_servlet/</guid><description>A servlet is a Java™ technology-based Web component, managed by a container, that generates dynamic content. 和其它基于Java的组件一样，Servlet也由Java类组成，这些Java类(.class文件)会</description></item><item><title>The Servlet Interface</title><link>https://zhannicholas.github.io/posts/java/jakartaee/the_servlet_interface/</link><pubDate>Sun, 13 Dec 2020 18:04:42 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jakartaee/the_servlet_interface/</guid><description>**Servlet接口是Java Servlet API的核心抽象，所有的Servlet都直接或间接地实现它。GenericServlet**和 **Http</description></item><item><title>About Jakarta EE</title><link>https://zhannicholas.github.io/posts/java/jakartaee/about/</link><pubDate>Sun, 13 Dec 2020 18:03:23 +0800</pubDate><guid>https://zhannicholas.github.io/posts/java/jakartaee/about/</guid><description>Java EE(Java Platform, Enterprise Edition)是构建在Java SE之上的一套企业级标准，早期被称为J2EE(Java 2 Platform Enterprise Edition)，现在则被称为Jakar</description></item><item><title>Redis中的事务</title><link>https://zhannicholas.github.io/posts/databases/redis/transactions/</link><pubDate>Sun, 13 Dec 2020 17:52:50 +0800</pubDate><guid>https://zhannicholas.github.io/posts/databases/redis/transactions/</guid><description>Redis中提供了5个和事务相关的命令：MULTI、EXEC、DISCARD、**WATCH key [key ...]**和 UNWATCH。Redis事务</description></item><item><title>Redis Streams</title><link>https://zhannicholas.github.io/posts/databases/redis/redis_streams/</link><pubDate>Sun, 13 Dec 2020 17:49:38 +0800</pubDate><guid>https://zhannicholas.github.io/posts/databases/redis/redis_streams/</guid><description>作为Redis 5.0中推出的全新数据结构，stream的行为就像append-only log一样，但它由基数树(radix tree)实现。s</description></item><item><title>Redis数据结构</title><link>https://zhannicholas.github.io/posts/databases/redis/redis_datastructures/</link><pubDate>Sun, 13 Dec 2020 17:47:33 +0800</pubDate><guid>https://zhannicholas.github.io/posts/databases/redis/redis_datastructures/</guid><description>Redis的键是一个字符串。在Redis中，字符串二进制安全的，也就是说：Redis中的字符串可以是任何二进制序列，即可以是任何类型的数据(</description></item><item><title>Publish/Subscribe</title><link>https://zhannicholas.github.io/posts/databases/redis/publish_subscribe/</link><pubDate>Sun, 13 Dec 2020 17:45:33 +0800</pubDate><guid>https://zhannicholas.github.io/posts/databases/redis/publish_subscribe/</guid><description>Redis通过 PUBLISH、**SUBSCRIBE**等命令实现了发布-订阅模式，这个功能提供了两种信息机制：simple syndicat</description></item><item><title>Redis Lua 脚本</title><link>https://zhannicholas.github.io/posts/databases/redis/lua_scripting/</link><pubDate>Sun, 13 Dec 2020 17:41:46 +0800</pubDate><guid>https://zhannicholas.github.io/posts/databases/redis/lua_scripting/</guid><description>Redis支持在服务端使用Lua解释器执行Lua脚本。Redis本身已经提供了非常多的命令，而Lua脚本可以帮助我们使用Lua提供的语言特性</description></item><item><title>Jedis</title><link>https://zhannicholas.github.io/posts/databases/redis/jedis/</link><pubDate>Sun, 13 Dec 2020 17:40:18 +0800</pubDate><guid>https://zhannicholas.github.io/posts/databases/redis/jedis/</guid><description>Jedis是一个Java编写的Redis客户端，提供了完整的Redis API。Redis客户端通常需要具备三种能力：管理Redis连接、实现</description></item><item><title>事务</title><link>https://zhannicholas.github.io/posts/databases/fundamentals/transactions/</link><pubDate>Sun, 13 Dec 2020 17:35:30 +0800</pubDate><guid>https://zhannicholas.github.io/posts/databases/fundamentals/transactions/</guid><description>本文中绝大部分内容和图片都来自 High Performance Java Persistence: Get the most out of your persistence layer。 事务是由一组读写操作组成的一个不可分割的执行单元，这组操作要么全部成功，要么</description></item><item><title>URI与资源</title><link>https://zhannicholas.github.io/posts/computer_networks/http/uri_and_resources/</link><pubDate>Sun, 13 Dec 2020 17:25:35 +0800</pubDate><guid>https://zhannicholas.github.io/posts/computer_networks/http/uri_and_resources/</guid><description>Web资源 Web资源（Web resource），或资源（resource）是一个非常宽泛的概念，它代表一个可以被识别的东西。WikiPedi</description></item><item><title>代理</title><link>https://zhannicholas.github.io/posts/computer_networks/http/proxies/</link><pubDate>Sun, 13 Dec 2020 17:19:57 +0800</pubDate><guid>https://zhannicholas.github.io/posts/computer_networks/http/proxies/</guid><description>Web代理（Proxy） 服务器是网络中的中间实体，位于客户端与服务器之间，扮演的是“中间人”的角色，负责在各端点之间来回传送HTTP报文。 W</description></item><item><title>HTTP 报文</title><link>https://zhannicholas.github.io/posts/computer_networks/http/http_messages/</link><pubDate>Sun, 13 Dec 2020 17:15:44 +0800</pubDate><guid>https://zhannicholas.github.io/posts/computer_networks/http/http_messages/</guid><description>用于HTTP协议交互的信息被称为HTTP报文（HTTP Messages）。客户端发出的HTTP叫做请求报文（或Requests），服务端发出</description></item><item><title>HTTP 认证</title><link>https://zhannicholas.github.io/posts/computer_networks/http/http_authentication/</link><pubDate>Sun, 13 Dec 2020 17:14:07 +0800</pubDate><guid>https://zhannicholas.github.io/posts/computer_networks/http/http_authentication/</guid><description>Web连接着不计其数的资源，但并不是所有的资源都是可以随意访问的。某些资源只对部分特定的用户开放，为了达到这个目的，需要对用户进行认证（au</description></item><item><title>网关、隧道和中继</title><link>https://zhannicholas.github.io/posts/computer_networks/http/gateway_tunnels_and_relays/</link><pubDate>Sun, 13 Dec 2020 17:07:48 +0800</pubDate><guid>https://zhannicholas.github.io/posts/computer_networks/http/gateway_tunnels_and_relays/</guid><description>Web上所有的资源都可以使用HTTP协议，并且其它应用和应用协议也可以利用HTTP来完成它们的任务。开发者可以将HTTP作为一个框架来使用其</description></item><item><title>HTTP连接管理</title><link>https://zhannicholas.github.io/posts/computer_networks/http/connection_management/</link><pubDate>Sun, 13 Dec 2020 17:05:53 +0800</pubDate><guid>https://zhannicholas.github.io/posts/computer_networks/http/connection_management/</guid><description>HTTP连接是HTTP报文传输的关键通道。 TCP连接 TCP/IP是全球计算机及网络设备都在使用的一个分层包交换协议集，几乎所有的HTTP通信</description></item><item><title>客户端身份识别与Cookie</title><link>https://zhannicholas.github.io/posts/computer_networks/http/client_certification_and_cookies/</link><pubDate>Sun, 13 Dec 2020 16:59:47 +0800</pubDate><guid>https://zhannicholas.github.io/posts/computer_networks/http/client_certification_and_cookies/</guid><description>HTTP 最初是一个匿名、无状态的请求/响应协议。服务器接收客户端请求，处理并回送响应，Web 服务器几乎没有什么信息可以用来判断请求来自于哪个用户。</description></item><item><title>Web缓存</title><link>https://zhannicholas.github.io/posts/computer_networks/http/caching/</link><pubDate>Sun, 13 Dec 2020 16:41:19 +0800</pubDate><guid>https://zhannicholas.github.io/posts/computer_networks/http/caching/</guid><description>Web缓存指的是一些可以自动保存常用文档副本的HTTP设备。当Web请求经过缓存时，如果缓存设备本地存在一个可用的“已缓存”副本，就不需要再</description></item><item><title>路由算法</title><link>https://zhannicholas.github.io/posts/computer_networks/fundamentals/routing_algorithms/</link><pubDate>Sun, 13 Dec 2020 16:34:55 +0800</pubDate><guid>https://zhannicholas.github.io/posts/computer_networks/fundamentals/routing_algorithms/</guid><description>网络层的主要功能就是将数据包从源主机路由到目标主机。在大多数网络中，数据包需要经过多跳才能到达目的地。路由算法负责为入境数据包选择一条输出线</description></item><item><title>延迟与带宽</title><link>https://zhannicholas.github.io/posts/computer_networks/fundamentals/latency_and_bandwidth/</link><pubDate>Sun, 13 Dec 2020 16:06:22 +0800</pubDate><guid>https://zhannicholas.github.io/posts/computer_networks/fundamentals/latency_and_bandwidth/</guid><description>延迟（Latency） 和**带宽（Bandwidth）**是衡量网络性能的两个关键指标。 延迟 延迟是指一个数据包(或一条消息)从发送到被接收这</description></item><item><title>Ip寻址</title><link>https://zhannicholas.github.io/posts/computer_networks/fundamentals/ip_address/</link><pubDate>Sun, 13 Dec 2020 15:44:47 +0800</pubDate><guid>https://zhannicholas.github.io/posts/computer_networks/fundamentals/ip_address/</guid><description>IP地址 IPv4采用的是32位地址，而Ipv6采用的是128位地址。Internet上的每台主机和路由器都有IP地址，但一个IP地址并不真正</description></item><item><title>ZooKeeper单机与伪集群部署</title><link>https://zhannicholas.github.io/posts/getting_started/zookeeper%E5%8D%95%E6%9C%BA%E4%B8%8E%E4%BC%AA%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</link><pubDate>Mon, 30 Sep 2019 13:38:40 +0800</pubDate><guid>https://zhannicholas.github.io/posts/getting_started/zookeeper%E5%8D%95%E6%9C%BA%E4%B8%8E%E4%BC%AA%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</guid><description>ZooKeeper是一个开源的分布式协调服务，可以为分布式计算环境维护配置信息、提供命名、同步、分组等服务。 单机部署 准备Java环境 ZooK</description></item><item><title>初见Redis</title><link>https://zhannicholas.github.io/posts/databases/redis/%E5%88%9D%E8%A7%81redis/</link><pubDate>Wed, 25 Sep 2019 19:24:06 +0800</pubDate><guid>https://zhannicholas.github.io/posts/databases/redis/%E5%88%9D%E8%A7%81redis/</guid><description>Redis是一个位于内存中的数据结构存储系统，可用作数据库、缓存和消息中间件。它支持的数据结构有：string、hash、list、set、</description></item><item><title>Linux添加用户并授予root权限的简单方法</title><link>https://zhannicholas.github.io/posts/linux/linux%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8E%88%E4%BA%88root%E6%9D%83%E9%99%90%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/</link><pubDate>Wed, 13 Feb 2019 16:29:45 +0800</pubDate><guid>https://zhannicholas.github.io/posts/linux/linux%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8E%88%E4%BA%88root%E6%9D%83%E9%99%90%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/</guid><description>快速方法 使用root操作 Step 1: 添加一个用户 adduser username Step 2: 授予root权限 usermod -aG sudo username 但是&amp;hellip;&amp;hellip; 有些时候，这并不管用 在vultr</description></item><item><title>《设计模式的艺术》读书笔记之十三：代理模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%89%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 27 Oct 2018 21:41:48 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%89%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid><description>代理模式（Proxy Pattern）:给某一个对象提供一个代理，并由代理对象控制对原对象的引用。 代理模式中引入了一个新的代理对象，代理对象可</description></item><item><title>《设计模式的艺术》读书笔记之十二：享元模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%BA%8C%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link><pubDate>Wed, 17 Oct 2018 12:24:25 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%BA%8C%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid><description>享元模式（Flyweight Pattern）：运行共享技术有效的支持大量 细粒度 对象的复用，又称轻量级模式。 享元模式以共享的方式高效的支持大量</description></item><item><title>《设计模式的艺术》读书笔记之十一：外观模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 15 Oct 2018 10:39:37 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid><description>外观模式（Facade Pattern）：外部与一个子系统的通信通过一个统一的外观角色进行，为子系统中的一组接口提供一个统一的入口。外观模式又</description></item><item><title>《设计模式的艺术》读书笔记之十：装饰模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 15 Oct 2018 05:23:56 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</guid><description>装饰模式（Decotator Pattern）：动态的给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更加灵活。 装饰模</description></item><item><title>《设计模式的艺术》读书笔记之九：组合模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B9%9D%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 13 Oct 2018 11:16:37 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B9%9D%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid><description>组合模式（Composite Pattern）：组合多个对象形成树形结构以表示具有“整体-部分”关系的层次结构。组合模式对单个对象（叶子对象）</description></item><item><title>《设计模式的艺术》读书笔记之八：桥接模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AB%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link><pubDate>Tue, 09 Oct 2018 08:48:04 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AB%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid><description>桥接模式（Bridge Pattern）：将类的功能层次结构（抽象部分）和实现层次结构（实现部分）分离，使二者能够 独立 的变化，并在二者之间搭建</description></item><item><title>《设计模式的艺术》读书笔记之七：适配器模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%83%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 08 Oct 2018 14:53:10 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%83%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid><description>适配器模式（Adapter Pattern）：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，又称包装器（Wrappe</description></item><item><title>《设计模式的艺术》读书笔记之六：建造者模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 07 Oct 2018 09:04:12 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>建造者模式（Builder Pattern）：将一个复杂的对象的构建与它的表示分离，使得同样的创建过程可以创建不同的表示。建造者模式又称为生成</description></item><item><title>《设计模式的艺术》读书笔记之五：原型模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 06 Oct 2018 11:35:30 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>原型模式（Prototype Pattern）：使用原型实例指定创建对象，并通过克隆这些原型得到新的对象。 原型模式的工作原理就是：将一个原型对</description></item><item><title>《设计模式的艺术》读书笔记之四：抽象工厂模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%9B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 05 Oct 2018 13:17:22 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%9B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列相关或者相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称Ki</description></item><item><title>《设计模式的艺术》读书笔记三：工厂方法模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link><pubDate>Wed, 03 Oct 2018 08:40:29 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid><description>工厂方法模式（Factory Method Pattern）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化，这让一个类的实例化延迟到了其子类。工</description></item><item><title>《设计模式的艺术》读书笔记二：简单工厂模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Tue, 02 Oct 2018 11:04:22 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>简单工厂模式（Simple Factory Pattern）：定义一个工厂类，工厂类根据参数返回不同的实例，被创建的实例通常具有共同的父类。由于创建实例的方</description></item><item><title>《设计模式的艺术》读书笔记一：单例模式</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Oct 2018 13:28:15 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%80%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid><description>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类就是单例类。 从单例模式</description></item><item><title>面向对象设计的7个原则</title><link>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%847%E4%B8%AA%E5%8E%9F%E5%88%99/</link><pubDate>Sat, 29 Sep 2018 20:51:23 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%847%E4%B8%AA%E5%8E%9F%E5%88%99/</guid><description>面向对象设计的7个原则 面向对象设计存在7个原则。在设计中使用这些原则，有助于提高设计模型的灵活性和可维护性，提高类的內聚度，降低类之间的耦合</description></item><item><title>Java Web复习笔记</title><link>https://zhannicholas.github.io/posts/grocery/java-web%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><pubDate>Sun, 19 Aug 2018 23:02:41 +0800</pubDate><guid>https://zhannicholas.github.io/posts/grocery/java-web%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid><description>Java WEB复习笔记 这是为了准备秋招面试而对Java Web开发进行的复习。 首先，对于一个Java Web应用，它由一组Servlet、HTML页、</description></item><item><title>寻找数组中的第K个最大的元素</title><link>https://zhannicholas.github.io/posts/leetcode/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/</link><pubDate>Fri, 20 Jul 2018 10:33:07 +0800</pubDate><guid>https://zhannicholas.github.io/posts/leetcode/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/</guid><description>这是Leetcode上的第215题：数组中的第k个最大元素。 问题描述 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第</description></item><item><title>荷兰国旗问题</title><link>https://zhannicholas.github.io/posts/leetcode/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/</link><pubDate>Thu, 19 Jul 2018 22:15:46 +0800</pubDate><guid>https://zhannicholas.github.io/posts/leetcode/%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98/</guid><description>问题描述 荷兰国旗问题(Dutch national flag problem)是Dijkstra提出的一个经典的编程练习。原问题大概是这样说的： Dijkstra used the Dutch National Flag Problem* as a structured programming</description></item><item><title>北邮回忆</title><link>https://zhannicholas.github.io/posts/grocery/%E5%8C%97%E9%82%AE%E5%9B%9E%E5%BF%86/</link><pubDate>Wed, 18 Jul 2018 08:26:18 +0800</pubDate><guid>https://zhannicholas.github.io/posts/grocery/%E5%8C%97%E9%82%AE%E5%9B%9E%E5%BF%86/</guid><description>在北邮一年的交换学习已经结束。仔细想想我这一年，好像并没有什么值得一提的。在我的印象里，第一学期的大多数时间都花在了学校开设的课程上，总是在</description></item><item><title>产生均匀随机排列的两种方法</title><link>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/two-ways-to-produce-a-uniform-random-permutation/</link><pubDate>Wed, 11 Jul 2018 12:46:30 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/two-ways-to-produce-a-uniform-random-permutation/</guid><description>许多随机算法通过排列给定的输入数组来使输入随机化。这里的目标是构造数组 A 的一个随机排列。 方法一：排序 为数组的每一个元素 A[i] 分配一个随机的优先级</description></item><item><title>通过偏概率0/1生成器，得到无偏概率0/1生成器</title><link>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/%E9%80%9A%E8%BF%8701%E6%9C%89%E5%81%8F%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%97%A0%E5%81%8F%E6%A6%82%E7%8E%87/</link><pubDate>Wed, 11 Jul 2018 09:51:21 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/%E9%80%9A%E8%BF%8701%E6%9C%89%E5%81%8F%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%97%A0%E5%81%8F%E6%A6%82%E7%8E%87/</guid><description>问题描述 这是《算法导论》的习题5.1-3： 假设你希望以各1/2的概率输出0和1。你可以自由使用一个输出0或1的过程BIASED-RANDOM</description></item><item><title>配置Anaconda源</title><link>https://zhannicholas.github.io/posts/python/anaconda-source-configuration/</link><pubDate>Sat, 07 Jul 2018 09:38:08 +0800</pubDate><guid>https://zhannicholas.github.io/posts/python/anaconda-source-configuration/</guid><description>Anaconda 是一个 **python** 的发行版，可以用来管理 python** 的包和环境，同时它包含1000+的开源package。正如那句话一样：\ _The Most Trusted Distribution for Data Science_\ 还有一个没有包含那么</description></item><item><title>矩阵乘法</title><link>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/matrix-multiplication/</link><pubDate>Mon, 02 Jul 2018 08:44:56 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/matrix-multiplication/</guid><description>矩阵乘法 矩阵相乘只有在第一个矩阵的列数（column）和第二个矩阵的行数（row）相同时才有定义。若 A 为 m x n 矩阵，B为 n x p 矩阵，则他们的</description></item><item><title>最大子数组问题</title><link>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/maximum-sub-array-problem/</link><pubDate>Fri, 29 Jun 2018 10:44:26 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/introduction_to_algorithms/maximum-sub-array-problem/</guid><description>问题 有一个数组A，寻找一个 A[] 的子数组 B[] ， 使得B的元素和大于A的任何一个子数组。比如A = [13, -3, 25, 20, -4, -20, -25, 18, 20, -5, 16, -5, -22, 18, -6, 8], 我们要求的 B[] 就是：[1</description></item><item><title>树</title><link>https://zhannicholas.github.io/notebook/reading_notes/algorithms_in_c/binary-tree/</link><pubDate>Sat, 02 Jun 2018 10:07:28 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/algorithms_in_c/binary-tree/</guid><description>树是满足一定要求的顶点和边的非空集合。 二叉树 二叉树的每个节点至多有2个子节点。 一种表示方法： struct Node{type key; Node *lchild, *richild;} typedef Node *link; 这种表示方法只适合从根节点开始</description></item><item><title>各种排序算法</title><link>https://zhannicholas.github.io/notebook/reading_notes/algorithms_in_c/sorting/</link><pubDate>Wed, 30 May 2018 18:55:31 +0800</pubDate><guid>https://zhannicholas.github.io/notebook/reading_notes/algorithms_in_c/sorting/</guid><description>学习《C算法》中排序这一部分时做的一些笔记。主要使用C++实现了书中的大部分排序算法。 开始之前 为了方便增加代码的灵活性，我采取了书中作者的部</description></item><item><title>Git初探</title><link>https://zhannicholas.github.io/posts/git/about-git/</link><pubDate>Wed, 30 May 2018 15:56:02 +0800</pubDate><guid>https://zhannicholas.github.io/posts/git/about-git/</guid><description>开始 文件的三种状态 已提交(committed) 数据已经安全的保存在了本地的数据库中 已修改(modified) 修改了文件，但还没保存到数据库中</description></item></channel></rss>